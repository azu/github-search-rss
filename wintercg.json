{
    "version": "https://jsonfeed.org/version/1",
    "title": "org:wintercg Issues",
    "home_page_url": "https://azu.github.io/github-search-rss/wintercg.json",
    "feed_url": "https://azu.github.io/github-search-rss/wintercg.json",
    "description": "org:wintercg Issues on GitHub",
    "items": [
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/8225977?u=ebf8bbc30918fe9c36833005bebc027a65984f34&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><p dir=\"auto\"><a href=\"https://fetch.spec.whatwg.org/#port-blocking\" rel=\"nofollow\">https://fetch.spec.whatwg.org/#port-blocking</a></p>\n<p dir=\"auto\">Those ports are usually for services other than HTTP, and you usually won't have HTTP servers on those. They're probably blocked to prevent sending an HTTP request that might be parsed as a different protocol.</p>\n<p dir=\"auto\">In browsers there's also the concern that this port blocking might be used to prevent remote websites messing with local network services. There are other mechanisms to prevent this for HTTP requests, but they might not work in the case of an attacker-controlled HTTP request being parsed as some other protocol. In that case, this probably isn't a concern that applies to servers, but it might apply to CLI processes (e.g. Node or Deno applications) running in a computer.</p>",
            "url": "https://github.com/wintercg/fetch-workstream/issues/10",
            "title": "Should we block bad ports?",
            "date_modified": "2025-04-03T15:10:23.000Z",
            "date_published": "2025-04-03T15:10:23.000Z",
            "author": {
                "name": "andreubotella",
                "url": "https://github.com/andreubotella"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/29357907?u=5b1be4accbf0796916d326a344e5c36655396dde&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><p dir=\"auto\">It seems like something similar to Electron. At least on the frontend side<br>\n<a href=\"https://tauri.app/\" rel=\"nofollow\">https://tauri.app/</a></p>",
            "url": "https://github.com/wintercg/runtime-keys/issues/21",
            "title": "Add tauri to draft?",
            "date_modified": "2025-03-24T21:06:13.000Z",
            "date_published": "2025-03-24T21:06:13.000Z",
            "author": {
                "name": "nikelborm",
                "url": "https://github.com/nikelborm"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/29357907?u=5b1be4accbf0796916d326a344e5c36655396dde&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><p dir=\"auto\">I'm not sure if it's appropriate for that proposal, but I think it might be</p>\n<p dir=\"auto\"><a href=\"https://github.com/facebook/hermes\">https://github.com/facebook/hermes</a></p>",
            "url": "https://github.com/wintercg/runtime-keys/issues/20",
            "title": "Add info about hermes and static hermes to the draft?",
            "date_modified": "2025-03-24T21:01:11.000Z",
            "date_published": "2025-03-24T20:57:42.000Z",
            "author": {
                "name": "nikelborm",
                "url": "https://github.com/nikelborm"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/7829205?u=280fa15bf97605fa9a7a1d331327485daaad7871&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><h2 dir=\"auto\">AbortSignal</h2>\n<ul dir=\"auto\">\n<li><code class=\"notranslate\">AbortController</code></li>\n<li><code class=\"notranslate\">AbortSignal</code></li>\n</ul>\n<div class=\"snippet-clipboard-content notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"+dom/abort/*\n-dom/abort/reason-constructor.html\"><pre class=\"notranslate\"><code class=\"notranslate\">+dom/abort/*\n-dom/abort/reason-constructor.html\n</code></pre></div>\n<h2 dir=\"auto\">Web Crypto API</h2>\n<ul dir=\"auto\">\n<li>Crypto</li>\n<li>CryptoKey</li>\n<li>SubtleCrypto</li>\n<li>globalThis.crypto</li>\n</ul>\n<div class=\"snippet-clipboard-content notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"+WebCryptoAPI/*\n-historical.any.*\n-algorithm-discards-context.https.window.*\"><pre class=\"notranslate\"><code class=\"notranslate\">+WebCryptoAPI/*\n-historical.any.*\n-algorithm-discards-context.https.window.*\n</code></pre></div>\n<h2 dir=\"auto\">Console</h2>\n<ul dir=\"auto\">\n<li>globalThis.console</li>\n</ul>\n<div class=\"snippet-clipboard-content notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"+console/*\"><pre class=\"notranslate\"><code class=\"notranslate\">+console/*\n</code></pre></div>\n<p dir=\"auto\">Tests are very sparse, and so is spec - it is unclear what side-effects <code class=\"notranslate\">console.log</code> should have across runtimes.</p>\n<h2 dir=\"auto\">Streams</h2>\n<ul dir=\"auto\">\n<li>ByteLengthQueuingStrategy</li>\n<li>CountQueuingStrategy</li>\n<li>ReadableByteStreamController</li>\n<li>ReadableStream</li>\n<li>ReadableStreamBYOBReader</li>\n<li>ReadableStreamBYOBRequest</li>\n<li>ReadableStreamDefaultController</li>\n<li>ReadableStreamDefaultReader</li>\n<li>TransformStream</li>\n<li>TransformStreamDefaultController</li>\n<li>WritableStream</li>\n<li>WritableStreamDefaultController</li>\n<li>WritableStreamDefaultWriter</li>\n</ul>\n<div class=\"snippet-clipboard-content notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"+streams/*\n-streams/readable-streams/cross-realm-crash.window.html\"><pre class=\"notranslate\"><code class=\"notranslate\">+streams/*\n-streams/readable-streams/cross-realm-crash.window.html\n</code></pre></div>\n<p dir=\"auto\"><code class=\"notranslate\">streams/transferable/*</code> needs investigation.</p>\n<h2 dir=\"auto\">(De)compression streams</h2>\n<ul dir=\"auto\">\n<li>CompressionStream</li>\n<li>DecompressionStream</li>\n</ul>\n<div class=\"snippet-clipboard-content notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"+compression/*\"><pre class=\"notranslate\"><code class=\"notranslate\">+compression/*\n</code></pre></div>\n<h2 dir=\"auto\">Text encoding</h2>\n<ul dir=\"auto\">\n<li>TextDecoder</li>\n<li>TextDecoderStream</li>\n<li>TextEncoder</li>\n<li>TextEncoderStream</li>\n</ul>\n<div class=\"snippet-clipboard-content notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"+encoding/*\n-encoding/streams/realms.window.html\n-encoding/streams/invalid-realm.window.html\n-encoding/unsupported-encodings.any.*\n-encoding/single-byte-decoder.window.html\n-encoding/unsupported-labels.window.html\"><pre class=\"notranslate\"><code class=\"notranslate\">+encoding/*\n-encoding/streams/realms.window.html\n-encoding/streams/invalid-realm.window.html\n-encoding/unsupported-encodings.any.*\n-encoding/single-byte-decoder.window.html\n-encoding/unsupported-labels.window.html\n</code></pre></div>\n<h2 dir=\"auto\">URL</h2>\n<ul dir=\"auto\">\n<li>URL</li>\n<li>URLSearchParams</li>\n</ul>\n<div class=\"snippet-clipboard-content notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"+url/*\n-url/url-setters-a-area.window.html\n-url/a-element-origin.html\n-url/a-element.html\n-url/data-uri-fragment.html\n-url/failure.html\n\"><pre class=\"notranslate\"><code class=\"notranslate\">+url/*\n-url/url-setters-a-area.window.html\n-url/a-element-origin.html\n-url/a-element.html\n-url/data-uri-fragment.html\n-url/failure.html\n\n</code></pre></div>\n<p dir=\"auto\">Note, a lot of tests in this directory also test using <code class=\"notranslate\">&lt;a&gt;</code> and <code class=\"notranslate\">&lt;area&gt;</code> tags from HTML. It would be good to split those into seperate files.</p>\n<h2 dir=\"auto\">URLPattern</h2>\n<ul dir=\"auto\">\n<li>URLPattern</li>\n</ul>\n<div class=\"snippet-clipboard-content notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"+urlpattern/urlpattern.any.*\n+urlpattern/urlpattern-https.any.*\n+urlpattern/urlpattern-hasregexpgroups.any.*\"><pre class=\"notranslate\"><code class=\"notranslate\">+urlpattern/urlpattern.any.*\n+urlpattern/urlpattern-https.any.*\n+urlpattern/urlpattern-hasregexpgroups.any.*\n</code></pre></div>\n<h2 dir=\"auto\">File API</h2>\n<ul dir=\"auto\">\n<li>Blob</li>\n<li>File</li>\n</ul>\n<div class=\"snippet-clipboard-content notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"+FileAPI/blob/*\n-FileAPI/blob/Blob-constructor-dom.window.html\n+FileAPI/file/*\n-FileAPI/file/send-file-form-*\n+FileAPI/url/url-format.any.*\n+FileAPI/url/url-with-fetch.any.*\n+FileAPI/unicode.html\"><pre class=\"notranslate\"><code class=\"notranslate\">+FileAPI/blob/*\n-FileAPI/blob/Blob-constructor-dom.window.html\n+FileAPI/file/*\n-FileAPI/file/send-file-form-*\n+FileAPI/url/url-format.any.*\n+FileAPI/url/url-with-fetch.any.*\n+FileAPI/unicode.html\n</code></pre></div>\n<p dir=\"auto\">A lot of these tests rely on FileReader existing. Should we add this?</p>",
            "url": "https://github.com/wintercg/proposal-minimum-common-api/issues/86",
            "title": "WPT analysis",
            "date_modified": "2025-03-21T14:42:03.000Z",
            "date_published": "2025-03-20T15:23:55.000Z",
            "author": {
                "name": "lucacasonato",
                "url": "https://github.com/lucacasonato"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/1148376?u=97348b862d4820275f7e7567ad64a72edfec1443&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><p dir=\"auto\">Just like reading <code class=\"notranslate\">status</code>, <code class=\"notranslate\">statusText</code> and final <code class=\"notranslate\">url</code>  i also wish there where a <code class=\"notranslate\">protocol</code> information on <code class=\"notranslate\">Response</code> object itself.<br>\ni want to know if the network call that was used when fetching some resource did decide to use <code class=\"notranslate\">http/1.1</code> <code class=\"notranslate\">http/2</code> or any other.</p>\n<p dir=\"auto\">likewise i which i could also control what protocol should be used or sending a preferred ordered. most gRPC applications do not support <code class=\"notranslate\">http/1.1</code> which is the default protocol being used with fetch stuff with standard fetch api.</p>\n<p dir=\"auto\">A gRPC service i used did support both both 1.1 and 2<br>\nBut when i made a request with <code class=\"notranslate\">fetch</code> to that server, it responded with 426 status saying basically saying: http/1.1 is not supported, use h2 instead</p>\n<p dir=\"auto\">if it had only supported h2 then that would have been a different story</p>\n<p dir=\"auto\">i which i could do something like</p>\n<div class=\"highlight highlight-source-js notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"new Request(url, { \n  // working similar to Content Negotiation headers\n  protocol: &quot;http/2=1; http/1.1=0.5, */*;q=0.2&quot;,\n\n  // or\n  protocol: ['h2', 'http/1.1', '*']\n}) \"><pre class=\"notranslate\"><span class=\"pl-k\">new</span> <span class=\"pl-v\">Request</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">url</span><span class=\"pl-kos\">,</span> <span class=\"pl-kos\">{</span> \n  <span class=\"pl-c\">// working similar to Content Negotiation headers</span>\n  <span class=\"pl-c1\">protocol</span>: <span class=\"pl-s\">\"http/2=1; http/1.1=0.5, */*;q=0.2\"</span><span class=\"pl-kos\">,</span>\n\n  <span class=\"pl-c\">// or</span>\n  <span class=\"pl-c1\">protocol</span>: <span class=\"pl-kos\">[</span><span class=\"pl-s\">'h2'</span><span class=\"pl-kos\">,</span> <span class=\"pl-s\">'http/1.1'</span><span class=\"pl-kos\">,</span> <span class=\"pl-s\">'*'</span><span class=\"pl-kos\">]</span>\n<span class=\"pl-kos\">}</span><span class=\"pl-kos\">)</span> </pre></div>",
            "url": "https://github.com/wintercg/fetch-workstream/issues/9",
            "title": "Controlling & inform ALPN protocol",
            "date_modified": "2025-03-14T14:04:25.000Z",
            "date_published": "2025-03-14T14:04:25.000Z",
            "author": {
                "name": "jimmywarting",
                "url": "https://github.com/jimmywarting"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/439929?u=88483145a53c3d594ab68146c1a8bdecc3bcd1d3&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><p dir=\"auto\">The <code class=\"notranslate\">MessageChannel</code> and <code class=\"notranslate\">MessagePort</code> APIs are supported by Node.js, Deno, and Bun. I am currently looking into implementing support in Cloudflare Workers. Are there any objections to adding these to the minimum common API?</p>",
            "url": "https://github.com/wintercg/proposal-minimum-common-api/issues/85",
            "title": "MessageChannel and MessagePort",
            "date_modified": "2025-03-20T15:36:40.000Z",
            "date_published": "2025-03-10T22:19:48.000Z",
            "author": {
                "name": "jasnell",
                "url": "https://github.com/jasnell"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/241506?u=13324b3ac27dc54cdde3ac635d567d0d96b88876&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><p dir=\"auto\">I've been chatting with <a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/jricher/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/jricher\">@jricher</a>, one of the authors of <a href=\"https://www.rfc-editor.org/rfc/rfc9421.html\" rel=\"nofollow\">RFC 9421 HTTP Message Signatures</a><sup><a href=\"#user-content-fn-playground-00d52284e764c1c62c3a5eac1383390b\" id=\"user-content-fnref-playground-00d52284e764c1c62c3a5eac1383390b\" data-footnote-ref=\"\" aria-describedby=\"footnote-label\">1</a></sup>, at the OAuth Security Workshop (#osw10) in Iceland and at IETF 121 Dublin about the forming of TC55 and its fetch() related workstream.</p>\n<p dir=\"auto\">Setting up application-level signatures has never been easy but with RFC 9421 being published last year there's finally a solid framework to be able to make it so. I believe an integration of HTTP Message Signatures and Web Crypto APIs <code class=\"notranslate\">CryptoKey</code> would be a worthwhile and Web API-native solution.</p>\n<p dir=\"auto\">Justin and I are both willing to collaborate on bringing HTTP Message Signatures support to server-side fetch() and Request/Response APIs (the former in hopes of it even standing a chance of ever appearing in browserland).</p>\n<section data-footnotes=\"\" class=\"footnotes\"><h2 id=\"footnote-label\" class=\"sr-only\" dir=\"auto\">Footnotes</h2>\n<ol dir=\"auto\">\n<li id=\"user-content-fn-playground-00d52284e764c1c62c3a5eac1383390b\">\n<p dir=\"auto\"><a href=\"https://httpsig.org/\">Playground for HTTP Message Signatures</a> <a href=\"#user-content-fnref-playground-00d52284e764c1c62c3a5eac1383390b\" data-footnote-backref=\"\" aria-label=\"Back to reference 1\" class=\"data-footnote-backref\">‚Ü©</a></p>\n</li>\n</ol>\n</section>",
            "url": "https://github.com/wintercg/fetch-workstream/issues/8",
            "title": "HTTP Message Signatures (RFC 9421) in fetch and Request/Response",
            "date_modified": "2025-03-06T15:05:09.000Z",
            "date_published": "2025-03-02T17:42:38.000Z",
            "author": {
                "name": "panva",
                "url": "https://github.com/panva"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/241506?u=13324b3ac27dc54cdde3ac635d567d0d96b88876&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><p dir=\"auto\">Original issue: <a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load title\" data-id=\"1549637680\" data-permission-text=\"Title is private\" data-url=\"https://github.com/wintercg/fetch/issues/3\" data-hovercard-type=\"issue\" data-hovercard-url=\"/wintercg/fetch/issues/3/hovercard\" href=\"https://github.com/wintercg/fetch/issues/3\">wintercg/fetch#3</a></p>\n<p dir=\"auto\">I would like to propose that the TC pursue standardization of Mutual TLS authentication extensions to the fetch() and Request API to accomodate both making API requests that employ Mutual TLS authentication, as well as being able to access client certificate information as part of incoming Request objects. These are quite possibly two different features.</p>",
            "url": "https://github.com/wintercg/fetch-workstream/issues/7",
            "title": "Mutual TLS (mTLS) handling in fetch() and Request",
            "date_modified": "2025-03-18T09:33:56.000Z",
            "date_published": "2025-03-02T17:29:34.000Z",
            "author": {
                "name": "panva",
                "url": "https://github.com/panva"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/7829205?u=280fa15bf97605fa9a7a1d331327485daaad7871&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><ul dir=\"auto\">\n<li>\n<p dir=\"auto\"><code class=\"notranslate\">Request.method</code>: ‚úÖ</p>\n</li>\n<li>\n<p dir=\"auto\"><code class=\"notranslate\">Request.url</code>: ‚úÖ</p>\n</li>\n<li>\n<p dir=\"auto\"><code class=\"notranslate\">Request.headers</code>: ‚úÖ</p>\n</li>\n<li>\n<p dir=\"auto\"><code class=\"notranslate\">Request.destination</code>: ‚ùå do not have the property (ie <code class=\"notranslate\">\"destination\" in req === false</code>)</p>\n</li>\n<li>\n<p dir=\"auto\"><code class=\"notranslate\">Request.referrer</code>: ‚ùå do not have the property</p>\n</li>\n<li>\n<p dir=\"auto\"><code class=\"notranslate\">Request.referrerPolicy</code>: ‚ùå do not have the property</p>\n</li>\n<li>\n<p dir=\"auto\"><code class=\"notranslate\">Request.mode</code>: ‚ùå do not have the property</p>\n</li>\n<li>\n<p dir=\"auto\"><code class=\"notranslate\">Request.credentials</code>: ‚ùå do not have the property</p>\n</li>\n<li>\n<p dir=\"auto\"><code class=\"notranslate\">Request.cache</code>: ‚úÖ (with considerations as to the default)</p>\n</li>\n<li>\n<p dir=\"auto\"><code class=\"notranslate\">Request.redirect</code>: ‚úÖ</p>\n</li>\n<li>\n<p dir=\"auto\"><code class=\"notranslate\">Request.integrity</code>: ‚úÖ (as specified)</p>\n</li>\n<li>\n<p dir=\"auto\"><code class=\"notranslate\">Request.keepalive</code>: ‚ùå do not have the property</p>\n</li>\n<li>\n<p dir=\"auto\"><code class=\"notranslate\">Request.isReloadNavigation</code>: ‚ùå do not have the property</p>\n</li>\n<li>\n<p dir=\"auto\"><code class=\"notranslate\">Request.isHistoryNavigation</code>: ‚ùå do not have the property</p>\n</li>\n<li>\n<p dir=\"auto\"><code class=\"notranslate\">Request.signal</code>: ‚úÖ</p>\n</li>\n<li>\n<p dir=\"auto\"><code class=\"notranslate\">Request.duplex</code>: ‚úÖ (same caviats as <a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load title\" data-id=\"2866690164\" data-permission-text=\"Title is private\" data-url=\"https://github.com/wintercg/fetch-workstream/issues/5\" data-hovercard-type=\"issue\" data-hovercard-url=\"/wintercg/fetch-workstream/issues/5/hovercard\" href=\"https://github.com/wintercg/fetch-workstream/issues/5\">#5</a>)</p>\n</li>\n<li>\n<p dir=\"auto\"><code class=\"notranslate\">Response.type</code>: ‚úÖ</p>\n<ul dir=\"auto\">\n<li>Requires some more exploration</li>\n<li>Likely only \"default\" and \"error\" are used, because all other things are cors related</li>\n</ul>\n</li>\n<li>\n<p dir=\"auto\"><code class=\"notranslate\">Response.url</code>: ‚úÖ</p>\n</li>\n<li>\n<p dir=\"auto\"><code class=\"notranslate\">Response.redirected</code>: ‚úÖ</p>\n</li>\n<li>\n<p dir=\"auto\"><code class=\"notranslate\">Response.status</code>: ‚úÖ</p>\n</li>\n<li>\n<p dir=\"auto\"><code class=\"notranslate\">Response.ok</code>: ‚úÖ</p>\n</li>\n<li>\n<p dir=\"auto\"><code class=\"notranslate\">Response.statusText</code>: ‚úÖ</p>\n</li>\n<li>\n<p dir=\"auto\"><code class=\"notranslate\">Response.headers</code>: ‚úÖ</p>\n</li>\n</ul>",
            "url": "https://github.com/wintercg/fetch-workstream/issues/6",
            "title": "Handling of properties in Request / Response objects",
            "date_modified": "2025-02-20T16:41:28.000Z",
            "date_published": "2025-02-20T16:41:28.000Z",
            "author": {
                "name": "lucacasonato",
                "url": "https://github.com/lucacasonato"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/7829205?u=280fa15bf97605fa9a7a1d331327485daaad7871&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><p dir=\"auto\">That covers <code class=\"notranslate\">RequestInit</code> and <code class=\"notranslate\">ResponseInit</code>:</p>\n<ul dir=\"auto\">\n<li>\n<p dir=\"auto\"><code class=\"notranslate\">RequestInit.method</code>: ‚úÖ</p>\n</li>\n<li>\n<p dir=\"auto\"><code class=\"notranslate\">RequestInit.headers</code>: ‚úÖ</p>\n</li>\n<li>\n<p dir=\"auto\"><code class=\"notranslate\">RequestInit.body</code>: ‚úÖ (Node.js diverges because it supports AsyncIterables here)</p>\n</li>\n<li>\n<p dir=\"auto\"><code class=\"notranslate\">RequestInit.signal</code>: ‚úÖ</p>\n</li>\n<li>\n<p dir=\"auto\"><code class=\"notranslate\">RequestInit.redirect</code>:</p>\n<ul dir=\"auto\">\n<li><code class=\"notranslate\">follow</code>: ‚úÖ</li>\n<li><code class=\"notranslate\">error</code>: ‚úÖ</li>\n<li><code class=\"notranslate\">manual</code>: ‚úÖ, but divergence because the returned response is not opaque. On the browser it is opaque because of <a href=\"https://fetch.spec.whatwg.org/#atomic-http-redirect-handling\" rel=\"nofollow\">Atomic HTTP redirect handling</a> - this security feature is not needed on servers.</li>\n</ul>\n</li>\n<li>\n<p dir=\"auto\"><code class=\"notranslate\">RequestInit.integrity</code>: üü†</p>\n<ul dir=\"auto\">\n<li>Must be verified, and if the supported integrity string is not supported, must throw.</li>\n<li>At minimum must support <code class=\"notranslate\">undefined</code> and <code class=\"notranslate\">\"\"</code>.</li>\n<li>We think this may be useful on the server, but it should be up to the host to determine to what extent they implement this.</li>\n</ul>\n</li>\n<li>\n<p dir=\"auto\"><code class=\"notranslate\">RequestInit.duplex</code>: ‚úÖ</p>\n<ul dir=\"auto\">\n<li>We should spec what <code class=\"notranslate\">duplex: full</code> means</li>\n<li>We should try to get <code class=\"notranslate\">duplex: full</code> to be the default in browsers</li>\n<li>We should start enforcing <code class=\"notranslate\">duplex: \"half\"</code> if you want half duplex in server environments</li>\n</ul>\n</li>\n<li>\n<p dir=\"auto\"><code class=\"notranslate\">RequestInit.cache</code>: üü†</p>\n<ul dir=\"auto\">\n<li>Verify the property is valid</li>\n<li>The default on server runtimes is <code class=\"notranslate\">no-store</code> or <code class=\"notranslate\">no-cache</code>, not <code class=\"notranslate\">default</code></li>\n<li>Runtimes must send the correct cache control header corresponding to the specified option</li>\n<li>Runtimes do not actually have to cache responses in a client side cache</li>\n<li>Verify if the spec allows implementations to \"downgrade\" to lower cache level (like no-store) even if a higher value is specified, for example in Incognito windows. If so, we do not need to throw on unsupported valid values.</li>\n<li>Figure out how <code class=\"notranslate\">default</code> and Cloudflare's default behaviour differ - do we need another value to specify that behaviour?</li>\n</ul>\n</li>\n<li>\n<p dir=\"auto\"><code class=\"notranslate\">RequestInit.priority</code>: üü†</p>\n<ul dir=\"auto\">\n<li>Either implement as specced, or completely ignore it</li>\n</ul>\n</li>\n<li>\n<p dir=\"auto\"><code class=\"notranslate\">RequestInit.referrer</code>: ‚ùå ignore completely (do not get off init)</p>\n<ul dir=\"auto\">\n<li>Servers don't have an active site/origin so there is no referrer</li>\n</ul>\n</li>\n<li>\n<p dir=\"auto\"><code class=\"notranslate\">RequestInit.referrerPolicy</code>: ‚ùå ignore completely</p>\n<ul dir=\"auto\">\n<li>If you don't have a referrer, you don't need a policy for them</li>\n</ul>\n</li>\n<li>\n<p dir=\"auto\"><code class=\"notranslate\">RequestInit.mode</code>: ‚ùå silently ignore</p>\n<ul dir=\"auto\">\n<li>CORS is not relevant on the server</li>\n</ul>\n</li>\n<li>\n<p dir=\"auto\"><code class=\"notranslate\">RequestInit.credentials</code>: ‚ùå silently ignore</p>\n<ul dir=\"auto\">\n<li>CORS is not relevant on the server</li>\n<li>Check that <code class=\"notranslate\">credentials: omit</code> does not remove explicitly set auth headers - if so, reconsider</li>\n</ul>\n</li>\n<li>\n<p dir=\"auto\"><code class=\"notranslate\">RequestInit.keepalive</code>: ‚ùå silently ignore</p>\n<ul dir=\"auto\">\n<li>Related to tab lifetime, not relevant to server runtimes</li>\n</ul>\n</li>\n<li>\n<p dir=\"auto\"><code class=\"notranslate\">RequestInit.window</code>: ‚ùå silently ignore</p>\n<ul dir=\"auto\">\n<li>no windows</li>\n</ul>\n</li>\n<li>\n<p dir=\"auto\"><code class=\"notranslate\">ResponseInit.status</code>: ‚úÖ</p>\n</li>\n<li>\n<p dir=\"auto\"><code class=\"notranslate\">ResponseInit.statusText</code>: ‚úÖ</p>\n</li>\n<li>\n<p dir=\"auto\"><code class=\"notranslate\">ResponseInit.headers</code>: ‚úÖ</p>\n</li>\n</ul>\n<p dir=\"auto\">‚úÖ = mandatory<br>\nüü† = sometimes<br>\n‚ùå = ignore</p>",
            "url": "https://github.com/wintercg/fetch-workstream/issues/5",
            "title": "Handling of properties in Request/Response init dictionaries",
            "date_modified": "2025-02-20T16:32:08.000Z",
            "date_published": "2025-02-20T16:32:08.000Z",
            "author": {
                "name": "lucacasonato",
                "url": "https://github.com/lucacasonato"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/598730?u=62984c4f4ede922870c5cc2dbdf498926c7c0f9e&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><p dir=\"auto\">The runtime keys gives useful information about the environment to the resolver, but there is currently no way to inspect this information from within the runtime environment.</p>\n<p dir=\"auto\">I understand this proposal is moving to a more general package.json spec, but before we do that, I wanted to discuss the possibility of an <code class=\"notranslate\">import.meta.runtime</code> object which would expose a frozen bag of booleans corresponding to the runtime key environment.</p>\n<p dir=\"auto\">Would be useful for platform checks:</p>\n<div class=\"snippet-clipboard-content notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"if (import.meta.runtime.node) { ... }\"><pre class=\"notranslate\"><code class=\"notranslate\">if (import.meta.runtime.node) { ... }\n</code></pre></div>\n<p dir=\"auto\">As well as dev / production checks:</p>\n<div class=\"snippet-clipboard-content notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"if (import.meta.runtime?.development) { ... }\"><pre class=\"notranslate\"><code class=\"notranslate\">if (import.meta.runtime?.development) { ... }\n</code></pre></div>\n<p dir=\"auto\">Having a standard like this would get support between Node.js and tools - of course we can't get support in browsers, but that might be acceptable having this as a build time inlining. And perhaps the browser does even define <code class=\"notranslate\">import.meta.runtime = { browser: true }</code> one day.</p>",
            "url": "https://github.com/wintercg/runtime-keys/issues/19",
            "title": "import.meta.runtime",
            "date_modified": "2025-02-18T14:20:50.000Z",
            "date_published": "2025-02-17T22:07:24.000Z",
            "author": {
                "name": "guybedford",
                "url": "https://github.com/guybedford"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/7829205?u=280fa15bf97605fa9a7a1d331327485daaad7871&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><p dir=\"auto\">On the web, the <code class=\"notranslate\">set-cookie</code> and <code class=\"notranslate\">set-cookie2</code> are stripped from incoming responses when a response is shown to the user. For servers, this does not make sense because they do not have a cookie jar that would automatically handle these cookies.</p>\n<p dir=\"auto\">We should allow reading these headers.</p>",
            "url": "https://github.com/wintercg/fetch-workstream/issues/4",
            "title": "Allow cookie related headers in incoming requests",
            "date_modified": "2025-02-07T10:42:01.000Z",
            "date_published": "2025-02-07T10:42:01.000Z",
            "author": {
                "name": "lucacasonato",
                "url": "https://github.com/lucacasonato"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/7829205?u=280fa15bf97605fa9a7a1d331327485daaad7871&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><p dir=\"auto\">The <code class=\"notranslate\">cookie</code> and <code class=\"notranslate\">cookie2</code> are stripped from outgoing requests when set by the user on the web. For servers, this does not make sense because they do not have a cookie jar.</p>\n<p dir=\"auto\">We should allow setting these headers.</p>\n<p dir=\"auto\">The outbound <code class=\"notranslate\">set-cookie</code> header is disallowed only because of technical difficulty with implementation in browsers - we could keep this disallowed, or allow it - it does not matter much I think.</p>",
            "url": "https://github.com/wintercg/fetch-workstream/issues/3",
            "title": "Allow cookie related headers in outgoing requests",
            "date_modified": "2025-02-07T10:40:54.000Z",
            "date_published": "2025-02-07T10:40:54.000Z",
            "author": {
                "name": "lucacasonato",
                "url": "https://github.com/lucacasonato"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/7829205?u=280fa15bf97605fa9a7a1d331327485daaad7871&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><p dir=\"auto\">In the browser, <code class=\"notranslate\">accept-charset</code>, <code class=\"notranslate\">date</code>, <code class=\"notranslate\">dnt</code>, <code class=\"notranslate\">origin</code>, <code class=\"notranslate\">referer</code>, <code class=\"notranslate\">via</code>, <code class=\"notranslate\">proxy-*</code>, <code class=\"notranslate\">sec-*</code>, <code class=\"notranslate\">x-http-method</code>, <code class=\"notranslate\">x-http-method-override</code>, and <code class=\"notranslate\">x-method-override</code> are disallowed because they should not be spoofable by users.</p>\n<p dir=\"auto\">On the server however, these are not security sensitive, so they do not have to be stripped from outgoing requests.</p>",
            "url": "https://github.com/wintercg/fetch-workstream/issues/2",
            "title": "Allowing various anti-spoofing headers for outgoing requests",
            "date_modified": "2025-02-07T14:06:04.000Z",
            "date_published": "2025-02-07T10:36:12.000Z",
            "author": {
                "name": "lucacasonato",
                "url": "https://github.com/lucacasonato"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/7829205?u=280fa15bf97605fa9a7a1d331327485daaad7871&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><p dir=\"auto\">This issue links out to all the different parts of the spec that we need to investigate changes in (that we have found so far):</p>\n<ul dir=\"auto\">\n<li>Allowed request headers\n<ul dir=\"auto\">\n<li><a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load title\" data-id=\"2837819735\" data-permission-text=\"Title is private\" data-url=\"https://github.com/wintercg/fetch-workstream/issues/2\" data-hovercard-type=\"issue\" data-hovercard-url=\"/wintercg/fetch-workstream/issues/2/hovercard\" href=\"https://github.com/wintercg/fetch-workstream/issues/2\">#2</a></li>\n<li><a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load title\" data-id=\"2837829918\" data-permission-text=\"Title is private\" data-url=\"https://github.com/wintercg/fetch-workstream/issues/3\" data-hovercard-type=\"issue\" data-hovercard-url=\"/wintercg/fetch-workstream/issues/3/hovercard\" href=\"https://github.com/wintercg/fetch-workstream/issues/3\">#3</a></li>\n<li>All other headers should stay forbidden:\n<ul dir=\"auto\">\n<li><code class=\"notranslate\">accept-encoding</code> is related to auto-decompression, see below</li>\n<li><code class=\"notranslate\">keep-alive</code>, <code class=\"notranslate\">transfer-encoding</code>, <code class=\"notranslate\">TE</code> are HTTP/1.1 specific headers that are managed by the underlying HTTP stack itself</li>\n<li><code class=\"notranslate\">trailers</code> are not supported in fetch yet (see below)</li>\n<li><code class=\"notranslate\">upgrade</code>, as there is no upgrade mechanism in fetch (see below)</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Allowed response headers\n<ul dir=\"auto\">\n<li><a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load title\" data-id=\"2837832206\" data-permission-text=\"Title is private\" data-url=\"https://github.com/wintercg/fetch-workstream/issues/4\" data-hovercard-type=\"issue\" data-hovercard-url=\"/wintercg/fetch-workstream/issues/4/hovercard\" href=\"https://github.com/wintercg/fetch-workstream/issues/4\">#4</a></li>\n</ul>\n</li>\n<li><code class=\"notranslate\">content-encoding</code> / <code class=\"notranslate\">content-length</code> header sanitization after auto-decompression of the body\n<ul dir=\"auto\">\n<li><a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load title\" data-id=\"2052984038\" data-permission-text=\"Title is private\" data-url=\"https://github.com/whatwg/fetch/issues/1729\" data-hovercard-type=\"issue\" data-hovercard-url=\"/whatwg/fetch/issues/1729/hovercard\" href=\"https://github.com/whatwg/fetch/issues/1729\">whatwg/fetch#1729</a></li>\n</ul>\n</li>\n<li>Handling of Request and Response properties in init and objects:\n<ul dir=\"auto\">\n<li><a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load title\" data-id=\"2866690164\" data-permission-text=\"Title is private\" data-url=\"https://github.com/wintercg/fetch-workstream/issues/5\" data-hovercard-type=\"issue\" data-hovercard-url=\"/wintercg/fetch-workstream/issues/5/hovercard\" href=\"https://github.com/wintercg/fetch-workstream/issues/5\">#5</a></li>\n<li><a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load title\" data-id=\"2866713575\" data-permission-text=\"Title is private\" data-url=\"https://github.com/wintercg/fetch-workstream/issues/6\" data-hovercard-type=\"issue\" data-hovercard-url=\"/wintercg/fetch-workstream/issues/6/hovercard\" href=\"https://github.com/wintercg/fetch-workstream/issues/6\">#6</a></li>\n</ul>\n</li>\n<li>Connection pooling\n<ul dir=\"auto\">\n<li>Network partition key is the agent. If a runtime has no notion of agents/clients, then there could be multiple partition keys. All global <code class=\"notranslate\">fetch</code> calls with no explicit agent share a network partition key.</li>\n<li>Connection pooling: pretty hand-wavey, seems like this is generally only specified for timing. \"This is intentionally a little vague\"</li>\n</ul>\n</li>\n<li>Port blocking\n<ul dir=\"auto\">\n<li>Need to investigate what different runtimes do</li>\n<li>Probably needs to be normative optional - there are use cases where you want to permit sending requests to <em>any</em> port</li>\n</ul>\n</li>\n<li>No request blocking based on mime type</li>\n<li>HTTP extensions\n<ul dir=\"auto\">\n<li><code class=\"notranslate\">origin</code> header should not be set: servers sometimes treat requests with these specially.</li>\n</ul>\n</li>\n</ul>\n<p dir=\"auto\">There are also some features we have identified as possibly being useful:</p>\n<ul dir=\"auto\">\n<li>Trailers</li>\n<li>HTTP Upgrade API</li>\n<li>Letting users set <code class=\"notranslate\">content-length</code> for HTTP streams</li>\n<li>API to receive interim responses (100 / 101 status code)</li>\n<li>Allowing async iterables in request / response bodies</li>\n<li>Disabling automatic response body decompression</li>\n</ul>",
            "url": "https://github.com/wintercg/fetch-workstream/issues/1",
            "title": "Tracking issue",
            "date_modified": "2025-04-03T15:46:32.000Z",
            "date_published": "2025-02-07T10:34:19.000Z",
            "author": {
                "name": "lucacasonato",
                "url": "https://github.com/lucacasonato"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/241506?u=13324b3ac27dc54cdde3ac635d567d0d96b88876&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><p dir=\"auto\">This is very much related to <a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load title\" data-id=\"1668941156\" data-permission-text=\"Title is private\" data-url=\"https://github.com/wintercg/runtime-keys/issues/5\" data-hovercard-type=\"issue\" data-hovercard-url=\"/wintercg/runtime-keys/issues/5/hovercard\" href=\"https://github.com/wintercg/runtime-keys/issues/5\">#5</a>, it highlights its importance and issues in the module ecosystem stemming from runtimes such as Bun and Deno pretending to be Node.js</p>\n<p dir=\"auto\">From the very <a href=\"https://runtime-keys.proposal.wintercg.org/#example-usage\" rel=\"nofollow\">example in the proposal</a></p>\n<div class=\"highlight highlight-source-js notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"&quot;exports&quot;: {\n    &quot;node&quot;: &quot;./dist/node/index.js&quot;,\n    &quot;deno&quot;: &quot;./dist/deno/index.js&quot;\n},\"><pre class=\"notranslate\"><span class=\"pl-s\">\"exports\"</span>: <span class=\"pl-kos\">{</span>\n    <span class=\"pl-s\">\"node\"</span>: <span class=\"pl-s\">\"./dist/node/index.js\"</span><span class=\"pl-kos\">,</span>\n    <span class=\"pl-s\">\"deno\"</span>: <span class=\"pl-s\">\"./dist/deno/index.js\"</span>\n<span class=\"pl-kos\">}</span><span class=\"pl-kos\">,</span></pre></div>\n<p dir=\"auto\">or an extended one</p>\n<div class=\"highlight highlight-source-js notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"&quot;exports&quot;: {\n    &quot;node&quot;: &quot;./dist/node/index.js&quot;,\n    &quot;deno&quot;: &quot;./dist/deno/index.js&quot;,\n    &quot;bun&quot;: &quot;./dist/bun/index.js&quot;\n},\"><pre class=\"notranslate\"><span class=\"pl-s\">\"exports\"</span>: <span class=\"pl-kos\">{</span>\n    <span class=\"pl-s\">\"node\"</span>: <span class=\"pl-s\">\"./dist/node/index.js\"</span><span class=\"pl-kos\">,</span>\n    <span class=\"pl-s\">\"deno\"</span>: <span class=\"pl-s\">\"./dist/deno/index.js\"</span><span class=\"pl-kos\">,</span>\n    <span class=\"pl-s\">\"bun\"</span>: <span class=\"pl-s\">\"./dist/bun/index.js\"</span>\n<span class=\"pl-kos\">}</span><span class=\"pl-kos\">,</span></pre></div>\n<p dir=\"auto\">While lacking resolution for <a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load title\" data-id=\"1668941156\" data-permission-text=\"Title is private\" data-url=\"https://github.com/wintercg/runtime-keys/issues/5\" data-hovercard-type=\"issue\" data-hovercard-url=\"/wintercg/runtime-keys/issues/5/hovercard\" href=\"https://github.com/wintercg/runtime-keys/issues/5\">#5</a> and at least some prescribed lookup behaviour one would mistakenly think that the following means \"everything but node loads from the webapi dist\".</p>\n<div class=\"highlight highlight-source-js notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"&quot;exports&quot;: {\n    &quot;node&quot;: &quot;./dist/node/index.js&quot;,\n    &quot;default&quot;: &quot;./dist/webapi/index.js&quot;\n},\"><pre class=\"notranslate\"><span class=\"pl-s\">\"exports\"</span>: <span class=\"pl-kos\">{</span>\n    <span class=\"pl-s\">\"node\"</span>: <span class=\"pl-s\">\"./dist/node/index.js\"</span><span class=\"pl-kos\">,</span>\n    <span class=\"pl-s\">\"default\"</span>: <span class=\"pl-s\">\"./dist/webapi/index.js\"</span>\n<span class=\"pl-kos\">}</span><span class=\"pl-kos\">,</span></pre></div>\n<p dir=\"auto\">Unfortunately that is not the case. Only Node.js correctly loads its intended export, while both Bun and Deno load \"node\" <strong>in all three examples above</strong> because of their compatibility beliefs and undescribed key order matching (all runtimes just look from top to bottom for a first hit).</p>\n<p dir=\"auto\">I believe the proposal needs <a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load title\" data-id=\"1668941156\" data-permission-text=\"Title is private\" data-url=\"https://github.com/wintercg/runtime-keys/issues/5\" data-hovercard-type=\"issue\" data-hovercard-url=\"/wintercg/runtime-keys/issues/5/hovercard\" href=\"https://github.com/wintercg/runtime-keys/issues/5\">#5</a> combined with at least some text around how the keys are to be used.</p>\n<p dir=\"auto\">For example:</p>\n<ul dir=\"auto\">\n<li>add \"wintercg\" or similar which effectively behaves as \"default\" does in the Node.js resolution algorithm</li>\n<li>prescribe that runtimes must first look for their own key, then wintercg/default, and only then fallback on proprietary resolution algorithms</li>\n</ul>\n<p dir=\"auto\">The alternative (today's behaviour) is that module authors need to maintain an ever growing list of keys in their package.json on the offchance that a new runtime is added that inherits from Deno or Bun in that they believe they can work with \"node\" exports</p>",
            "url": "https://github.com/wintercg/runtime-keys/issues/18",
            "title": "Runtime's own key resolution should be at least somewhat defined",
            "date_modified": "2024-11-08T15:17:53.000Z",
            "date_published": "2024-10-31T07:52:38.000Z",
            "author": {
                "name": "panva",
                "url": "https://github.com/panva"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/567540?u=8c4489cd158bb1a7fffff338fc832359a113955e&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><p dir=\"auto\">Some code that runs in either the browser or a non-browser environment may have dedicated code paths for each, e.g. because certain code isn't expected to work- or to be exposed in browsers (or vice versa). The only API that is exposed in the minimum common API appears to be <code class=\"notranslate\">navigator.userAgent</code> and it looks fragile when it comes to detecting browser vs non-browser environments.</p>\n<p dir=\"auto\">Are there plans to have a clear signal that can be used to detect the presence of the minimum common API?</p>",
            "url": "https://github.com/wintercg/proposal-minimum-common-api/issues/77",
            "title": "Detect common API vs browser",
            "date_modified": "2024-10-30T18:52:52.000Z",
            "date_published": "2024-10-28T17:44:10.000Z",
            "author": {
                "name": "jkrems",
                "url": "https://github.com/jkrems"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/567540?u=8c4489cd158bb1a7fffff338fc832359a113955e&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><p dir=\"auto\">The current spec text seems ambiguous so I was interested in the semantics: it links to the HTML spec for userAgent which says that the value is used as the default value for the User-Agent header. Is that true for the property here as well? Will fetch() by default use that value?</p>",
            "url": "https://github.com/wintercg/proposal-minimum-common-api/issues/76",
            "title": "navigator.userAgent and User-Agent",
            "date_modified": "2024-10-24T00:17:28.000Z",
            "date_published": "2024-10-24T00:17:28.000Z",
            "author": {
                "name": "jkrems",
                "url": "https://github.com/jkrems"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/8225977?u=ebf8bbc30918fe9c36833005bebc027a65984f34&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><p dir=\"auto\">The File System API is a relatively recent web standard, now implemented in all browsers, that allows accessing and modifying files in the file system. All browsers allow access through this API to a virtual filesystem, unique to a page's origin, through <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/StorageManager/getDirectory\" rel=\"nofollow\"><code class=\"notranslate\">await navigator.storage.getDirectory()</code></a>, that you can't go outside of.</p>\n<p dir=\"auto\">However, Chromium extends this by providing additional APIs (such as <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Window/showOpenFilePicker\" rel=\"nofollow\"><code class=\"notranslate\">window.showOpenFilePicker()</code></a>) that give you access to arbitrary files and directories in the file system. Although other browsers are opposed to implementing these APIs because of safety and privacy concerns, this is not an issue for server-side runtimes.</p>\n<p dir=\"auto\">I have heard that this API is not a great fit for server-side environments, but (as someone who hasn't looked in depth at the API and considered it) those concerns are not clear to me. So I opened this issue to have a place to discuss what it's missing, whether we can work with WHATWG to fix that, and also to discuss WinterCG extensions similar to <code class=\"notranslate\">showOpenFilePicker()</code>.</p>",
            "url": "https://github.com/wintercg/proposal-minimum-common-api/issues/73",
            "title": "Considering the File System API",
            "date_modified": "2024-07-03T01:57:04.000Z",
            "date_published": "2024-07-02T08:55:34.000Z",
            "author": {
                "name": "andreubotella",
                "url": "https://github.com/andreubotella"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/9669289?u=1dba106891d6c062871da687242942532ea26005&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><p dir=\"auto\">Hi there, at the <a href=\"https://webengineshackfest.org/\" rel=\"nofollow\">Web Engines Hackfest</a> I raised the question of how to get a WinterCG \"position\" about new web API proposals. Along with others, <a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/littledan/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/littledan\">@littledan</a> mentioned that for now, filing issues against this repository will do.</p>\n<p dir=\"auto\">I'd like to get Winter's position on the Observable API, as proposed in <a href=\"https://github.com/WICG/observable\">https://github.com/WICG/observable</a>. Observables are a <a href=\"https://github.com/whatwg/dom/issues/544\" data-hovercard-type=\"issue\" data-hovercard-url=\"/whatwg/dom/issues/544/hovercard\">long-awaited</a> and <a href=\"https://foolip.github.io/spec-reactions/\" rel=\"nofollow\">highly desired</a> ergonomic improvement for event handling.</p>\n<p dir=\"auto\">I'll admit I'd still like to do my research on where exactly the line should be drawn between Observables and Signals in terms of their usage (at the moment I know almost nothing about Signals except for what some people described to me in person). But still it would be good to get a gut check on this proposal by experts over here, sooner than later. Thanks!</p>",
            "url": "https://github.com/wintercg/proposal-minimum-common-api/issues/72",
            "title": "Requesting a position on the Observable API",
            "date_modified": "2024-06-17T07:10:14.000Z",
            "date_published": "2024-06-06T13:43:19.000Z",
            "author": {
                "name": "domfarolino",
                "url": "https://github.com/domfarolino"
            }
        }
    ]
}