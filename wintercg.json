{
    "version": "https://jsonfeed.org/version/1",
    "title": "org:wintercg Issues",
    "home_page_url": "https://azu.github.io/github-search-rss/wintercg.json",
    "feed_url": "https://azu.github.io/github-search-rss/wintercg.json",
    "description": "org:wintercg Issues on GitHub",
    "items": [
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/16144158?u=82cadd66bfcfcd8340269a3c0ce30f503acaf7b4&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><h2 dir=\"auto\">Introduction</h2>\n<p dir=\"auto\">As <em>runtime keys</em> have begun being adopted for individual platforms, some developers have  asked for some kind of common key indicating a package is compatible with the WinterCG <a href=\"https://common-min-api.proposal.wintercg.org/\" rel=\"nofollow\">Minimum Common API</a>, and thus the package will work in any framework that is also compatible with the Minimum Common API.</p>\n<p dir=\"auto\">The simplest solution is to add a <code class=\"notranslate\">\"wintercg\"</code> key that indicates Minimum Common API compliance. However, this solution is incomplete.</p>\n<p dir=\"auto\">Since the Minimum Common API specification can change overtime, discrepancies can form between frameworks and packages that both claim to be compliant with the standard. For example, consider ECMAScript. When a developer uses ES2020 features in their code, but the target system can only handle ES6 code, their project simply wont work. To parallel that to the Minimum Common API, imagine if the standard was to change and add a new interface. A developer then uses that new interface in their project, and expects to be able to run their project on any framework that indicates its <code class=\"notranslate\">\"wintercg\"</code> compatible. Lets assume a framework hasn't been able to add that new interface yet. This developer's project will not work in that particular framework.</p>\n<blockquote>\n<p dir=\"auto\">There are plenty more examples to demonstrate how \"wintercg\" key alone is insufficient, but lets move on to a better solution proposal</p>\n</blockquote>\n<h2 dir=\"auto\">Proposed Solution</h2>\n<p dir=\"auto\">There are multiple pieces to this problem</p>\n<ul dir=\"auto\">\n<li>How can frameworks reliably indicate they comply with the Minimum Common API?</li>\n<li>How can a library or application author indicate their thing is compatible with any framework that complies with the Minimum Common API?</li>\n<li>How can tools check at build-time and run-time that a given library or application is compatible with current framework?</li>\n</ul>\n<h3 dir=\"auto\">How can frameworks reliably indicate they comply with the Minimum Common API?</h3>\n<p dir=\"auto\">Browser have had a solution to this for a long time, web platform tests. If we create a similar test suite for the Minimum Common API (and maybe even use the existing WPT), frameworks can automatically test themselves against it and report the results to a public tool such as <a href=\"http://caniuse.com/\" rel=\"nofollow\">caniuse.com</a>.</p>\n<h3 dir=\"auto\">How can a library or application author indicate their thing is compatible with any framework that complies with the Minimum Common API?</h3>\n<p dir=\"auto\">Given the usage example in the Runtime Keys specification, libraries and applications can use the <code class=\"notranslate\">\"engines\"</code> fields in <code class=\"notranslate\">package.json</code> to indicate what framework version (or version range) they can be used in. By introducing a <code class=\"notranslate\">\"wintercg\"</code> key as well as <strong>versioning methodology</strong> for that represents compliance with the Minimum Common API, projects could specify exactly what version of the specification they are compliant with.</p>\n<h3 dir=\"auto\">How can tools check at build-time and run-time that a given library or application is compatible with current framework?</h3>\n<p dir=\"auto\">Incorporating the <strong>versioning methodology</strong> into the test suite compliance tool, build-time and run-time tooling can be instrumented to compare values between what specified in a project‚Äôs configuration file (like <code class=\"notranslate\">package.json</code>) with what has been publicly recorded and verify if the given project is supported.</p>\n<h3 dir=\"auto\">Versioning Methodology</h3>\n<blockquote>\n<p dir=\"auto\">This part of the proposal is where I believe much of the debate will be. Two options are provided to start the discussion. Please feel free to provide more options for consideration.</p>\n</blockquote>\n<p dir=\"auto\"><strong>Option 1</strong>: Annual versioning</p>\n<ul dir=\"auto\">\n<li>Works like ECMAScript</li>\n<li>At the beginning of the year, we release ‚ÄúWinterCG Minimum Common API ‚Äù, for example ‚ÄúWinterCG Minimum Common API 2023‚Äù</li>\n<li>Throughout the remainder of the year, changes are added to a ‚Äúnext‚Äù version of the spec.</li>\n<li>Keys could look like <code class=\"notranslate\">wintercg-2023</code> and <code class=\"notranslate\">wintercg-next</code></li>\n<li>But when used in something like <code class=\"notranslate\">engines</code>, they may be used like <code class=\"notranslate\">\"wintercg\": \"2023\"</code> instead</li>\n<li>For 2023 specifically, we would work to solidify and release the current spec as. And then we‚Äôd start the annual release format starting in 2024.</li>\n</ul>\n<p dir=\"auto\"><strong>Option 2:</strong> semver</p>\n<ul dir=\"auto\">\n<li>Works like many of the frameworks do</li>\n<li>Breaking changes are included in Major versions</li>\n<li>New features are included in Minor versions</li>\n<li>Fixes are included in Patch versions</li>\n<li>Keys could look like <code class=\"notranslate\">wintercg-1.0.0</code> and <code class=\"notranslate\">wintercg-2.3.4</code></li>\n<li>Similar to annual model, they keys could also be used like <code class=\"notranslate\">\"wintercg\": \"1.0.0\"</code></li>\n</ul>\n<h2 dir=\"auto\">Next Steps</h2>\n<p dir=\"auto\">Thank you for reading this proposal. Please comment your thoughts and feedback in this issue thread or in the WinterCG Matrix channel. We will discuss this proposal at the next WinterCG call on May 4th, 2023. It will also be presented during my talk at Open Source Summit on May 10th. <g-emoji class=\"g-emoji\" alias=\"rocket\" fallback-src=\"https://github.githubassets.com/images/icons/emoji/unicode/1f680.png\">üöÄ</g-emoji></p>",
            "url": "https://github.com/wintercg/runtime-keys/issues/5",
            "title": "WinterCG Common key proposal",
            "date_modified": "2023-04-19T09:37:33.000Z",
            "date_published": "2023-04-14T20:56:22.000Z",
            "author": {
                "name": "Ethan-Arrowood",
                "url": "https://github.com/Ethan-Arrowood"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/7829205?u=5a9294123bdf7301054aacbc88fda275f72ad4cb&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><p dir=\"auto\">Use the compliance modes from <a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load title\" data-id=\"1613807165\" data-permission-text=\"Title is private\" data-url=\"https://github.com/wintercg/fetch/issues/19\" data-hovercard-type=\"pull_request\" data-hovercard-url=\"/wintercg/fetch/pull/19/hovercard\" href=\"https://github.com/wintercg/fetch/pull/19\">#19</a> throughout the spec:</p>\n<ul class=\"contains-task-list\">\n<li class=\"task-list-item\"><input type=\"checkbox\" id=\"\" disabled=\"\" class=\"task-list-item-checkbox\"> CORS</li>\n<li class=\"task-list-item\"><input type=\"checkbox\" id=\"\" disabled=\"\" class=\"task-list-item-checkbox\"> Cookies</li>\n<li class=\"task-list-item\"><input type=\"checkbox\" id=\"\" disabled=\"\" class=\"task-list-item-checkbox\"> Caching</li>\n<li class=\"task-list-item\"><input type=\"checkbox\" id=\"\" disabled=\"\" class=\"task-list-item-checkbox\"> Service workers</li>\n<li class=\"task-list-item\"><input type=\"checkbox\" id=\"\" disabled=\"\" class=\"task-list-item-checkbox\"> Basic auth popup</li>\n</ul>",
            "url": "https://github.com/wintercg/fetch/issues/20",
            "title": "Use compliance modes throughout",
            "date_modified": "2023-03-31T10:02:38.000Z",
            "date_published": "2023-03-30T15:36:57.000Z",
            "author": {
                "name": "lucacasonato",
                "url": "https://github.com/lucacasonato"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/908303?v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><p dir=\"auto\">Hey <g-emoji class=\"g-emoji\" alias=\"wave\" fallback-src=\"https://github.githubassets.com/images/icons/emoji/unicode/1f44b.png\">üëã</g-emoji> Thanks for working on this, and apologies for not looking at the spec earlier!</p>\n<p dir=\"auto\">As a high-level comment, I would argue <code class=\"notranslate\">EncryptionStream</code> should live in the same namespace as <code class=\"notranslate\">crypto.subtle.encrypt</code>. After all, it's equally \"subtle\" as that function, and people should be careful not to use unauthenticated algorithms by themselves, for example. So I think having some indication of that in the name (e.g. <code class=\"notranslate\">crypto.subtle.EncryptionStream</code>) would be good.</p>\n<p dir=\"auto\">Also, without necessarily advocating for doing so, if we ever want to add <code class=\"notranslate\">DecryptionStream</code>, that would be even more \"subtle\" (since you have to be careful not to accidentally use unauthenticated data), so that should definitely have to live under <code class=\"notranslate\">SubtleCrypto</code>, IMO.</p>",
            "url": "https://github.com/wintercg/proposal-webcrypto-streams/issues/6",
            "title": "Move EncryptionStream to SubtleCrypto?",
            "date_modified": "2023-02-08T19:02:23.000Z",
            "date_published": "2023-02-08T18:59:15.000Z",
            "author": {
                "name": "twiss",
                "url": "https://github.com/twiss"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/4174848?v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><p dir=\"auto\">What is the end-goal of this repository? What does a deliverable look like?</p>",
            "url": "https://github.com/wintercg/proposal-common-minimum-api/issues/37",
            "title": "Is this repository concerned with only Node.js and Deno - not QuickJS, txiki.js, Bun?",
            "date_modified": "2023-02-12T00:24:24.000Z",
            "date_published": "2023-01-14T16:49:17.000Z",
            "author": {
                "name": "guest271314",
                "url": "https://github.com/guest271314"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/1148376?u=97348b862d4820275f7e7567ad64a72edfec1443&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><p dir=\"auto\">I have played around with Deno's built in test runner before.<br>\nit's pretty nice. but i tend to not use it if i'm also writing test cases that should run in different env.</p>\n<p dir=\"auto\">When i write test cases for both NodeJS and Deno then i tend to simply just use a simple array or an object myself to define all test cases and import all files that i want to test. Then i just use a simple logic function that are very similar to <code class=\"notranslate\">console.assert</code> but it throws instead. then i simply just write a for loop to exec all functions, if the env match Deno then i use <code class=\"notranslate\">Deno.test</code> otherwise it have just been a classic for loop that execute. very simple and fast but lose a lot of shiny features for the cost of being more cross compatible. I'm not such a huge fan of any of the existing test framework that exist out there on npm atm.</p>\n<p dir=\"auto\">now i found out that NodeJS also have a test <a href=\"https://nodejs.org/api/test.html\" rel=\"nofollow\">runner built in</a></p>\n<p dir=\"auto\">it would be nice if both could play ball and work the same way...<br>\nI know this isn't something web related but it would be nice if i could write test cases the same way.<br>\nWould even wish for there to be some browserified version of it too.</p>\n<p dir=\"auto\">Bonus point if there where something like <code class=\"notranslate\">node --test --browsers</code> that could launch maybe a headless browser or where i could open up a own browser and navigate to url to hook it in.</p>\n<ul dir=\"auto\">\n<li>then it would dump everything to the console,</li>\n<li>talk with each other over websocket</li>\n<li>hook it into file changes</li>\n<li>have some good CI/CD that could execute all test cases in a browser and exit with either an error or a success in the terminal</li>\n</ul>",
            "url": "https://github.com/wintercg/proposal-common-minimum-api/issues/32",
            "title": "Same test api",
            "date_modified": "2022-12-18T06:20:35.000Z",
            "date_published": "2022-12-18T01:21:23.000Z",
            "author": {
                "name": "jimmywarting",
                "url": "https://github.com/jimmywarting"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/5900105?u=3a9f6d65f8ec7432d6ce35bb83c4a8c95ea10ca3&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><p dir=\"auto\">My company is looking for integrating WinterCG common minimum API into TypeScript config, in order to provide type checking, error highlighting, autocomplete, etc.</p>\n<h1 dir=\"auto\">1. <a href=\"https://github.com/tsconfig/bases/\">TypeScript base config</a></h1>\n<p dir=\"auto\">Developers may be able to write something like this in tsconfig.json:</p>\n<div class=\"highlight highlight-source-json notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{\n  &quot;extends&quot;: &quot;@tsconfig/wintercg/tsconfig.json&quot;\n}\"><pre class=\"notranslate\">{\n  <span class=\"pl-ent\">\"extends\"</span>: <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>@tsconfig/wintercg/tsconfig.json<span class=\"pl-pds\">\"</span></span>\n}</pre></div>\n<p dir=\"auto\">This tsconfig should at least support the common minimum APIs which are listed in <a href=\"https://blog.cloudflare.com/introducing-the-wintercg/\" rel=\"nofollow\">https://blog.cloudflare.com/introducing-the-wintercg/</a> and <a href=\"https://common-min-api.proposal.wintercg.org/\" rel=\"nofollow\">https://common-min-api.proposal.wintercg.org/</a>.</p>\n<p dir=\"auto\">Install the wintercg tsconfig:</p>\n<div class=\"highlight highlight-source-shell notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"npm install --save-dev @tsconfig/wintercg\nyarn add --dev @tsconfig/wintercg\"><pre class=\"notranslate\">npm install --save-dev @tsconfig/wintercg\nyarn add --dev @tsconfig/wintercg</pre></div>\n<h1 dir=\"auto\">2. <a href=\"https://www.typescriptlang.org/tsconfig#lib\" rel=\"nofollow\"><code class=\"notranslate\">lib</code></a></h1>\n<p dir=\"auto\">Provide WinterCG common minimum API access in the <code class=\"notranslate\">lib</code> configuration. For example: <code class=\"notranslate\">lib</code> can be set to <code class=\"notranslate\">WinterCG</code>.</p>\n<p dir=\"auto\"><a target=\"_blank\" rel=\"noopener noreferrer nofollow\" href=\"https://user-images.githubusercontent.com/5900105/199933617-f56dbf2c-3c99-4c58-83d2-28ecda2e1d64.png\"><img src=\"https://user-images.githubusercontent.com/5900105/199933617-f56dbf2c-3c99-4c58-83d2-28ecda2e1d64.png\" alt=\"Screenshot from 2022-11-04 16-59-36\" style=\"max-width: 100%;\"></a></p>",
            "url": "https://github.com/wintercg/proposal-common-minimum-api/issues/31",
            "title": "Provide TypeScript config for minimum common API",
            "date_modified": "2022-11-05T03:49:49.000Z",
            "date_published": "2022-11-04T06:31:36.000Z",
            "author": {
                "name": "ytxmobile98",
                "url": "https://github.com/ytxmobile98"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/16144158?u=82cadd66bfcfcd8340269a3c0ce30f503acaf7b4&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><p dir=\"auto\">As promised a few calls ago, I have been working on drafting the initial specification for WinterCG Fetch. I've had many discussions with multiple folks and I have arrived at two options for us. I'd like us to decide on one of them as the organization structure for our specification. Once agreed; I will continue <a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load title\" data-id=\"1549639442\" data-permission-text=\"Title is private\" data-url=\"https://github.com/wintercg/fetch/issues/11\" data-hovercard-type=\"issue\" data-hovercard-url=\"/wintercg/fetch/issues/11/hovercard\" href=\"https://github.com/wintercg/fetch/issues/11\">#11</a> and get our base line specification published.</p>\n<h3 dir=\"auto\">Option 1</h3>\n<p dir=\"auto\">The first option is to create a fork of <code class=\"notranslate\">whatwg/fetch</code> here in wintercg. We will utilize aspects of the <a href=\"https://tabatkins.github.io/bikeshed/\" rel=\"nofollow\">Bikeshed</a> language (which is what <code class=\"notranslate\">whatwg/fetch</code> is written in) to omit sections and include notes/extensions for aspects that we want to modify.</p>\n<p dir=\"auto\">We will be responsible for rebasing our modifications every time Fetch lands a change to the specification. This could be partially automated where we create a bot that watches the <code class=\"notranslate\">whatwg/fetch</code> repo, and anytime new commit(s) are merged to <code class=\"notranslate\">main</code>, it would open a branch and attempts to do the necessary git operations. Of course, if there are merge conflicts they would need to be settled by a contributor here in WinterCG.</p>\n<p dir=\"auto\">This will ensure our specification is always up to date with the latest whatwg version.</p>\n<p dir=\"auto\">This option has a long-term maintenance cost where members of WinterCG would be responsible for managing the rebasing overtime. As stated, it could be automated, but it wouldn't be a perfect solution as whenever conflicts arise someone would have to spend time fixing them.</p>\n<h3 dir=\"auto\">Option 2</h3>\n<p dir=\"auto\">The second option is to start with essentially an empty specification that states something along the lines of: \"Unless otherwise specified in this document, WinterCG Fetch is compatible with the latest edition of WHATWG Fetch specification\". Then, overtime as we agree on modifications to <code class=\"notranslate\">whatwg/fetch</code>, we will create new sections within our document that states the necessary changes. For example, lets pretend we agree to get rid of the entire concept of \"Forbidden Headers\". Our specification may include a section such as:</p>\n<blockquote>\n<p dir=\"auto\">Please note this is purely for demonstration purposes. The WinterCG has made no decisions regarding modifications to the Whatwg Fetch API and the content in the following example is purely hypothetical. Do not use this issue thread to discuss the nuance of the example.</p>\n</blockquote>\n<div class=\"snippet-clipboard-content notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"### Headers\n\n#### Modification of Forbidden Headers List\n\nSection [2.2.2 Headers #forbidden-header-name](https://fetch.spec.whatwg.org/#forbidden-header-name) of the whatwg/fetch specification states a list of header names that are considered &quot;forbidden&quot;. During runtime execution of the Fetch API, usage of a forbidden header results in an early return such as in the [Concept Headers append](https://fetch.spec.whatwg.org/#concept-headers-append) section.\n\nWinterCG Fetch deviates from this section by stating that there are **no** forbidden headers. A WinterCG Fetch API will not return early if it encounters one of these headers.\"><pre class=\"notranslate\"><code class=\"notranslate\">### Headers\n\n#### Modification of Forbidden Headers List\n\nSection [2.2.2 Headers #forbidden-header-name](https://fetch.spec.whatwg.org/#forbidden-header-name) of the whatwg/fetch specification states a list of header names that are considered \"forbidden\". During runtime execution of the Fetch API, usage of a forbidden header results in an early return such as in the [Concept Headers append](https://fetch.spec.whatwg.org/#concept-headers-append) section.\n\nWinterCG Fetch deviates from this section by stating that there are **no** forbidden headers. A WinterCG Fetch API will not return early if it encounters one of these headers.\n</code></pre></div>\n<p dir=\"auto\">This option has less maintenance burden as it could essentially stagnate while remaining \"up to date\". With the catch all statement stating that essentially WinterCG Fetch <strong>is</strong> WHATWG Fetch unless otherwise noted. The WHATWG Fetch could land changes and unless we need to deviate from those changes, we don't have to modify our specification.</p>\n<p dir=\"auto\">Unfortunately, this also means that if we are not on top of changes to WHATWG Fetch, we could incorrectly be supporting something they add that we want to deviate from. Arguably, implementations don't generally move as quickly as standards. And so even if there is a bit of a lag between us coming to decision on a hypothetical change to WHATWG Fetch, many implementers would already be apart of the conversation and it wouldn't have much impact.</p>\n<hr>\n<p dir=\"auto\">With these two options, please react to this post with which one you prefer more to give us a sense of what folks are preferring. We will also be discussing this at upcoming wintercg calls. When we come to a majority decision I will create the initial proposal draft. In the mean time, we can being making API decisions for WinterCG Fetch - capture the result in issues, and when we eventually get our proposal created, I can add those decisions to the initial draft. Also please feel free to use this issue to discuss details of either option too.</p>\n<p dir=\"auto\">Thank you!</p>\n<p dir=\"auto\">Option 1 - react with: <g-emoji class=\"g-emoji\" alias=\"smile\" fallback-src=\"https://github.githubassets.com/images/icons/emoji/unicode/1f604.png\">üòÑ</g-emoji></p>\n<p dir=\"auto\">Option 2 - react with: <g-emoji class=\"g-emoji\" alias=\"rocket\" fallback-src=\"https://github.githubassets.com/images/icons/emoji/unicode/1f680.png\">üöÄ</g-emoji></p>",
            "url": "https://github.com/wintercg/fetch/issues/12",
            "title": "Specification outline",
            "date_modified": "2023-01-19T17:40:58.000Z",
            "date_published": "2022-10-19T21:40:11.000Z",
            "author": {
                "name": "Ethan-Arrowood",
                "url": "https://github.com/Ethan-Arrowood"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/241506?u=5c10f2bbf617c297b2ceb8d0e827906007a7d5a7&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><p dir=\"auto\">A lot of times I encounter the need to single a specific runtime out. For instance, all wintercg runtimes meet my criteria except <code class=\"notranslate\">node</code>.</p>\n<p dir=\"auto\">What I'm looking for is key setup which allows me to put specific runtimes infront of a wintercg catchall.</p>",
            "url": "https://github.com/wintercg/runtime-keys/issues/1",
            "title": "wintercg-specific fallback",
            "date_modified": "2022-11-11T01:58:28.000Z",
            "date_published": "2022-10-05T06:06:05.000Z",
            "author": {
                "name": "panva",
                "url": "https://github.com/panva"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/2842176?v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><p dir=\"auto\">For exceptions from <code class=\"notranslate\">Promise</code>, we can simply use <code class=\"notranslate\">unhandledrejection</code>. But how about exceptions that not come from <code class=\"notranslate\">Promise</code>? Is there any way to specify the behavior?</p>",
            "url": "https://github.com/wintercg/proposal-common-minimum-api/issues/29",
            "title": "How to deal with something like `UncaughtException`?",
            "date_modified": "2022-09-18T19:44:16.000Z",
            "date_published": "2022-09-14T06:54:55.000Z",
            "author": {
                "name": "XadillaX",
                "url": "https://github.com/XadillaX"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/439929?u=88483145a53c3d594ab68146c1a8bdecc3bcd1d3&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><p dir=\"auto\">Within Workers we have been having a discussion about how to communicate to users via Errors that the conditions leading to an error are temporary and that the user should retry their operation. The how and when to retry is not important here.</p>\n<p dir=\"auto\">For example, a <code class=\"notranslate\">fetch()</code> promise can fail for many reasons. The network path could temporarily be down, the URL could be blocked, the header could be malformated, etc. We want to be able to clearly indicate that the user can/should retry their operation <em>without</em> requiring that the user resort to parsing the error message.</p>\n<p dir=\"auto\">We have several possible paths forward, all of which have the same fundamental problem. We'd like to get consensus on which approach folks would find the most agreeable.</p>\n<h2 dir=\"auto\">Option 1: New error types</h2>\n<div class=\"highlight highlight-source-js notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"const err = new Error('an error occurred');\nObject.defineProperty(err, 'name', { value: 'RetriableError' });\"><pre class=\"notranslate\"><span class=\"pl-k\">const</span> <span class=\"pl-s1\">err</span> <span class=\"pl-c1\">=</span> <span class=\"pl-k\">new</span> <span class=\"pl-v\">Error</span><span class=\"pl-kos\">(</span><span class=\"pl-s\">'an error occurred'</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-v\">Object</span><span class=\"pl-kos\">.</span><span class=\"pl-en\">defineProperty</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">err</span><span class=\"pl-kos\">,</span> <span class=\"pl-s\">'name'</span><span class=\"pl-kos\">,</span> <span class=\"pl-kos\">{</span> <span class=\"pl-c1\">value</span>: <span class=\"pl-s\">'RetriableError'</span> <span class=\"pl-kos\">}</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">;</span></pre></div>\n<h2 dir=\"auto\">Option 2: Non-standard own properties on <code class=\"notranslate\">Error</code></h2>\n<div class=\"highlight highlight-source-js notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"const err = new Error('an error occurred');\nerr.retriable = true;\"><pre class=\"notranslate\"><span class=\"pl-k\">const</span> <span class=\"pl-s1\">err</span> <span class=\"pl-c1\">=</span> <span class=\"pl-k\">new</span> <span class=\"pl-v\">Error</span><span class=\"pl-kos\">(</span><span class=\"pl-s\">'an error occurred'</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-s1\">err</span><span class=\"pl-kos\">.</span><span class=\"pl-c1\">retriable</span> <span class=\"pl-c1\">=</span> <span class=\"pl-c1\">true</span><span class=\"pl-kos\">;</span></pre></div>\n<h2 dir=\"auto\">Option 3: Using <code class=\"notranslate\">cause</code></h2>\n<div class=\"highlight highlight-source-js notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"const err = new Error('an error occured', { cause: { retriable: true } })\"><pre class=\"notranslate\"><span class=\"pl-k\">const</span> <span class=\"pl-s1\">err</span> <span class=\"pl-c1\">=</span> <span class=\"pl-k\">new</span> <span class=\"pl-v\">Error</span><span class=\"pl-kos\">(</span><span class=\"pl-s\">'an error occured'</span><span class=\"pl-kos\">,</span> <span class=\"pl-kos\">{</span> <span class=\"pl-c1\">cause</span>: <span class=\"pl-kos\">{</span> <span class=\"pl-c1\">retriable</span>: <span class=\"pl-c1\">true</span> <span class=\"pl-kos\">}</span> <span class=\"pl-kos\">}</span><span class=\"pl-kos\">)</span></pre></div>\n<h2 dir=\"auto\">Option 4: Using <code class=\"notranslate\">AggregateError</code></h2>\n<div class=\"highlight highlight-source-js notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"// The first object is always an error but the additional things communicate\n// the additional structured information we want.\nconst err = new AggregateError([\n  new Error('an error occurred'),\n  { retriable: true }\n])\"><pre class=\"notranslate\"><span class=\"pl-c\">// The first object is always an error but the additional things communicate</span>\n<span class=\"pl-c\">// the additional structured information we want.</span>\n<span class=\"pl-k\">const</span> <span class=\"pl-s1\">err</span> <span class=\"pl-c1\">=</span> <span class=\"pl-k\">new</span> <span class=\"pl-v\">AggregateError</span><span class=\"pl-kos\">(</span><span class=\"pl-kos\">[</span>\n  <span class=\"pl-k\">new</span> <span class=\"pl-v\">Error</span><span class=\"pl-kos\">(</span><span class=\"pl-s\">'an error occurred'</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">,</span>\n  <span class=\"pl-kos\">{</span> <span class=\"pl-c1\">retriable</span>: <span class=\"pl-c1\">true</span> <span class=\"pl-kos\">}</span>\n<span class=\"pl-kos\">]</span><span class=\"pl-kos\">)</span></pre></div>\n<h2 dir=\"auto\">Option 5: ??</h2>\n<p dir=\"auto\">Other ideas?</p>\n<h2 dir=\"auto\">Current Thinking</h2>\n<p dir=\"auto\">My current thinking here is to prefer Option 3, using the <code class=\"notranslate\">cause</code> property.</p>\n<p dir=\"auto\">Specifically, pulling out to a logical level: The purpose of the <code class=\"notranslate\">cause</code> is to communicate the reason for this error. That reason might be that another <code class=\"notranslate\">Error</code> was thrown, or it might be that some other condition occurred. For instance, the network was down, or there was an internal error, etc. So let's differentiate between <code class=\"notranslate\">Error</code> and <code class=\"notranslate\">Condition</code>.</p>\n<p dir=\"auto\">If I have a transient condition and want to communicate that the user should retry their operation, then I could logically do something like:</p>\n<div class=\"highlight highlight-source-js notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"cont condition = {\n  // The condition is temporary....\n  transient: true,\n  // The operation is retriable...\n  retriable: true,\n};\nconst err = new Error('oops that failed', { cause: condition });\"><pre class=\"notranslate\"><span class=\"pl-s1\">cont</span> <span class=\"pl-s1\">condition</span> <span class=\"pl-c1\">=</span> <span class=\"pl-kos\">{</span>\n  <span class=\"pl-c\">// The condition is temporary....</span>\n  <span class=\"pl-c1\">transient</span>: <span class=\"pl-c1\">true</span><span class=\"pl-kos\">,</span>\n  <span class=\"pl-c\">// The operation is retriable...</span>\n  <span class=\"pl-c1\">retriable</span>: <span class=\"pl-c1\">true</span><span class=\"pl-kos\">,</span>\n<span class=\"pl-kos\">}</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-k\">const</span> <span class=\"pl-s1\">err</span> <span class=\"pl-c1\">=</span> <span class=\"pl-k\">new</span> <span class=\"pl-v\">Error</span><span class=\"pl-kos\">(</span><span class=\"pl-s\">'oops that failed'</span><span class=\"pl-kos\">,</span> <span class=\"pl-kos\">{</span> <span class=\"pl-c1\">cause</span>: <span class=\"pl-s1\">condition</span> <span class=\"pl-kos\">}</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">;</span></pre></div>\n<p dir=\"auto\">The challenge with this, of course, is interoperability. If workers chooses to use <code class=\"notranslate\">cause</code> in this way but other <code class=\"notranslate\">fetch()</code> implementations choose to use <code class=\"notranslate\">cause</code> in other ways then we can run into interop issues. To be clear, <em>ALL</em> of the options suffer from this exact problem.</p>\n<h2 dir=\"auto\">Proposal</h2>\n<p dir=\"auto\">The proposal I would like to make is to define a new <code class=\"notranslate\">ErrorCondition</code> interface specifically for use with <code class=\"notranslate\">cause</code></p>\n<p dir=\"auto\">Essentially (treat this as a discussion example to express intent... the <em>actual</em> proposal can be refined):</p>\n<div class=\"snippet-clipboard-content notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"dictionary ErrorConditionInit {\n  boolean transient = false;\n  boolean retriable = false;\n  DOMString name = &quot;&quot;;\n};\n\ninterface ErrorCondition {\n  constructor(optional DOMString message = &quot;&quot;, optional ConditionInit init = {});\n  readonly attribute boolean transient;\n  readonly attribute boolean retriable;\n  readonly attribute DOMString name;\n  readonly attribute DOMString message;\n}\"><pre class=\"notranslate\"><code class=\"notranslate\">dictionary ErrorConditionInit {\n  boolean transient = false;\n  boolean retriable = false;\n  DOMString name = \"\";\n};\n\ninterface ErrorCondition {\n  constructor(optional DOMString message = \"\", optional ConditionInit init = {});\n  readonly attribute boolean transient;\n  readonly attribute boolean retriable;\n  readonly attribute DOMString name;\n  readonly attribute DOMString message;\n}\n</code></pre></div>\n<p dir=\"auto\">Note that this interface <em>intentionally</em> mimics <code class=\"notranslate\">DOMException</code> with the inclusion of a <code class=\"notranslate\">name</code> and <code class=\"notranslate\">message</code> accessors.</p>\n<p dir=\"auto\">Example use (assuming the proposal to add <code class=\"notranslate\">cause</code> to <code class=\"notranslate\">DOMException</code> goes through):</p>\n<div class=\"snippet-clipboard-content notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"const err = new DOMException('The operation failed', {\n  name: 'NETWORK_ERR',\n  cause: new ErrorCondition('The network path is down', {\n    transient: true,\n    retriable: true,\n  })\n});\n\nconsole.log(err.cause.transient);  // true\nconsole.log(err.cause.retriable); // true\"><pre class=\"notranslate\"><code class=\"notranslate\">const err = new DOMException('The operation failed', {\n  name: 'NETWORK_ERR',\n  cause: new ErrorCondition('The network path is down', {\n    transient: true,\n    retriable: true,\n  })\n});\n\nconsole.log(err.cause.transient);  // true\nconsole.log(err.cause.retriable); // true\n</code></pre></div>\n<p dir=\"auto\">To be clear, I don't really have strong opinions on exactly how we solve this use case. My only requirement is that we have a mechanism for reliably communicating transient/retriable conditions that is interoperable across runtimes.</p>\n<h2 dir=\"auto\">Some questions</h2>\n<ol dir=\"auto\">\n<li>How are retriable errors like this handled elsewhere on the web?</li>\n</ol>",
            "url": "https://github.com/wintercg/fetch/issues/11",
            "title": "Error conditions, retry, and Error.cause",
            "date_modified": "2023-01-19T17:40:59.000Z",
            "date_published": "2022-09-08T18:15:41.000Z",
            "author": {
                "name": "jasnell",
                "url": "https://github.com/jasnell"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/1150298?v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><p dir=\"auto\">Already exists in at least Cloudflare Workers, Deno and Node.js...</p>",
            "url": "https://github.com/wintercg/proposal-common-minimum-api/issues/27",
            "title": "Expected `fetch` to be in the common minimum API",
            "date_modified": "2022-10-01T23:37:39.000Z",
            "date_published": "2022-09-08T14:52:54.000Z",
            "author": {
                "name": "timfish",
                "url": "https://github.com/timfish"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/8500303?u=50e30202b089c2c9bd355d8f86eae6ebcda67ffd&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><p dir=\"auto\"><a href=\"https://w3c.github.io/resource-timing/\" rel=\"nofollow\">Resource Timing</a> defines the interface <code class=\"notranslate\">PerformanceResourceTiming</code>, which represents an timing measurement entry of <a href=\"https://fetch.spec.whatwg.org/#concept-fetch\" rel=\"nofollow\">fetched</a> <a href=\"https://fetch.spec.whatwg.org/#http-scheme\" rel=\"nofollow\">http(s)</a> resources.</p>\n<p dir=\"auto\">Implementation Status:</p>\n<table role=\"table\">\n<thead>\n<tr>\n<th>Interface</th>\n<th>Node</th>\n<th>Deno</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code class=\"notranslate\">PerformanceResourceTiming</code></td>\n<td><a href=\"https://nodejs.org/dist/latest-v18.x/docs/api/perf_hooks.html#class-performanceresourcetiming\" rel=\"nofollow\"><g-emoji class=\"g-emoji\" alias=\"white_check_mark\" fallback-src=\"https://github.githubassets.com/images/icons/emoji/unicode/2705.png\">‚úÖ</g-emoji></a></td>\n<td><g-emoji class=\"g-emoji\" alias=\"question\" fallback-src=\"https://github.githubassets.com/images/icons/emoji/unicode/2753.png\">‚ùì</g-emoji></td>\n</tr>\n<tr>\n<td><code class=\"notranslate\">Performance.clearResourceTiming</code></td>\n<td><g-emoji class=\"g-emoji\" alias=\"white_check_mark\" fallback-src=\"https://github.githubassets.com/images/icons/emoji/unicode/2705.png\">‚úÖ</g-emoji></td>\n<td><g-emoji class=\"g-emoji\" alias=\"question\" fallback-src=\"https://github.githubassets.com/images/icons/emoji/unicode/2753.png\">‚ùì</g-emoji></td>\n</tr>\n<tr>\n<td><code class=\"notranslate\">Performance.setResourceTimingBufferSize</code></td>\n<td><g-emoji class=\"g-emoji\" alias=\"white_check_mark\" fallback-src=\"https://github.githubassets.com/images/icons/emoji/unicode/2705.png\">‚úÖ</g-emoji></td>\n<td><g-emoji class=\"g-emoji\" alias=\"question\" fallback-src=\"https://github.githubassets.com/images/icons/emoji/unicode/2753.png\">‚ùì</g-emoji></td>\n</tr>\n</tbody>\n</table>",
            "url": "https://github.com/wintercg/performance/issues/5",
            "title": "Resource Timing",
            "date_modified": "2022-08-30T08:16:21.000Z",
            "date_published": "2022-08-25T16:29:59.000Z",
            "author": {
                "name": "legendecas",
                "url": "https://github.com/legendecas"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/8500303?u=50e30202b089c2c9bd355d8f86eae6ebcda67ffd&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><ul dir=\"auto\">\n<li>Fix auto-links to WebPerf documents.</li>\n<li>Fix auto-links to the terms defined in <a href=\"https://common-min-api.proposal.wintercg.org/\" rel=\"nofollow\">https://common-min-api.proposal.wintercg.org/</a>.</li>\n</ul>",
            "url": "https://github.com/wintercg/performance/issues/4",
            "title": "Editorial: autolinks to terms defined in other specs",
            "date_modified": "2022-08-11T17:29:55.000Z",
            "date_published": "2022-08-11T17:29:55.000Z",
            "author": {
                "name": "legendecas",
                "url": "https://github.com/legendecas"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/3468483?u=daf25d236ad2cc227470fa0da2d5bdf3dbb7feed&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><p dir=\"auto\">It's hard to use the wasm version of Canvas implementation on edge; because the size of the current implementation for canvas in npm is huge and slow.</p>\n<p dir=\"auto\">It would be nice if the runtime provide the native <code class=\"notranslate\">OffscreenCanvas</code> API.</p>",
            "url": "https://github.com/wintercg/proposal-common-minimum-api/issues/26",
            "title": "OffscreenCanvas",
            "date_modified": "2023-01-10T01:24:40.000Z",
            "date_published": "2022-08-04T13:47:00.000Z",
            "author": {
                "name": "Brooooooklyn",
                "url": "https://github.com/Brooooooklyn"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/8225977?u=ebf8bbc30918fe9c36833005bebc027a65984f34&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><p dir=\"auto\">The fetch spec includes APIs for interacting with form submissions. For example, there is the <code class=\"notranslate\">Request</code> and <code class=\"notranslate\">Response</code> constructors accepting <a href=\"https://url.spec.whatwg.org/#interface-urlsearchparams\" rel=\"nofollow\"><code class=\"notranslate\">URLSearchParams</code></a> and <a href=\"https://xhr.spec.whatwg.org/#interface-formdata\" rel=\"nofollow\"><code class=\"notranslate\">FormData</code></a> objects as the request/response body, which is generally useful and is expected to be part of the common minimum API.</p>\n<p dir=\"auto\">However, the fetch spec also defines the <a href=\"https://fetch.spec.whatwg.org/#dom-body-formdata\" rel=\"nofollow\"><code class=\"notranslate\">formData()</code></a> method of the <code class=\"notranslate\">Body</code> interface mixin, which is included in <code class=\"notranslate\">Request</code> and <code class=\"notranslate\">Response</code>. This method parses the HTTP body as a form submission enctype (either <code class=\"notranslate\">application/x-www-form-urlencoded</code> or <code class=\"notranslate\">multipart/form-data</code>) and returns a <code class=\"notranslate\">FormData</code> object. Since form submission bodies only generally make sense as requests, and it's rarely useful to parse a request body from an HTTP client, it wouldn't make much sense to include this method as part of the common minimum API ‚Äì but it is certainly useful for fetch-based HTTP server APIs, as Deno and CFW have.</p>\n<p dir=\"auto\">For <code class=\"notranslate\">multipart/form-data</code> parsing, however, this method leaves things almost completely unspecified. While there is a formal definition of this format (in <a href=\"https://www.rfc-editor.org/rfc/rfc7578\" rel=\"nofollow\">RFC7578</a>, which relies on <a href=\"https://www.rfc-editor.org/rfc/rfc2046#section-5.1\" rel=\"nofollow\">the <code class=\"notranslate\">multipart</code> definitions in RFC2046</a>), it is in the form of an ABNF grammar rather than a parsing algorithms, and so different implementations differ in how they parse some input.</p>\n<p dir=\"auto\">What's more, browsers have not always escaped field names and filenames in <code class=\"notranslate\">multipart/form-data</code> payloads in the same way. For example, until last year Firefox escaped double quotes by prepending a backslash, and newlines by turning them into spaces; while Chromium and Webkit used percent-encoding. And while this percent-encoding behavior was added to the HTML spec (<a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load title\" data-id=\"784103377\" data-permission-text=\"Title is private\" data-url=\"https://github.com/whatwg/html/issues/6282\" data-hovercard-type=\"pull_request\" data-hovercard-url=\"/whatwg/html/pull/6282/hovercard\" href=\"https://github.com/whatwg/html/pull/6282\">whatwg/html#6282</a>), and FIrefox's behavior fixed in turn, no implementation of the parsing that I'm aware of (including Chromium and Webkit!) decode the percent-encoding escapes:</p>\n<div class=\"highlight highlight-source-js notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"const original = new FormData();\noriginal.set('a&quot;b', &quot;&quot;);\noriginal.set('c&quot;d', new File([], 'e&quot;f'));\nlog(original);  // a&quot;b c&quot;d e&quot;f\n\nconst parsed = await new Response(original).formData();\nlog(parsed);  // a%22b c%22d e%22f\n// (In CFW it's a%22b c%22d undefined, because it seems like files are not\n// distinguished from non-file values when parsing.)\n\nfunction log(formdata) {\n  // FormData is pair-iterable.\n  const entries = [...formdata];\n  const firstEntryName = entries[0][0];\n  const secondEntryName = entries[1][0];\n  const secondEntryFilename = entries[1][1].name;\n  console.log(firstEntryName, secondEntryName, secondEntryFilename);\n}\"><pre class=\"notranslate\"><span class=\"pl-k\">const</span> <span class=\"pl-s1\">original</span> <span class=\"pl-c1\">=</span> <span class=\"pl-k\">new</span> <span class=\"pl-v\">FormData</span><span class=\"pl-kos\">(</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-s1\">original</span><span class=\"pl-kos\">.</span><span class=\"pl-en\">set</span><span class=\"pl-kos\">(</span><span class=\"pl-s\">'a\"b'</span><span class=\"pl-kos\">,</span> <span class=\"pl-s\">\"\"</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-s1\">original</span><span class=\"pl-kos\">.</span><span class=\"pl-en\">set</span><span class=\"pl-kos\">(</span><span class=\"pl-s\">'c\"d'</span><span class=\"pl-kos\">,</span> <span class=\"pl-k\">new</span> <span class=\"pl-v\">File</span><span class=\"pl-kos\">(</span><span class=\"pl-kos\">[</span><span class=\"pl-kos\">]</span><span class=\"pl-kos\">,</span> <span class=\"pl-s\">'e\"f'</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-en\">log</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">original</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">;</span>  <span class=\"pl-c\">// a\"b c\"d e\"f</span>\n\n<span class=\"pl-k\">const</span> <span class=\"pl-s1\">parsed</span> <span class=\"pl-c1\">=</span> <span class=\"pl-k\">await</span> <span class=\"pl-k\">new</span> <span class=\"pl-v\">Response</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">original</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">.</span><span class=\"pl-en\">formData</span><span class=\"pl-kos\">(</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-en\">log</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">parsed</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">;</span>  <span class=\"pl-c\">// a%22b c%22d e%22f</span>\n<span class=\"pl-c\">// (In CFW it's a%22b c%22d undefined, because it seems like files are not</span>\n<span class=\"pl-c\">// distinguished from non-file values when parsing.)</span>\n\n<span class=\"pl-k\">function</span> <span class=\"pl-en\">log</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">formdata</span><span class=\"pl-kos\">)</span> <span class=\"pl-kos\">{</span>\n  <span class=\"pl-c\">// FormData is pair-iterable.</span>\n  <span class=\"pl-k\">const</span> <span class=\"pl-s1\">entries</span> <span class=\"pl-c1\">=</span> <span class=\"pl-kos\">[</span>...<span class=\"pl-s1\">formdata</span><span class=\"pl-kos\">]</span><span class=\"pl-kos\">;</span>\n  <span class=\"pl-k\">const</span> <span class=\"pl-s1\">firstEntryName</span> <span class=\"pl-c1\">=</span> <span class=\"pl-s1\">entries</span><span class=\"pl-kos\">[</span><span class=\"pl-c1\">0</span><span class=\"pl-kos\">]</span><span class=\"pl-kos\">[</span><span class=\"pl-c1\">0</span><span class=\"pl-kos\">]</span><span class=\"pl-kos\">;</span>\n  <span class=\"pl-k\">const</span> <span class=\"pl-s1\">secondEntryName</span> <span class=\"pl-c1\">=</span> <span class=\"pl-s1\">entries</span><span class=\"pl-kos\">[</span><span class=\"pl-c1\">1</span><span class=\"pl-kos\">]</span><span class=\"pl-kos\">[</span><span class=\"pl-c1\">0</span><span class=\"pl-kos\">]</span><span class=\"pl-kos\">;</span>\n  <span class=\"pl-k\">const</span> <span class=\"pl-s1\">secondEntryFilename</span> <span class=\"pl-c1\">=</span> <span class=\"pl-s1\">entries</span><span class=\"pl-kos\">[</span><span class=\"pl-c1\">1</span><span class=\"pl-kos\">]</span><span class=\"pl-kos\">[</span><span class=\"pl-c1\">1</span><span class=\"pl-kos\">]</span><span class=\"pl-kos\">.</span><span class=\"pl-c1\">name</span><span class=\"pl-kos\">;</span>\n  <span class=\"pl-smi\">console</span><span class=\"pl-kos\">.</span><span class=\"pl-en\">log</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">firstEntryName</span><span class=\"pl-kos\">,</span> <span class=\"pl-s1\">secondEntryName</span><span class=\"pl-kos\">,</span> <span class=\"pl-s1\">secondEntryFilename</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\">For browsers, specifying <code class=\"notranslate\">multipart/form-data</code> parsing is not a big priority, since there are not many use cases for them, and the <code class=\"notranslate\">formData()</code> method has been broken for 8 years or so. But for WinterCG runtimes with a fetch-based HTTP server API, being able to parse form submissions with the existing fetch API is crucial, and being able to accurately parse the form submissions that all browser engines are currently submitting is a large part of that. So this seems like a very interesting issue to tackle as part of the WinterCG project.</p>",
            "url": "https://github.com/wintercg/fetch/issues/10",
            "title": "Work on standardizing multipart/form-data parsing (for `Request.prototype.formData`)",
            "date_modified": "2023-01-19T17:40:42.000Z",
            "date_published": "2022-07-30T20:14:29.000Z",
            "author": {
                "name": "andreubotella",
                "url": "https://github.com/andreubotella"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/439929?u=88483145a53c3d594ab68146c1a8bdecc3bcd1d3&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><p dir=\"auto\">One of the active discussions at the whatwg/dom repo is creation of an AbortSignal that can follow other AbortSignals... see <a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load title\" data-id=\"740045062\" data-permission-text=\"Title is private\" data-url=\"https://github.com/whatwg/dom/issues/920\" data-hovercard-type=\"issue\" data-hovercard-url=\"/whatwg/dom/issues/920/hovercard\" href=\"https://github.com/whatwg/dom/issues/920\">whatwg/dom#920</a></p>\n<p dir=\"auto\">There is a proposal on the table for <code class=\"notranslate\">AbortSignal.any()</code> here: <a href=\"https://github.com/shaseley/abort-signal-any/blob/main/README.md\">https://github.com/shaseley/abort-signal-any/blob/main/README.md</a></p>\n<p dir=\"auto\">The key question for this group is whether the proposal looks good and whether wintercg has any feedback for the discussion.</p>",
            "url": "https://github.com/wintercg/proposal-common-minimum-api/issues/25",
            "title": "Use cases for AbortSignal.any()",
            "date_modified": "2022-07-30T15:35:16.000Z",
            "date_published": "2022-07-30T15:01:42.000Z",
            "author": {
                "name": "jasnell",
                "url": "https://github.com/jasnell"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/241506?u=5c10f2bbf617c297b2ceb8d0e827906007a7d5a7&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><p dir=\"auto\">I'd like to propose that <code class=\"notranslate\">Ed25519</code> EdDSA (proposed in <a href=\"https://wicg.github.io/webcrypto-secure-curves\" rel=\"nofollow\">Secure Curves in the Web Cryptography API</a>) be part of the Minimum Common Web Platform API proposal.</p>\n<p dir=\"auto\">Depending on feasibility possibly also <code class=\"notranslate\">X25519</code> key agreement.</p>",
            "url": "https://github.com/wintercg/proposal-common-minimum-api/issues/24",
            "title": "Include a subset of Web Crypto API Secure Curves",
            "date_modified": "2022-07-30T15:36:16.000Z",
            "date_published": "2022-07-14T16:34:37.000Z",
            "author": {
                "name": "panva",
                "url": "https://github.com/panva"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/2842176?v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><p dir=\"auto\">E.g. <code class=\"notranslate\">fetch('/foo')</code>, what should the whole URL should be?</p>",
            "url": "https://github.com/wintercg/fetch/issues/9",
            "title": "URL with relative uri",
            "date_modified": "2023-01-19T17:40:37.000Z",
            "date_published": "2022-06-30T17:13:19.000Z",
            "author": {
                "name": "XadillaX",
                "url": "https://github.com/XadillaX"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/1566869?u=2503348c06c35836486e92d9bcb983557dc4e955&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><h2 dir=\"auto\">Motivation</h2>\n<p dir=\"auto\">Platforms are not consistent in how they provide access to environment variables. We'd like to define a consistent API for environment variable access.</p>\n<h2 dir=\"auto\">Environment variables on existing platforms</h2>\n<h3 dir=\"auto\">Cloudflare</h3>\n<p dir=\"auto\">Environment variables are injected into a scoped variable. For example, an <code class=\"notranslate\">API_TOKEN</code> environment variable would be available within the <code class=\"notranslate\">env</code> param:</p>\n<div class=\"highlight highlight-source-ts notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"export default {\n  fetch(request, env, context) {\n    // env.API_TOKEN\n  },\n};\"><pre class=\"notranslate\"><span class=\"pl-k\">export</span> <span class=\"pl-k\">default</span> <span class=\"pl-kos\">{</span>\n  <span class=\"pl-en\">fetch</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">request</span><span class=\"pl-kos\">,</span> <span class=\"pl-s1\">env</span><span class=\"pl-kos\">,</span> <span class=\"pl-s1\">context</span><span class=\"pl-kos\">)</span> <span class=\"pl-kos\">{</span>\n    <span class=\"pl-c\">// env.API_TOKEN</span>\n  <span class=\"pl-kos\">}</span><span class=\"pl-kos\">,</span>\n<span class=\"pl-kos\">}</span><span class=\"pl-kos\">;</span></pre></div>\n<p dir=\"auto\">Reference: <a href=\"https://developers.cloudflare.com/workers/runtime-apis/fetch-event/#syntax-module-worker\" rel=\"nofollow\">https://developers.cloudflare.com/workers/runtime-apis/fetch-event/#syntax-module-worker</a></p>\n<h3 dir=\"auto\">Vercel</h3>\n<p dir=\"auto\">Environment variables are defined on <code class=\"notranslate\">process.env</code> object. For example, an <code class=\"notranslate\">API_TOKEN</code> environment variable would be available by <code class=\"notranslate\">process.env.API_TOKEN</code>.</p>\n<p dir=\"auto\">Reference: <a href=\"https://vercel.com/docs/concepts/functions/serverless-functions#environment-variables\" rel=\"nofollow\">https://vercel.com/docs/concepts/functions/serverless-functions#environment-variables</a></p>\n<h3 dir=\"auto\">Deno</h3>\n<p dir=\"auto\">Environment variables are retrieved through a global <code class=\"notranslate\">Deno.env</code> object. For example, an <code class=\"notranslate\">API_TOKEN</code> environment variable would be available by <code class=\"notranslate\">Deno.env.get('API_TOKEN')</code></p>\n<p dir=\"auto\">Reference: <a href=\"https://doc.deno.land/deno/stable/~/Deno.env\" rel=\"nofollow\">https://doc.deno.land/deno/stable/~/Deno.env</a></p>\n<h3 dir=\"auto\">NodeJS</h3>\n<p dir=\"auto\">Environment variables are defined on a global <code class=\"notranslate\">process.env</code> object. For example, an <code class=\"notranslate\">API_TOKEN</code> environment variable would be available by <code class=\"notranslate\">process.env.API_TOKEN</code>.</p>\n<p dir=\"auto\">Reference: <a href=\"https://nodejs.org/docs/latest/api/process.html#processenv\" rel=\"nofollow\">https://nodejs.org/docs/latest/api/process.html#processenv</a></p>\n<h3 dir=\"auto\">Shopify Oxygen</h3>\n<p dir=\"auto\">Environment variables are defined on a global <code class=\"notranslate\">Oxygen.env</code> object. For example, an <code class=\"notranslate\">API_TOKEN</code> environment variable would be available by <code class=\"notranslate\">Oxygen.env.API_TOKEN</code>.</p>\n<p dir=\"auto\">Reference: <a href=\"https://shopify.dev/custom-storefronts/oxygen/environment-variables\" rel=\"nofollow\">https://shopify.dev/custom-storefronts/oxygen/environment-variables</a></p>\n<h2 dir=\"auto\">Options</h2>\n<h3 dir=\"auto\">Unify on one of the existing platform implementations</h3>\n<p dir=\"auto\">Which one?</p>\n<h3 dir=\"auto\"><code class=\"notranslate\">import.meta</code></h3>\n<p dir=\"auto\">The <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/import.meta\" rel=\"nofollow\"><code class=\"notranslate\">import.meta</code> object</a> exposes context-specific metadata to a JavaScript module. We could utilize that container for environment variables, <code class=\"notranslate\">import.meta.env.API_TOKEN</code>.</p>\n<p dir=\"auto\">There is precedent to <code class=\"notranslate\">import.meta.env</code> with <a href=\"https://vitejs.dev/guide/env-and-mode.html#env-variables\" rel=\"nofollow\">Vite's implementation</a>. The downside to this is that <code class=\"notranslate\">import.meta</code> is only available in ES Modules.</p>",
            "url": "https://github.com/wintercg/environment-metadata/issues/1",
            "title": "Environment variables",
            "date_modified": "2023-03-20T12:12:29.000Z",
            "date_published": "2022-06-29T21:16:43.000Z",
            "author": {
                "name": "blittle",
                "url": "https://github.com/blittle"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/11720408?u=81d18186faaee6e6a77cb714e55240f238480871&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><p dir=\"auto\">Platforms like <a href=\"https://developers.cloudflare.com/workers/runtime-apis/request/\" rel=\"nofollow\">Cloudflare Workers</a> or <a href=\"https://shopify.dev/custom-storefronts/oxygen/worker-runtime-apis#custom-headers\" rel=\"nofollow\">Shopify Oxygen</a> may need to add additional information to requests/responses. Cloudflare Workers has a proprietary <a href=\"https://developers.cloudflare.com/workers/runtime-apis/request/#incomingrequestcfproperties\" rel=\"nofollow\"><code class=\"notranslate\">.cf</code> property</a> which includes fields like geolocation data etc. Shopify's Oxygen runtime has similar needs but uses custom HTTP headers to pass the data.</p>\n<p dir=\"auto\">Since the standard doesn't offer any way to pass extra meta information along with <code class=\"notranslate\">Request</code>/<code class=\"notranslate\">Response</code> instances, it would be great to explore these and similar scenarios to see how the extra meta data may be added. There likely were no use cases for this in the browser world, but on the server side, the situation is different.</p>\n<p dir=\"auto\">Using extra HTTP custom headers might be the most obvious approach, but it has a clear downside that headers have tight size limits, aren't very suitable for holding complex data, and can't contain anything that isn't directly serialisable into a string.</p>\n<p dir=\"auto\">A custom property like <code class=\"notranslate\">.meta</code> or <code class=\"notranslate\">.metadata</code> (which should hold a JavaScript object, leaving its fields up to the vendor implementation) would be more flexible but needs to be standardised.</p>",
            "url": "https://github.com/wintercg/fetch/issues/8",
            "title": "Passing platform-specific meta information with the `Request`/`Response` instances",
            "date_modified": "2023-01-19T17:40:26.000Z",
            "date_published": "2022-06-28T15:46:25.000Z",
            "author": {
                "name": "maxshirshin",
                "url": "https://github.com/maxshirshin"
            }
        }
    ]
}