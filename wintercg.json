{
    "version": "https://jsonfeed.org/version/1",
    "title": "org:wintercg Issues",
    "home_page_url": "https://azu.github.io/github-search-rss/wintercg.json",
    "feed_url": "https://azu.github.io/github-search-rss/wintercg.json",
    "description": "org:wintercg Issues on GitHub",
    "items": [
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/1935696?u=d4da91ea9b820da475036cd6fec79943b2c06775&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><p dir=\"auto\">Since Node.js, Bun and Deno offer different APIs (<a href=\"https://nodejs.org/api/test.html#test-runner\" rel=\"nofollow\"><code class=\"notranslate\">node:test</code></a>, <a href=\"https://bun.sh/docs/test/writing\" rel=\"nofollow\"><code class=\"notranslate\">bun:test</code></a>, <a href=\"https://examples.deno.land/writing-tests\" rel=\"nofollow\"><code class=\"notranslate\">Deno.test</code></a>) but have many similarities, would it make sense to have a set of specced cross-platform testing APIs?</p>\n<h2 dir=\"auto\">Motivating Example</h2>\n<p dir=\"auto\"><code class=\"notranslate\">runtime:</code> prefix, in the style of Node.js or Bun:</p>\n<div class=\"highlight highlight-source-ts notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"import { test } from 'runtime:test';\n\ntest('2 + 2', () =&gt; {\n  expect(2 + 2).toBe(4);\n});\"><pre class=\"notranslate\"><span class=\"pl-k\">import</span> <span class=\"pl-kos\">{</span> <span class=\"pl-s1\">test</span> <span class=\"pl-kos\">}</span> <span class=\"pl-k\">from</span> <span class=\"pl-s\">'runtime:test'</span><span class=\"pl-kos\">;</span>\n\n<span class=\"pl-en\">test</span><span class=\"pl-kos\">(</span><span class=\"pl-s\">'2 + 2'</span><span class=\"pl-kos\">,</span> <span class=\"pl-kos\">(</span><span class=\"pl-kos\">)</span> <span class=\"pl-c1\">=&gt;</span> <span class=\"pl-kos\">{</span>\n  <span class=\"pl-en\">expect</span><span class=\"pl-kos\">(</span><span class=\"pl-c1\">2</span> <span class=\"pl-c1\">+</span> <span class=\"pl-c1\">2</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">.</span><span class=\"pl-en\">toBe</span><span class=\"pl-kos\">(</span><span class=\"pl-c1\">4</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-kos\">}</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">;</span></pre></div>\n<p dir=\"auto\">Or, Deno-style global:</p>\n<div class=\"highlight highlight-source-ts notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"Runtime.test(&quot;assert works correctly&quot;, () =&gt; {\n  assert(true);\n  assertEquals(1, 1);\n});\n\n// Using existing global:\nglobalThis.test(&quot;assert works correctly&quot;, () =&gt; {\n  assert(true);\n  assertEquals(1, 1);\n});\"><pre class=\"notranslate\"><span class=\"pl-smi\">Runtime</span><span class=\"pl-kos\">.</span><span class=\"pl-en\">test</span><span class=\"pl-kos\">(</span><span class=\"pl-s\">\"assert works correctly\"</span><span class=\"pl-kos\">,</span> <span class=\"pl-kos\">(</span><span class=\"pl-kos\">)</span> <span class=\"pl-c1\">=&gt;</span> <span class=\"pl-kos\">{</span>\n  <span class=\"pl-en\">assert</span><span class=\"pl-kos\">(</span><span class=\"pl-c1\">true</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">;</span>\n  <span class=\"pl-en\">assertEquals</span><span class=\"pl-kos\">(</span><span class=\"pl-c1\">1</span><span class=\"pl-kos\">,</span> <span class=\"pl-c1\">1</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-kos\">}</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">;</span>\n\n<span class=\"pl-c\">// Using existing global:</span>\n<span class=\"pl-s1\">globalThis</span><span class=\"pl-kos\">.</span><span class=\"pl-en\">test</span><span class=\"pl-kos\">(</span><span class=\"pl-s\">\"assert works correctly\"</span><span class=\"pl-kos\">,</span> <span class=\"pl-kos\">(</span><span class=\"pl-kos\">)</span> <span class=\"pl-c1\">=&gt;</span> <span class=\"pl-kos\">{</span>\n  <span class=\"pl-en\">assert</span><span class=\"pl-kos\">(</span><span class=\"pl-c1\">true</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">;</span>\n  <span class=\"pl-en\">assertEquals</span><span class=\"pl-kos\">(</span><span class=\"pl-c1\">1</span><span class=\"pl-kos\">,</span> <span class=\"pl-c1\">1</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-kos\">}</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">;</span></pre></div>\n<p dir=\"auto\">This was originally inspired by <a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/nzakas/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/nzakas\">@nzakas</a>'s tweet here:</p>\n<blockquote>\n<p dir=\"auto\">What I want: To write JavaScript tests once and be able to run them across Node.js, Bun, and Deno.</p>\n<p dir=\"auto\">Problem: Bun and Deno have built-in test runners you have to import from to run tests. I use Mocha. This doesn't work.</p>\n<p dir=\"auto\">Solution: ???</p>\n</blockquote>\n<p dir=\"auto\">Source: <a href=\"https://twitter.com/slicknet/status/1762264774166085937\" rel=\"nofollow\">https://twitter.com/slicknet/status/1762264774166085937</a></p>\n<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/CanadaHonk/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/CanadaHonk\">@CanadaHonk</a> rightly mentions that, while there are similarities, there are probably challenges creating a spec:</p>\n<blockquote>\n<p dir=\"auto\">most test framework APIs are pretty similar?</p>\n<p dir=\"auto\">probably hard to spec due to sandbox/isolation/etc</p>\n</blockquote>\n<p dir=\"auto\">Source: <a href=\"https://twitter.com/CanadaHonk/status/1762417370893516929\" rel=\"nofollow\">https://twitter.com/CanadaHonk/status/1762417370893516929</a></p>\n<h2 dir=\"auto\">Alternatives Considered</h2>\n<h3 dir=\"auto\">Separate Package</h3>\n<p dir=\"auto\">Instead of something built into the standard library of multiple runtimes, use a separate package (either like Vitest, including testing features of its own, or a wrapper package).</p>\n<p dir=\"auto\">Downsides:</p>\n<ol dir=\"auto\">\n<li>Doesn't work out of the box or with zero dependencies</li>\n<li>Downloading and maintaining another package in <code class=\"notranslate\">devDependencies</code></li>\n</ol>",
            "url": "https://github.com/wintercg/proposal-common-minimum-api/issues/68",
            "title": "Cross-Runtime Testing APIs?",
            "date_modified": "2024-03-01T07:46:37.000Z",
            "date_published": "2024-02-27T10:10:33.000Z",
            "author": {
                "name": "karlhorky",
                "url": "https://github.com/karlhorky"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/42794878?u=c2da6d9d9cc86ff6ae7bd4c089f2cdbb9ff01a84&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><p dir=\"auto\">Cloudflare workers, Deno, node, bun all have it in some capacity. But it's also extremely limited and there is little incentive from browsers to change it.</p>\n<p dir=\"auto\">Node supports passing a dictionary as the second argument, ie. for setting custom headers or undici dispatchers (which allows for proxying, etc.). If this could be standardized it'd be great.</p>\n<p dir=\"auto\"><a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load title\" data-id=\"1599378606\" data-permission-text=\"Title is private\" data-url=\"https://github.com/whatwg/websockets/issues/42\" data-hovercard-type=\"issue\" data-hovercard-url=\"/whatwg/websockets/issues/42/hovercard\" href=\"https://github.com/whatwg/websockets/issues/42\">whatwg/websockets#42</a><br>\n<a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load title\" data-id=\"1147048320\" data-permission-text=\"Title is private\" data-url=\"https://github.com/whatwg/websockets/issues/16\" data-hovercard-type=\"issue\" data-hovercard-url=\"/whatwg/websockets/issues/16/hovercard?comment_id=881547333&amp;comment_type=issue_comment\" href=\"https://github.com/whatwg/websockets/issues/16#issuecomment-881547333\">whatwg/websockets#16 (comment)</a></p>",
            "url": "https://github.com/wintercg/proposal-common-minimum-api/issues/66",
            "title": "WebSocket",
            "date_modified": "2024-02-09T09:48:37.000Z",
            "date_published": "2024-02-09T04:01:26.000Z",
            "author": {
                "name": "KhafraDev",
                "url": "https://github.com/KhafraDev"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/189835?u=2d60c25c3f0cbdad0e8c9239a7283e887a3e490c&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><p dir=\"auto\">Last time I checked, only Firefox actually fired the languagechange event. We should probably investigate whether it even deserves to be in the spec, before we ask people to implement it in servers. (Really, servers should not have a current language, but that is more difficult to do compatibly...)</p>",
            "url": "https://github.com/wintercg/navigator-registry/issues/2",
            "title": "Language change",
            "date_modified": "2024-01-08T13:59:28.000Z",
            "date_published": "2024-01-08T13:59:28.000Z",
            "author": {
                "name": "littledan",
                "url": "https://github.com/littledan"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/8225977?u=ebf8bbc30918fe9c36833005bebc027a65984f34&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><p dir=\"auto\">The <a href=\"https://xhr.spec.whatwg.org/#formdata\" rel=\"nofollow\"><code class=\"notranslate\">FormData</code></a> constructor, as defined in the XHR spec, takes two optional parameters: the first of type <code class=\"notranslate\">HTMLFormElement</code>, and the second of type <code class=\"notranslate\">HTMLElement</code>. These are DOM APIs, which server-side runtimes don't support.</p>\n<p dir=\"auto\">The way I see it, if any of these arguments is passed (and it's anything other than <code class=\"notranslate\">undefined</code>), this indicates a bug in user code. For example, the code in question could be isomorphic code using DOM APIs through a library such as <a href=\"https://github.com/jsdom/jsdom\">jsdom</a> or <a href=\"https://github.com/b-fuze/deno-dom\">deno-dom</a>, and the developer mistakenly used those objects with the runtime's <code class=\"notranslate\">FormData</code> implementation. TypeScript might not catch that, since it could be set up to use the browser's type definitions rather than the runtime's.</p>\n<p dir=\"auto\">In the runtimes I've tested:</p>\n<ul dir=\"auto\">\n<li>Node.js and Deno throw if the first argument is not <code class=\"notranslate\">undefined</code>, but they ignore the second argument.</li>\n<li>Cloudflare Workers / <code class=\"notranslate\">workerd</code>, Bun and WinterJS ignore both arguments.</li>\n</ul>\n<p dir=\"auto\">No runtimes seem to check the second argument. Specifying Node.js and Deno's behavior might be fine, since in browsers the second argument does nothing if the first one is <code class=\"notranslate\">undefined</code>, and the first argument is already checked. But the WebIDL implementation in browsers does check that the second argument is a valid <code class=\"notranslate\">HTMLElement</code> regardless of whether the first one is <code class=\"notranslate\">undefined</code>, so maybe we should be consistent with that. This would also let us specify this by just saying what happens with unsupported WebIDL types, which is something that might also apply to other APIs in the future.</p>",
            "url": "https://github.com/wintercg/proposal-common-minimum-api/issues/63",
            "title": "How does the `FormData` constructor handle arguments in non-DOM runtimes?",
            "date_modified": "2024-01-12T16:48:45.000Z",
            "date_published": "2024-01-08T07:00:26.000Z",
            "author": {
                "name": "andreubotella",
                "url": "https://github.com/andreubotella"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/14912729?u=2997309b4cece94a0202986b59a3f3de5636f55f&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><p dir=\"auto\">The <code class=\"notranslate\">fetch</code> API is becoming the standard HTTP client for server usage. When proxying back a fetched resource to the user-agent, here's what i'd intuitively do:</p>\n<div class=\"highlight highlight-source-ts notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"async function myEndpoint(request: Request): Promise&lt;Response&gt; {\n   return await fetch(&quot;https://www.gatsbyjs.com/Gatsby-Logo.svg&quot;);\n}\"><pre class=\"notranslate\"><span class=\"pl-k\">async</span> <span class=\"pl-k\">function</span> <span class=\"pl-en\">myEndpoint</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">request</span>: <span class=\"pl-smi\">Request</span><span class=\"pl-kos\">)</span>: <span class=\"pl-smi\">Promise</span><span class=\"pl-kos\">&lt;</span><span class=\"pl-smi\">Response</span><span class=\"pl-kos\">&gt;</span> <span class=\"pl-kos\">{</span>\n   <span class=\"pl-k\">return</span> <span class=\"pl-k\">await</span> <span class=\"pl-en\">fetch</span><span class=\"pl-kos\">(</span><span class=\"pl-s\">\"https://www.gatsbyjs.com/Gatsby-Logo.svg\"</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\">The URL in this example responds with a gzip-compressed SVG. As specced in 16.1.1.1 of <a href=\"https://fetch.spec.wintercg.org/#http-network-fetch\" rel=\"nofollow\"><code class=\"notranslate\">15.6 HTTP - network fetch</code></a>, the <code class=\"notranslate\">body</code> stream contains an uncompressed version of the SVG, making compression transparent to the user. This works well for consuming the SVG.</p>\n<p dir=\"auto\">However, the spec does not require headers to mirror this decompression. Although the <code class=\"notranslate\">Response</code> has uncompressed body, the <code class=\"notranslate\">Content-Length</code> headers shows it compressed length and the <code class=\"notranslate\">Content-Encoding</code> header pretends it's compressed. In <a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load title\" data-id=\"2033082818\" data-permission-text=\"Title is private\" data-url=\"https://github.com/nodejs/undici/issues/2514\" data-hovercard-type=\"issue\" data-hovercard-url=\"/nodejs/undici/issues/2514/hovercard\" href=\"https://github.com/nodejs/undici/issues/2514\">nodejs/undici#2514</a> (the issue I originally opened), I've included a repro of what this means if the <code class=\"notranslate\">Response</code> is proxied to the user-agent:</p>\n<ol dir=\"auto\">\n<li>The <code class=\"notranslate\">body</code> ends up being longer than the headers described. This is not allowed in the HTTP spec, and leads clients like cURL to warn.</li>\n<li>The user-agent will try decompress a body that isn't compressed</li>\n</ol>\n<p dir=\"auto\">The current workaround is to manually alter headers on responses from <code class=\"notranslate\">fetch</code>:</p>\n<div class=\"highlight highlight-source-ts notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"async function myEndpoint(request: Request): Promise&lt;Response&gt; {\n   let resp = await fetch(&quot;https://www.gatsbyjs.com/Gatsby-Logo.svg&quot;);\n   if (resp.headers.get(&quot;content-encoding&quot;) {\n     const headers = new Headers(resp.headers)\n     headers.delete(&quot;content-encoding&quot;)\n     headers.delete(&quot;content-length&quot;)\n     resp = new Response(body, { ...resp, headers })\n   }\n   return resp\n}\"><pre class=\"notranslate\"><span class=\"pl-k\">async</span> <span class=\"pl-k\">function</span> <span class=\"pl-en\">myEndpoint</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">request</span>: <span class=\"pl-smi\">Request</span><span class=\"pl-kos\">)</span>: <span class=\"pl-smi\">Promise</span><span class=\"pl-kos\">&lt;</span><span class=\"pl-smi\">Response</span><span class=\"pl-kos\">&gt;</span> <span class=\"pl-kos\">{</span>\n   <span class=\"pl-k\">let</span> <span class=\"pl-s1\">resp</span> <span class=\"pl-c1\">=</span> <span class=\"pl-k\">await</span> <span class=\"pl-en\">fetch</span><span class=\"pl-kos\">(</span><span class=\"pl-s\">\"https://www.gatsbyjs.com/Gatsby-Logo.svg\"</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">;</span>\n   <span class=\"pl-k\">if</span> <span class=\"pl-kos\">(</span><span class=\"pl-s1\">resp</span><span class=\"pl-kos\">.</span><span class=\"pl-c1\">headers</span><span class=\"pl-kos\">.</span><span class=\"pl-en\">get</span><span class=\"pl-kos\">(</span><span class=\"pl-s\">\"content-encoding\"</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\"></span> <span class=\"pl-kos\">{</span>\n     <span class=\"pl-k\">const</span> <span class=\"pl-s1\">headers</span> <span class=\"pl-c1\">=</span> <span class=\"pl-k\">new</span> <span class=\"pl-smi\">Headers</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">resp</span><span class=\"pl-kos\">.</span><span class=\"pl-c1\">headers</span><span class=\"pl-kos\">)</span>\n     <span class=\"pl-s1\">headers</span><span class=\"pl-kos\">.</span><span class=\"pl-en\">delete</span><span class=\"pl-kos\">(</span><span class=\"pl-s\">\"content-encoding\"</span><span class=\"pl-kos\">)</span>\n     <span class=\"pl-s1\">headers</span><span class=\"pl-kos\">.</span><span class=\"pl-en\">delete</span><span class=\"pl-kos\">(</span><span class=\"pl-s\">\"content-length\"</span><span class=\"pl-kos\">)</span>\n     <span class=\"pl-s1\">resp</span> <span class=\"pl-c1\">=</span> <span class=\"pl-k\">new</span> <span class=\"pl-smi\">Response</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">body</span><span class=\"pl-kos\">,</span> <span class=\"pl-kos\">{</span> ...<span class=\"pl-s1\">resp</span><span class=\"pl-kos\">,</span> headers <span class=\"pl-kos\">}</span><span class=\"pl-kos\">)</span>\n   <span class=\"pl-kos\">}</span>\n   <span class=\"pl-k\">return</span> <span class=\"pl-s1\">resp</span>\n<span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\">This is cumbersome and should live in library code. It can't live in frameworks, because it's impossible to differentiate a response produced by fetch (content-encoding header, but uncompressed body) from a compressed Response created in user code (same content-encoding header, but compressed body).</p>\n<p dir=\"auto\">Instead of this workaround, <code class=\"notranslate\">fetch</code> should require the <code class=\"notranslate\">content-length</code> and <code class=\"notranslate\">content-encoding</code> headers to be deleted when response body is decompressed.</p>\n<p dir=\"auto\">Some implementors already do this, including Deno and workerd. Netlify might implement the same for Netlify Functions 2.0.</p>\n<p dir=\"auto\">I've checked undici (Node.js), node-fetch, Chrome and Safari - all of them expose the behaviour explained above, where the headers don't match the body.</p>\n<p dir=\"auto\">An alternative solution for this would be <a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load title\" data-id=\"1431770838\" data-permission-text=\"Title is private\" data-url=\"https://github.com/whatwg/fetch/issues/1524\" data-hovercard-type=\"issue\" data-hovercard-url=\"/whatwg/fetch/issues/1524/hovercard\" href=\"https://github.com/whatwg/fetch/issues/1524\">whatwg#1524</a> - that way, frameworks can use the decompressed body field to tell compressed responses from uncompressed ones.</p>\n<hr>\n<p dir=\"auto\">Summary:</p>\n<p dir=\"auto\"><strong>What's the problem?</strong> compressed responses having <code class=\"notranslate\">content-encoding</code> header, but decompressed <code class=\"notranslate\">body</code> leads to incoherent <code class=\"notranslate\">Response</code><br>\n<strong>What's the usecase?</strong>  mostly reverse proxying<br>\n<strong>Is it relevant to upstream?</strong> Yes, potentially because of service workers.<br>\n<strong>What's my suggestion for a fix?</strong> Upon decompression, <code class=\"notranslate\">content-length</code> and <code class=\"notranslate\">content-encoding</code> headers should be deleted.<br>\n<strong>How do engines deal with this?</strong> Most have the bug, but Deno and workerd implemented the fix I propose.</p>",
            "url": "https://github.com/wintercg/fetch/issues/23",
            "title": "For compressed responses, omit `Content-Length` and `Content-Encoding` headers",
            "date_modified": "2024-01-02T08:58:09.000Z",
            "date_published": "2023-12-11T16:13:34.000Z",
            "author": {
                "name": "Skn0tt",
                "url": "https://github.com/Skn0tt"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/2352663?u=6d0db159fb863f7648118acf92b7960701228bf9&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><p dir=\"auto\">Hey, I'm sorry if this has already been discussed. I'm just wondering why an entirely new API is being designed when there is at least one existing proposal: <a href=\"https://wicg.github.io/direct-sockets/\" rel=\"nofollow\">https://wicg.github.io/direct-sockets/</a><br>\nHas it been considered to work with Google on that?</p>",
            "url": "https://github.com/wintercg/proposal-sockets-api/issues/27",
            "title": "Why not follow existing proposals for Sockets API",
            "date_modified": "2024-01-24T10:42:42.000Z",
            "date_published": "2023-11-29T13:45:20.000Z",
            "author": {
                "name": "targos",
                "url": "https://github.com/targos"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/205482?u=de3265fd6a286e3e51965136cbe7a04bb9ec051a&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><p dir=\"auto\">I've been working on building up diagnostics_channel and TracingChannel as a high-performance data source for tracing products to consume safely rather than relying on risky monkey patching. I would like to extend that effort to defining consistent events for serverless function providers to publish around the lifecycle of a request to form a trace boundary.</p>\n<p dir=\"auto\">For the tracing use case a clear <code class=\"notranslate\">start</code> and <code class=\"notranslate\">end</code> event will be needed to scope the activity of that request. Additionally some error tracking event would be valuable. This could be a single event or it may be worth splitting out certain commit failure cases such as timeouts.</p>\n<p dir=\"auto\">Is this something others feel makes sense as a part of this functions API initiative, or should standardization of this debugging information be considered separately? What are others thoughts on what this should look like?</p>",
            "url": "https://github.com/wintercg/proposal-functions-api/issues/4",
            "title": "Consistent use of diagnostics_channel events to demarcate the boundaries of a request",
            "date_modified": "2023-11-15T18:29:03.000Z",
            "date_published": "2023-11-15T18:29:03.000Z",
            "author": {
                "name": "Qard",
                "url": "https://github.com/Qard"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/11367844?v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><p dir=\"auto\">This is sort of similar to <a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load title\" data-id=\"1549639044\" data-permission-text=\"Title is private\" data-url=\"https://github.com/wintercg/fetch/issues/9\" data-hovercard-type=\"issue\" data-hovercard-url=\"/wintercg/fetch/issues/9/hovercard\" href=\"https://github.com/wintercg/fetch/issues/9\">#9</a> but I think it has some interesting semantics that might be worth looking into seperately.</p>\n<p dir=\"auto\">The current spec is very clear that <code class=\"notranslate\">Response.redirect</code> MUST be resolved against the current url. This is rather unfortunate by itself since server runtimes don't really have a concept of \"current url\". Outside of that, redirects (especially when paired with status code <code class=\"notranslate\">307</code>) are incredibly common for stuff like OAuth flows.</p>\n<p dir=\"auto\">Currently, doing:</p>\n<div class=\"highlight highlight-source-ts notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"return Response.redirect(&quot;/home&quot;, 307);\"><pre class=\"notranslate\"><span class=\"pl-k\">return</span> <span class=\"pl-smi\">Response</span><span class=\"pl-kos\">.</span><span class=\"pl-en\">redirect</span><span class=\"pl-kos\">(</span><span class=\"pl-s\">\"/home\"</span><span class=\"pl-kos\">,</span> <span class=\"pl-c1\">307</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">;</span></pre></div>\n<p dir=\"auto\">just errors in Node and Deno (without the <code class=\"notranslate\">--location</code> flag). The correct way to do this currently is</p>\n<div class=\"highlight highlight-source-ts notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"return new Response(null, {\n    status: 307,\n    headers: {\n        &quot;Location&quot;: &quot;/home&quot;\n    }\n});\"><pre class=\"notranslate\"><span class=\"pl-k\">return</span> <span class=\"pl-k\">new</span> <span class=\"pl-smi\">Response</span><span class=\"pl-kos\">(</span><span class=\"pl-c1\">null</span><span class=\"pl-kos\">,</span> <span class=\"pl-kos\">{</span>\n    <span class=\"pl-c1\">status</span>: <span class=\"pl-c1\">307</span><span class=\"pl-kos\">,</span>\n    <span class=\"pl-c1\">headers</span>: <span class=\"pl-kos\">{</span>\n        <span class=\"pl-s\">\"Location\"</span>: <span class=\"pl-s\">\"/home\"</span>\n    <span class=\"pl-kos\">}</span>\n<span class=\"pl-kos\">}</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">;</span></pre></div>\n<p dir=\"auto\">which I think is suboptimal. Perhaps this issue should be raised upstream, because this could actually work in a web-standard <code class=\"notranslate\">Response.redirect</code>. Ideally, <code class=\"notranslate\">Response.redirect</code> would just use a relative location for status codes that support it. I'm hoping to champion this change in WinterCG and eventually land it upstream later.</p>",
            "url": "https://github.com/wintercg/fetch/issues/22",
            "title": "`Response.redirect` with relative URLs",
            "date_modified": "2024-02-13T20:07:05.000Z",
            "date_published": "2023-11-14T23:24:47.000Z",
            "author": {
                "name": "lino-levan",
                "url": "https://github.com/lino-levan"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/246651?u=80e18ea8c1e4cba31f0f0e3de791b33f0d36c523&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><p dir=\"auto\">From <a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load title\" data-id=\"1941459453\" data-permission-text=\"Title is private\" data-url=\"https://github.com/cloudflare/workerd/issues/1305\" data-hovercard-type=\"issue\" data-hovercard-url=\"/cloudflare/workerd/issues/1305/hovercard\" href=\"https://github.com/cloudflare/workerd/issues/1305\">cloudflare/workerd#1305</a> we've realised that we should define what should happen when <code class=\"notranslate\">close</code> is called on a socket that already had its <code class=\"notranslate\">closed</code> promise rejected.</p>\n<p dir=\"auto\">When the <code class=\"notranslate\">closed</code> promise is resolved then the answer is easy: <code class=\"notranslate\">close</code> does nothing.</p>\n<p dir=\"auto\">But when <code class=\"notranslate\">closed</code> is rejected, we have a couple of options:</p>\n<ul dir=\"auto\">\n<li><code class=\"notranslate\">close</code> throws the exception in <code class=\"notranslate\">closed</code></li>\n<li><code class=\"notranslate\">close</code> doesn't throw <strong>and</strong> leaves the <code class=\"notranslate\">closed</code> promise unchanged (so it remains rejected)</li>\n</ul>\n<p dir=\"auto\">Workerd currently does a third option, which I think just leads to gotchas so I want to change it, where <code class=\"notranslate\">close</code> doesn't throw but also resolves the <code class=\"notranslate\">closed</code> promise which means the exception can be lost.</p>",
            "url": "https://github.com/wintercg/proposal-sockets-api/issues/24",
            "title": "sockets.close behaviour when `closed` already rejected",
            "date_modified": "2023-11-05T23:00:11.000Z",
            "date_published": "2023-10-27T15:08:43.000Z",
            "author": {
                "name": "dom96",
                "url": "https://github.com/dom96"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/135671829?u=bde12febd669ab6108ec844bb653e8f1ab229962&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><p dir=\"auto\">There should be an ability to add client certificates to the new TLS connection. While this feature is implemented in web clients on the browser side (and not allowed from the code side), it's important to have ability to specify client certificates from code on the server side.</p>\n<p dir=\"auto\">Some apps use client certificates as an authentication technology, so it might be critical.</p>\n<p dir=\"auto\">It could look like an option properties <code class=\"notranslate\">tlsKey</code>, <code class=\"notranslate\">tlsCert</code> or as an object property <code class=\"notranslate\">tls</code> with <code class=\"notranslate\">key</code> and <code class=\"notranslate\">cert</code> properties:</p>\n<div class=\"highlight highlight-source-js notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"const socket = connect('https://example.com', {\n  tls: {\n    key: clientKey,\n    cert: clientCert,\n  },\n)\"><pre class=\"notranslate\"><span class=\"pl-k\">const</span> <span class=\"pl-s1\">socket</span> <span class=\"pl-c1\">=</span> <span class=\"pl-en\">connect</span><span class=\"pl-kos\">(</span><span class=\"pl-s\">'https://example.com'</span><span class=\"pl-kos\">,</span> <span class=\"pl-kos\">{</span>\n  <span class=\"pl-c1\">tls</span>: <span class=\"pl-kos\">{</span>\n    <span class=\"pl-c1\">key</span>: <span class=\"pl-s1\">clientKey</span><span class=\"pl-kos\">,</span>\n    <span class=\"pl-c1\">cert</span>: <span class=\"pl-s1\">clientCert</span><span class=\"pl-kos\">,</span>\n  <span class=\"pl-kos\">}</span><span class=\"pl-kos\">,</span><span class=\"pl-kos\"></span>\n<span class=\"pl-kos\">)</span></pre></div>\n<p dir=\"auto\">The key and certificate values could be WebCrypto API primitives or TypedArray, ArrayBuffer, DataView instances.</p>",
            "url": "https://github.com/wintercg/proposal-sockets-api/issues/23",
            "title": "Add client certificates support",
            "date_modified": "2023-11-11T18:47:19.000Z",
            "date_published": "2023-10-11T17:26:39.000Z",
            "author": {
                "name": "teabroker",
                "url": "https://github.com/teabroker"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/246651?u=80e18ea8c1e4cba31f0f0e3de791b33f0d36c523&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><p dir=\"auto\"><a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load title\" data-id=\"1727934008\" data-permission-text=\"Title is private\" data-url=\"https://github.com/cloudflare/cloudflare-docs/issues/9118\" data-hovercard-type=\"pull_request\" data-hovercard-url=\"/cloudflare/cloudflare-docs/pull/9118/hovercard?comment_id=1752288727&amp;comment_type=issue_comment\" href=\"https://github.com/cloudflare/cloudflare-docs/pull/9118#issuecomment-1752288727\">cloudflare/cloudflare-docs#9118 (comment)</a></p>",
            "url": "https://github.com/wintercg/proposal-sockets-api/issues/22",
            "title": "Document allowed inputs to WritableStream::write",
            "date_modified": "2023-10-10T22:11:38.000Z",
            "date_published": "2023-10-10T22:11:38.000Z",
            "author": {
                "name": "dom96",
                "url": "https://github.com/dom96"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/135671829?u=bde12febd669ab6108ec844bb653e8f1ab229962&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><p dir=\"auto\">It should be decided not to make insecure options to be default. Developers usually rely on default values as secure enough. It could and would lead to data leakages and security breaches.</p>\n<p dir=\"auto\">The <code class=\"notranslate\">secureTransport</code> option in <code class=\"notranslate\">SocketOptions</code> should not be <code class=\"notranslate\">\"off\"</code>.</p>",
            "url": "https://github.com/wintercg/proposal-sockets-api/issues/21",
            "title": "Make defaults secure",
            "date_modified": "2023-11-05T22:48:03.000Z",
            "date_published": "2023-10-08T11:13:40.000Z",
            "author": {
                "name": "teabroker",
                "url": "https://github.com/teabroker"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/628926?u=005309ed463151dd6cf918269125f91578f15096&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><p dir=\"auto\">Your spec sites are all down.. Like: <a href=\"https://common-min-api.proposal.wintercg.org/\" rel=\"nofollow\">https://common-min-api.proposal.wintercg.org/</a></p>",
            "url": "https://github.com/wintercg/proposal-common-minimum-api/issues/59",
            "title": "Spec websites are down",
            "date_modified": "2024-01-09T12:54:58.000Z",
            "date_published": "2023-10-05T20:13:17.000Z",
            "author": {
                "name": "melroy89",
                "url": "https://github.com/melroy89"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/439929?u=88483145a53c3d594ab68146c1a8bdecc3bcd1d3&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><p dir=\"auto\">Because the socket API builds on the streams spec, it would be helpful for performance tuning to be able to specify the readable and writable queuing strategies. For example,</p>\n<div class=\"highlight highlight-source-js notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"const socket = connect('https://example.org', {\n  writableStrategy: { highWaterMark: 4096 },\n  readableStrategy: { highWaterMark: 4096 },\n});\"><pre class=\"notranslate\"><span class=\"pl-k\">const</span> <span class=\"pl-s1\">socket</span> <span class=\"pl-c1\">=</span> <span class=\"pl-en\">connect</span><span class=\"pl-kos\">(</span><span class=\"pl-s\">'https://example.org'</span><span class=\"pl-kos\">,</span> <span class=\"pl-kos\">{</span>\n  <span class=\"pl-c1\">writableStrategy</span>: <span class=\"pl-kos\">{</span> <span class=\"pl-c1\">highWaterMark</span>: <span class=\"pl-c1\">4096</span> <span class=\"pl-kos\">}</span><span class=\"pl-kos\">,</span>\n  <span class=\"pl-c1\">readableStrategy</span>: <span class=\"pl-kos\">{</span> <span class=\"pl-c1\">highWaterMark</span>: <span class=\"pl-c1\">4096</span> <span class=\"pl-kos\">}</span><span class=\"pl-kos\">,</span>\n<span class=\"pl-kos\">}</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">;</span></pre></div>",
            "url": "https://github.com/wintercg/proposal-sockets-api/issues/20",
            "title": "Writable and Readable QueuingStrategies",
            "date_modified": "2023-10-01T16:34:58.000Z",
            "date_published": "2023-10-01T16:34:58.000Z",
            "author": {
                "name": "jasnell",
                "url": "https://github.com/jasnell"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/512240?v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><p dir=\"auto\">The socket should provide the local and peer addresses for connections. For example, you may wish to know on which port the outgoing connection was established for logging or accounting purposes. In addition, it may be useful to know which IP address a wildcard connection resolved to (though obviously this will be 127.0.0.1 in most cases).</p>",
            "url": "https://github.com/wintercg/proposal-sockets-api/issues/17",
            "title": "Peer addresses",
            "date_modified": "2023-11-12T12:12:29.000Z",
            "date_published": "2023-09-28T17:13:28.000Z",
            "author": {
                "name": "mmastrac",
                "url": "https://github.com/mmastrac"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/512240?v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><p dir=\"auto\">Deno currently provides the ability to connect to a unix socket. While I believe there is no standard for unix socket addresses URIs, a few ad-hoc standards do exist for this. Ideally the connection standard should make it reasonably easy for implementers to provide additional platform-specific socket types.</p>\n<p dir=\"auto\">Some discussion around this in WhatWG: <a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load title\" data-id=\"802612854\" data-permission-text=\"Title is private\" data-url=\"https://github.com/whatwg/url/issues/577\" data-hovercard-type=\"issue\" data-hovercard-url=\"/whatwg/url/issues/577/hovercard\" href=\"https://github.com/whatwg/url/issues/577\">whatwg/url#577</a></p>",
            "url": "https://github.com/wintercg/proposal-sockets-api/issues/16",
            "title": "Unix sockets",
            "date_modified": "2023-09-28T18:23:27.000Z",
            "date_published": "2023-09-28T16:34:32.000Z",
            "author": {
                "name": "mmastrac",
                "url": "https://github.com/mmastrac"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/512240?v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><p dir=\"auto\">The spec likely needs to deal with these three items which are necessary for creating HTTP/2 connections.</p>\n<p dir=\"auto\">The socket options must allow outgoing connections to specify ALPN negotation strings and/or byte strings, and should return the negotiated values as part of a handshake.</p>\n<p dir=\"auto\">In addition, a socket should be configured so that it may optionally send/receive data before the handshake promise completes.</p>",
            "url": "https://github.com/wintercg/proposal-sockets-api/issues/14",
            "title": "Early data, handshake promise, and ALPN negotiation",
            "date_modified": "2023-11-05T22:49:11.000Z",
            "date_published": "2023-09-28T16:30:41.000Z",
            "author": {
                "name": "mmastrac",
                "url": "https://github.com/mmastrac"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/246651?u=80e18ea8c1e4cba31f0f0e3de791b33f0d36c523&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><p dir=\"auto\">Only <code class=\"notranslate\">hostname:port</code> should be supported.</p>",
            "url": "https://github.com/wintercg/proposal-sockets-api/issues/13",
            "title": "Clarify the string format of AnySocketAddress",
            "date_modified": "2023-11-05T22:21:48.000Z",
            "date_published": "2023-09-27T13:22:18.000Z",
            "author": {
                "name": "dom96",
                "url": "https://github.com/dom96"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/16144158?u=82cadd66bfcfcd8340269a3c0ce30f503acaf7b4&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><p dir=\"auto\"><a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load title\" data-id=\"1884495951\" data-permission-text=\"Title is private\" data-url=\"https://github.com/wintercg/proposal-sockets-api/issues/8\" data-hovercard-type=\"pull_request\" data-hovercard-url=\"/wintercg/proposal-sockets-api/pull/8/hovercard\" href=\"https://github.com/wintercg/proposal-sockets-api/pull/8\">#8</a></p>\n<blockquote>\n<blockquote>\n<p dir=\"auto\">A constructor for {{Socket}} is intentially not specified, and is left to implementors to create.</p>\n</blockquote>\n<p dir=\"auto\">Do we want to leave it like this? Are there reasons why implementors might want to create a constructor for Socket? If there are then it's better for us to capture that in this document and avoid every vendor creating their own constructor.</p>\n</blockquote>",
            "url": "https://github.com/wintercg/proposal-sockets-api/issues/9",
            "title": "Should we define a constructor for the Socket class?",
            "date_modified": "2023-09-08T19:46:24.000Z",
            "date_published": "2023-09-07T16:27:00.000Z",
            "author": {
                "name": "Ethan-Arrowood",
                "url": "https://github.com/Ethan-Arrowood"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/275871?v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><p dir=\"auto\">I can <code class=\"notranslate\">curl https://common-min-api.proposal.wintercg.org/</code> but not <code class=\"notranslate\">firefox https://common-min-api.proposal.wintercg.org/</code> (edit: on ubuntu) - the latter fails persistently with a <code class=\"notranslate\">NS_ERROR_UNKNOWN_HOST</code> and I believe this is due to the somewhat unusual CNAME construct:</p>\n<div class=\"snippet-clipboard-content notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"$ dig common-min-api.proposal.wintercg.org +short\nproposal-*.deno.dev.\n34.120.54.55\"><pre class=\"notranslate\"><code class=\"notranslate\">$ dig common-min-api.proposal.wintercg.org +short\nproposal-*.deno.dev.\n34.120.54.55\n</code></pre></div>\n<p dir=\"auto\">Supporting evidence: it starts working the moment I add a <code class=\"notranslate\">34.120.54.55 common-min-api.proposal.wintercg.org</code> stanza to my /etc/hosts.</p>\n<p dir=\"auto\">Also applies to the other *.proposal.wintercg.org domain names.</p>\n<p dir=\"auto\">Small aside: proposal.wintercg.org has no A or AAAA records.</p>",
            "url": "https://github.com/wintercg/www/issues/35",
            "title": "*.proposal.wintercg.org not reachable in firefox",
            "date_modified": "2024-02-01T17:33:19.000Z",
            "date_published": "2023-08-30T10:33:24.000Z",
            "author": {
                "name": "bnoordhuis",
                "url": "https://github.com/bnoordhuis"
            }
        }
    ]
}