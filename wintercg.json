{
    "version": "https://jsonfeed.org/version/1",
    "title": "org:wintercg Issues",
    "home_page_url": "https://azu.github.io/github-search-rss/wintercg.json",
    "feed_url": "https://azu.github.io/github-search-rss/wintercg.json",
    "description": "org:wintercg Issues on GitHub",
    "items": [
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/135671829?u=bde12febd669ab6108ec844bb653e8f1ab229962&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><p dir=\"auto\">It should be decided not to make insecure options to be default. Developers usually rely on default values as secure enough. It could and would lead to data leakages and security breaches.</p>\n<p dir=\"auto\">The <code class=\"notranslate\">secureTransport</code> option in <code class=\"notranslate\">SocketOptions</code> should not be <code class=\"notranslate\">\"off\"</code>.</p>",
            "url": "https://github.com/wintercg/proposal-sockets-api/issues/21",
            "title": "Make defaults secure",
            "date_modified": "2023-10-08T11:13:40.000Z",
            "date_published": "2023-10-08T11:13:40.000Z",
            "author": {
                "name": "teabroker",
                "url": "https://github.com/teabroker"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/628926?u=005309ed463151dd6cf918269125f91578f15096&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><p dir=\"auto\">Your spec sites are all down.. Like: <a href=\"https://common-min-api.proposal.wintercg.org/\" rel=\"nofollow\">https://common-min-api.proposal.wintercg.org/</a></p>",
            "url": "https://github.com/wintercg/proposal-common-minimum-api/issues/59",
            "title": "Spec websites are down",
            "date_modified": "2023-10-05T20:13:17.000Z",
            "date_published": "2023-10-05T20:13:17.000Z",
            "author": {
                "name": "melroy89",
                "url": "https://github.com/melroy89"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/439929?u=88483145a53c3d594ab68146c1a8bdecc3bcd1d3&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><p dir=\"auto\">Because the socket API builds on the streams spec, it would be helpful for performance tuning to be able to specify the readable and writable queuing strategies. For example,</p>\n<div class=\"highlight highlight-source-js notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"const socket = connect('https://example.org', {\n  writableStrategy: { highWaterMark: 4096 },\n  readableStrategy: { highWaterMark: 4096 },\n});\"><pre class=\"notranslate\"><span class=\"pl-k\">const</span> <span class=\"pl-s1\">socket</span> <span class=\"pl-c1\">=</span> <span class=\"pl-en\">connect</span><span class=\"pl-kos\">(</span><span class=\"pl-s\">'https://example.org'</span><span class=\"pl-kos\">,</span> <span class=\"pl-kos\">{</span>\n  <span class=\"pl-c1\">writableStrategy</span>: <span class=\"pl-kos\">{</span> <span class=\"pl-c1\">highWaterMark</span>: <span class=\"pl-c1\">4096</span> <span class=\"pl-kos\">}</span><span class=\"pl-kos\">,</span>\n  <span class=\"pl-c1\">readableStrategy</span>: <span class=\"pl-kos\">{</span> <span class=\"pl-c1\">highWaterMark</span>: <span class=\"pl-c1\">4096</span> <span class=\"pl-kos\">}</span><span class=\"pl-kos\">,</span>\n<span class=\"pl-kos\">}</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">;</span></pre></div>",
            "url": "https://github.com/wintercg/proposal-sockets-api/issues/20",
            "title": "Writable and Readable QueuingStrategies",
            "date_modified": "2023-10-01T16:34:58.000Z",
            "date_published": "2023-10-01T16:34:58.000Z",
            "author": {
                "name": "jasnell",
                "url": "https://github.com/jasnell"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/512240?v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><p dir=\"auto\">The socket should provide the local and peer addresses for connections. For example, you may wish to know on which port the outgoing connection was established for logging or accounting purposes. In addition, it may be useful to know which IP address a wildcard connection resolved to (though obviously this will be 127.0.0.1 in most cases).</p>",
            "url": "https://github.com/wintercg/proposal-sockets-api/issues/17",
            "title": "Peer addresses",
            "date_modified": "2023-09-30T16:14:00.000Z",
            "date_published": "2023-09-28T17:13:28.000Z",
            "author": {
                "name": "mmastrac",
                "url": "https://github.com/mmastrac"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/512240?v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><p dir=\"auto\">Deno currently provides the ability to connect to a unix socket. While I believe there is no standard for unix socket addresses URIs, a few ad-hoc standards do exist for this. Ideally the connection standard should make it reasonably easy for implementers to provide additional platform-specific socket types.</p>\n<p dir=\"auto\">Some discussion around this in WhatWG: <a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load title\" data-id=\"802612854\" data-permission-text=\"Title is private\" data-url=\"https://github.com/whatwg/url/issues/577\" data-hovercard-type=\"issue\" data-hovercard-url=\"/whatwg/url/issues/577/hovercard\" href=\"https://github.com/whatwg/url/issues/577\">whatwg/url#577</a></p>",
            "url": "https://github.com/wintercg/proposal-sockets-api/issues/16",
            "title": "Unix sockets",
            "date_modified": "2023-09-28T18:23:27.000Z",
            "date_published": "2023-09-28T16:34:32.000Z",
            "author": {
                "name": "mmastrac",
                "url": "https://github.com/mmastrac"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/512240?v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><p dir=\"auto\">The hostname negotiation for SNI may be different from the connection address. For example, a client may connect by IP to a service and provide an unresolved hostname on connection. As in <a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load title\" data-id=\"1917884775\" data-permission-text=\"Title is private\" data-url=\"https://github.com/wintercg/proposal-sockets-api/issues/14\" data-hovercard-type=\"issue\" data-hovercard-url=\"/wintercg/proposal-sockets-api/issues/14/hovercard\" href=\"https://github.com/wintercg/proposal-sockets-api/issues/14\">#14</a>, this SNI negotation result may need to provided as part of the handshake promise.</p>",
            "url": "https://github.com/wintercg/proposal-sockets-api/issues/15",
            "title": "Provide hostname for SNI",
            "date_modified": "2023-09-28T19:24:35.000Z",
            "date_published": "2023-09-28T16:33:09.000Z",
            "author": {
                "name": "mmastrac",
                "url": "https://github.com/mmastrac"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/512240?v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><p dir=\"auto\">The spec likely needs to deal with these three items which are necessary for creating HTTP/2 connections.</p>\n<p dir=\"auto\">The socket options must allow outgoing connections to specify ALPN negotation strings and/or byte strings, and should return the negotiated values as part of a handshake.</p>\n<p dir=\"auto\">In addition, a socket should be configured so that it may optionally send/receive data before the handshake promise completes.</p>",
            "url": "https://github.com/wintercg/proposal-sockets-api/issues/14",
            "title": "Early data, handshake promise, and ALPN negotiation",
            "date_modified": "2023-09-28T18:32:50.000Z",
            "date_published": "2023-09-28T16:30:41.000Z",
            "author": {
                "name": "mmastrac",
                "url": "https://github.com/mmastrac"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/246651?u=80e18ea8c1e4cba31f0f0e3de791b33f0d36c523&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><p dir=\"auto\">Only <code class=\"notranslate\">hostname:port</code> should be supported.</p>",
            "url": "https://github.com/wintercg/proposal-sockets-api/issues/13",
            "title": "Clarify the string format of AnySocketAddress",
            "date_modified": "2023-09-28T18:43:10.000Z",
            "date_published": "2023-09-27T13:22:18.000Z",
            "author": {
                "name": "dom96",
                "url": "https://github.com/dom96"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/16144158?u=82cadd66bfcfcd8340269a3c0ce30f503acaf7b4&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><p dir=\"auto\"><a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load title\" data-id=\"1884495951\" data-permission-text=\"Title is private\" data-url=\"https://github.com/wintercg/proposal-sockets-api/issues/8\" data-hovercard-type=\"pull_request\" data-hovercard-url=\"/wintercg/proposal-sockets-api/pull/8/hovercard\" href=\"https://github.com/wintercg/proposal-sockets-api/pull/8\">#8</a></p>\n<blockquote>\n<blockquote>\n<p dir=\"auto\">A constructor for {{Socket}} is intentially not specified, and is left to implementors to create.</p>\n</blockquote>\n<p dir=\"auto\">Do we want to leave it like this? Are there reasons why implementors might want to create a constructor for Socket? If there are then it's better for us to capture that in this document and avoid every vendor creating their own constructor.</p>\n</blockquote>",
            "url": "https://github.com/wintercg/proposal-sockets-api/issues/9",
            "title": "Should we define a constructor for the Socket class?",
            "date_modified": "2023-09-08T19:46:24.000Z",
            "date_published": "2023-09-07T16:27:00.000Z",
            "author": {
                "name": "Ethan-Arrowood",
                "url": "https://github.com/Ethan-Arrowood"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/275871?v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><p dir=\"auto\">I can <code class=\"notranslate\">curl https://common-min-api.proposal.wintercg.org/</code> but not <code class=\"notranslate\">firefox https://common-min-api.proposal.wintercg.org/</code> (edit: on ubuntu) - the latter fails persistently with a <code class=\"notranslate\">NS_ERROR_UNKNOWN_HOST</code> and I believe this is due to the somewhat unusual CNAME construct:</p>\n<div class=\"snippet-clipboard-content notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"$ dig common-min-api.proposal.wintercg.org +short\nproposal-*.deno.dev.\n34.120.54.55\"><pre class=\"notranslate\"><code class=\"notranslate\">$ dig common-min-api.proposal.wintercg.org +short\nproposal-*.deno.dev.\n34.120.54.55\n</code></pre></div>\n<p dir=\"auto\">Supporting evidence: it starts working the moment I add a <code class=\"notranslate\">34.120.54.55 common-min-api.proposal.wintercg.org</code> stanza to my /etc/hosts.</p>\n<p dir=\"auto\">Also applies to the other *.proposal.wintercg.org domain names.</p>\n<p dir=\"auto\">Small aside: proposal.wintercg.org has no A or AAAA records.</p>",
            "url": "https://github.com/wintercg/www/issues/35",
            "title": "*.proposal.wintercg.org not reachable in firefox",
            "date_modified": "2023-08-30T10:34:24.000Z",
            "date_published": "2023-08-30T10:33:24.000Z",
            "author": {
                "name": "bnoordhuis",
                "url": "https://github.com/bnoordhuis"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/4174848?v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><p dir=\"auto\">References:</p>\n<ul dir=\"auto\">\n<li><a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load title\" data-id=\"1554347168\" data-permission-text=\"Title is private\" data-url=\"https://github.com/oven-sh/bun/issues/1886\" data-hovercard-type=\"issue\" data-hovercard-url=\"/oven-sh/bun/issues/1886/hovercard\" href=\"https://github.com/oven-sh/bun/issues/1886\">oven-sh/bun#1886</a></li>\n<li><a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load title\" data-id=\"1838998062\" data-permission-text=\"Title is private\" data-url=\"https://github.com/nodejs/node/issues/49050\" data-hovercard-type=\"issue\" data-hovercard-url=\"/nodejs/node/issues/49050/hovercard\" href=\"https://github.com/nodejs/node/issues/49050\">nodejs/node#49050</a></li>\n<li><a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load title\" data-id=\"922412855\" data-permission-text=\"Title is private\" data-url=\"https://github.com/whatwg/fetch/issues/1254\" data-hovercard-type=\"issue\" data-hovercard-url=\"/whatwg/fetch/issues/1254/hovercard\" href=\"https://github.com/whatwg/fetch/issues/1254\">whatwg/fetch#1254</a></li>\n</ul>",
            "url": "https://github.com/wintercg/proposal-common-minimum-api/issues/55",
            "title": "Streams Standard implementation behave wildly differently in Deno, Node.js, Bun: Investigate",
            "date_modified": "2023-08-13T17:12:02.000Z",
            "date_published": "2023-08-13T17:10:42.000Z",
            "author": {
                "name": "guest271314",
                "url": "https://github.com/guest271314"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/4174848?v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><p dir=\"auto\">This Draft <a href=\"https://common-min-api.proposal.wintercg.org/\" rel=\"nofollow\">https://common-min-api.proposal.wintercg.org/</a> links to <a href=\"https://wicg.github.io/background-fetch/\" rel=\"nofollow\">https://wicg.github.io/background-fetch/</a> not <a href=\"https://fetch.spec.whatwg.org/\" rel=\"nofollow\">https://fetch.spec.whatwg.org/</a>. Disambiguate.</p>",
            "url": "https://github.com/wintercg/proposal-common-minimum-api/issues/53",
            "title": "Disambiguate BackgroundFetch from Fetch Standard",
            "date_modified": "2023-08-10T05:48:17.000Z",
            "date_published": "2023-08-10T05:48:17.000Z",
            "author": {
                "name": "guest271314",
                "url": "https://github.com/guest271314"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/52195?v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><p dir=\"auto\">One of the most annoying things in the ESM implementation in Node.js is the lack of <code class=\"notranslate\">__filename</code> and <code class=\"notranslate\">__dirname</code> to work with paths from ESM files.</p>\n<p dir=\"auto\">I would recommend we specify <code class=\"notranslate\">import.meta.dirname</code> and <code class=\"notranslate\">import.meta.filename</code> as optional shared metadata, returning the local paths in the filesystem as strings (and not <code class=\"notranslate\">file://</code> URLs).</p>\n<p dir=\"auto\">For more context: <a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load title\" data-id=\"1799813372\" data-permission-text=\"Title is private\" data-url=\"https://github.com/nodejs/node/issues/48740\" data-hovercard-type=\"pull_request\" data-hovercard-url=\"/nodejs/node/pull/48740/hovercard\" href=\"https://github.com/nodejs/node/pull/48740\">nodejs/node#48740</a></p>",
            "url": "https://github.com/wintercg/proposal-common-minimum-api/issues/50",
            "title": "import.meta.filename and import.meta.dirname",
            "date_modified": "2023-09-19T21:38:24.000Z",
            "date_published": "2023-08-02T11:52:50.000Z",
            "author": {
                "name": "mcollina",
                "url": "https://github.com/mcollina"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/21236?u=b06abb428eb56148f0d63ed53b83bcc4026226b1&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><p dir=\"auto\">APIs proposed here address the problem of hashing / signing / verifying content that is too large to hold in memory, which is great. Unfortunately it does not address use cases where you need to do those operations incrementally e.g. when large stream of data is transferred over some channel you may want to send checksums along the way.</p>\n<p dir=\"auto\">With the drafted API it would require replaying all the previous bytes. In contrast node's crypto APIs provide you with <code class=\"notranslate\">.copy()</code> method on a hasher so you can continue writing into hasher.</p>\n<p dir=\"auto\">Perhaps something along the same lines could be done here as well, e.g. instead of hashing / signing / verifying readable stream, one could create hasher / signer / verifier instance from readable stream, with a method method <code class=\"notranslate\">digest</code> / <code class=\"notranslate\">sign</code> / <code class=\"notranslate\">verify</code> to compute result for the bytes that had been written so far.</p>",
            "url": "https://github.com/wintercg/proposal-webcrypto-streams/issues/7",
            "title": "Incremental hashing / signing ",
            "date_modified": "2023-07-20T19:03:20.000Z",
            "date_published": "2023-07-20T19:03:20.000Z",
            "author": {
                "name": "Gozala",
                "url": "https://github.com/Gozala"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/4174848?v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><p dir=\"auto\">Take a look at these Native Messaging hosts written in JavaScript; Node.js, Deno, Bun, QuickJS, txiki.js. They implement reading stdin and writing stdout differently.</p>\n<p dir=\"auto\">The last time I check <code class=\"notranslate\">d8</code> (V8) and <code class=\"notranslate\">jsshell</code> (SpiderMonkey) provide no means to read stdin and write stdout using <code class=\"notranslate\">TypedArray</code>s (buffers).</p>\n<ul dir=\"auto\">\n<li><a href=\"https://github.com/guest271314/NativeMessagingHosts/blob/main/nm_nodejs.mjs\">https://github.com/guest271314/NativeMessagingHosts/blob/main/nm_nodejs.mjs</a></li>\n<li><a href=\"https://github.com/guest271314/NativeMessagingHosts/blob/main/nm_deno.js\">https://github.com/guest271314/NativeMessagingHosts/blob/main/nm_deno.js</a></li>\n<li><a href=\"https://github.com/guest271314/NativeMessagingHosts/blob/main/nm_qjs.js\">https://github.com/guest271314/NativeMessagingHosts/blob/main/nm_qjs.js</a></li>\n<li><a href=\"https://github.com/guest271314/NativeMessagingHosts/blob/main/nm_tjs.js\">https://github.com/guest271314/NativeMessagingHosts/blob/main/nm_tjs.js</a></li>\n<li><a href=\"https://github.com/guest271314/NativeMessagingHosts/blob/main/nm_bun.js\">https://github.com/guest271314/NativeMessagingHosts/blob/main/nm_bun.js</a></li>\n</ul>\n<p dir=\"auto\">Node.js does not write more than 65536 to stdout without <code class=\"notranslate\">process.stdout._handle.setBlocking(true)</code>, at least not during my testing; Deno, Node.js, Bun; txiki.js all require multiple reads to read 1 MB from stdin after reading the first 4 bytes, QuickJS reads the full 1 MB in one read.</p>\n<p dir=\"auto\">A common stdin/stdout.stderr module that can be imported (CommonJS, Ecmascript Modules, whatever) and is capable of assuming responsibility of writing string or buffer at author/application discretion will be very helpful as a common specification that can be implemented for JavaScript implementations.</p>",
            "url": "https://github.com/wintercg/proposal-common-minimum-api/issues/47",
            "title": "Common I/O (stdin/stdout/stderr) module specification",
            "date_modified": "2023-07-11T02:14:22.000Z",
            "date_published": "2023-07-11T02:14:22.000Z",
            "author": {
                "name": "guest271314",
                "url": "https://github.com/guest271314"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/8225977?u=ebf8bbc30918fe9c36833005bebc027a65984f34&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><p dir=\"auto\">In today's WinterCG meeting we agreed to add <code class=\"notranslate\">import.meta</code> to the common minimum API, including the web's <code class=\"notranslate\">url</code> property and <code class=\"notranslate\">resolve</code> method, but also Deno's <code class=\"notranslate\">main</code> property.</p>",
            "url": "https://github.com/wintercg/proposal-common-minimum-api/issues/46",
            "title": "Add `import.meta`",
            "date_modified": "2023-08-02T17:49:49.000Z",
            "date_published": "2023-07-06T19:10:03.000Z",
            "author": {
                "name": "andreubotella",
                "url": "https://github.com/andreubotella"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/67498?u=dcd3838813e80bc707de1a11a727294614196968&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><p dir=\"auto\">The <a href=\"https://wintercg.org/faq\" rel=\"nofollow\">https://wintercg.org/faq</a> page says:<br>\n<em>\"The group itself has a strict consensus policy outlined in the charter, which is oversought by the group chairs.\"</em><br>\n-- \"oversought\" should be replaced with \"overseen\".</p>\n<p dir=\"auto\">See <a href=\"https://github.com/wintercg/www/blob/main/main.jsx#L205\">https://github.com/wintercg/www/blob/main/main.jsx#L205</a></p>",
            "url": "https://github.com/wintercg/www/issues/34",
            "title": "Nit/typo in faq page",
            "date_modified": "2023-06-13T18:28:23.000Z",
            "date_published": "2023-06-13T18:26:41.000Z",
            "author": {
                "name": "cweekly",
                "url": "https://github.com/cweekly"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/297678?v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><p dir=\"auto\">These seem like great things to add.</p>\n<p dir=\"auto\">And just to start the conversation, additionally it would be amazing to spec Winter APIs out for WebAssembly, not just for JS, as a (web-friendly) alternative to WASI. It would be useful for compiling to native as well.</p>",
            "url": "https://github.com/wintercg/proposal-common-minimum-api/issues/44",
            "title": "request: WebAssembly, Worker, MessageChannel, postMessage, SharedArrayBuffer, Atomics",
            "date_modified": "2023-06-12T04:39:23.000Z",
            "date_published": "2023-06-12T01:40:38.000Z",
            "author": {
                "name": "trusktr",
                "url": "https://github.com/trusktr"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/8225977?u=ebf8bbc30918fe9c36833005bebc027a65984f34&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><p dir=\"auto\">The HTML spec defines a <a href=\"https://html.spec.whatwg.org/multipage/webappapis.html#runtime-script-errors\" rel=\"nofollow\"><code class=\"notranslate\">reportError</code></a> function which takes a JS value (usually an exception object) and acts as if that value had been thrown, without actually stopping the execution of the current function and its callstack. This seems fairly useful in server-side environments.</p>\n<p dir=\"auto\">Acting \"as if the value had been thrown\" in browsers includes firing an <code class=\"notranslate\">error</code> event at the global, propagating up the chain of workers if called inside a dedicated worker, and eventually, if the error is not handled at any step along the way, logging the corresponding error message on the console.</p>\n<p dir=\"auto\">However, specifying this for server-side runtimes would involve having to deal with the runtime's existing error handling mechanisms, which might be quite different to those in browsers. (See also <a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load title\" data-id=\"1372455065\" data-permission-text=\"Title is private\" data-url=\"https://github.com/wintercg/proposal-common-minimum-api/issues/29\" data-hovercard-type=\"issue\" data-hovercard-url=\"/wintercg/proposal-common-minimum-api/issues/29/hovercard\" href=\"https://github.com/wintercg/proposal-common-minimum-api/issues/29\">#29</a>)</p>",
            "url": "https://github.com/wintercg/proposal-common-minimum-api/issues/41",
            "title": "Consider adding `globalThis.reportError()`",
            "date_modified": "2023-05-10T15:51:44.000Z",
            "date_published": "2023-05-10T10:06:20.000Z",
            "author": {
                "name": "andreubotella",
                "url": "https://github.com/andreubotella"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/16144158?u=82cadd66bfcfcd8340269a3c0ce30f503acaf7b4&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><h2 dir=\"auto\">Introduction</h2>\n<p dir=\"auto\">As <em>runtime keys</em> have begun being adopted for individual platforms, some developers have  asked for some kind of common key indicating a package is compatible with the WinterCG <a href=\"https://common-min-api.proposal.wintercg.org/\" rel=\"nofollow\">Minimum Common API</a>, and thus the package will work in any framework that is also compatible with the Minimum Common API.</p>\n<p dir=\"auto\">The simplest solution is to add a <code class=\"notranslate\">\"wintercg\"</code> key that indicates Minimum Common API compliance. However, this solution is incomplete.</p>\n<p dir=\"auto\">Since the Minimum Common API specification can change overtime, discrepancies can form between frameworks and packages that both claim to be compliant with the standard. For example, consider ECMAScript. When a developer uses ES2020 features in their code, but the target system can only handle ES6 code, their project simply wont work. To parallel that to the Minimum Common API, imagine if the standard was to change and add a new interface. A developer then uses that new interface in their project, and expects to be able to run their project on any framework that indicates its <code class=\"notranslate\">\"wintercg\"</code> compatible. Lets assume a framework hasn't been able to add that new interface yet. This developer's project will not work in that particular framework.</p>\n<blockquote>\n<p dir=\"auto\">There are plenty more examples to demonstrate how \"wintercg\" key alone is insufficient, but lets move on to a better solution proposal</p>\n</blockquote>\n<h2 dir=\"auto\">Proposed Solution</h2>\n<p dir=\"auto\">There are multiple pieces to this problem</p>\n<ul dir=\"auto\">\n<li>How can frameworks reliably indicate they comply with the Minimum Common API?</li>\n<li>How can a library or application author indicate their thing is compatible with any framework that complies with the Minimum Common API?</li>\n<li>How can tools check at build-time and run-time that a given library or application is compatible with current framework?</li>\n</ul>\n<h3 dir=\"auto\">How can frameworks reliably indicate they comply with the Minimum Common API?</h3>\n<p dir=\"auto\">Browser have had a solution to this for a long time, web platform tests. If we create a similar test suite for the Minimum Common API (and maybe even use the existing WPT), frameworks can automatically test themselves against it and report the results to a public tool such as <a href=\"http://caniuse.com/\" rel=\"nofollow\">caniuse.com</a>.</p>\n<h3 dir=\"auto\">How can a library or application author indicate their thing is compatible with any framework that complies with the Minimum Common API?</h3>\n<p dir=\"auto\">Given the usage example in the Runtime Keys specification, libraries and applications can use the <code class=\"notranslate\">\"engines\"</code> fields in <code class=\"notranslate\">package.json</code> to indicate what framework version (or version range) they can be used in. By introducing a <code class=\"notranslate\">\"wintercg\"</code> key as well as <strong>versioning methodology</strong> for that represents compliance with the Minimum Common API, projects could specify exactly what version of the specification they are compliant with.</p>\n<h3 dir=\"auto\">How can tools check at build-time and run-time that a given library or application is compatible with current framework?</h3>\n<p dir=\"auto\">Incorporating the <strong>versioning methodology</strong> into the test suite compliance tool, build-time and run-time tooling can be instrumented to compare values between what specified in a project‚Äôs configuration file (like <code class=\"notranslate\">package.json</code>) with what has been publicly recorded and verify if the given project is supported.</p>\n<h3 dir=\"auto\">Versioning Methodology</h3>\n<blockquote>\n<p dir=\"auto\">This part of the proposal is where I believe much of the debate will be. Two options are provided to start the discussion. Please feel free to provide more options for consideration.</p>\n</blockquote>\n<p dir=\"auto\"><strong>Option 1</strong>: Annual versioning</p>\n<ul dir=\"auto\">\n<li>Works like ECMAScript</li>\n<li>At the beginning of the year, we release ‚ÄúWinterCG Minimum Common API ‚Äù, for example ‚ÄúWinterCG Minimum Common API 2023‚Äù</li>\n<li>Throughout the remainder of the year, changes are added to a ‚Äúnext‚Äù version of the spec.</li>\n<li>Keys could look like <code class=\"notranslate\">wintercg-2023</code> and <code class=\"notranslate\">wintercg-next</code></li>\n<li>But when used in something like <code class=\"notranslate\">engines</code>, they may be used like <code class=\"notranslate\">\"wintercg\": \"2023\"</code> instead</li>\n<li>For 2023 specifically, we would work to solidify and release the current spec as. And then we‚Äôd start the annual release format starting in 2024.</li>\n</ul>\n<p dir=\"auto\"><strong>Option 2:</strong> semver</p>\n<ul dir=\"auto\">\n<li>Works like many of the frameworks do</li>\n<li>Breaking changes are included in Major versions</li>\n<li>New features are included in Minor versions</li>\n<li>Fixes are included in Patch versions</li>\n<li>Keys could look like <code class=\"notranslate\">wintercg-1.0.0</code> and <code class=\"notranslate\">wintercg-2.3.4</code></li>\n<li>Similar to annual model, they keys could also be used like <code class=\"notranslate\">\"wintercg\": \"1.0.0\"</code></li>\n</ul>\n<h2 dir=\"auto\">Next Steps</h2>\n<p dir=\"auto\">Thank you for reading this proposal. Please comment your thoughts and feedback in this issue thread or in the WinterCG Matrix channel. We will discuss this proposal at the next WinterCG call on May 4th, 2023. It will also be presented during my talk at Open Source Summit on May 10th. üöÄ</p>",
            "url": "https://github.com/wintercg/runtime-keys/issues/5",
            "title": "WinterCG Common key proposal",
            "date_modified": "2023-05-11T02:02:41.000Z",
            "date_published": "2023-04-14T20:56:22.000Z",
            "author": {
                "name": "Ethan-Arrowood",
                "url": "https://github.com/Ethan-Arrowood"
            }
        }
    ]
}