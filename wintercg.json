{
    "version": "https://jsonfeed.org/version/1",
    "title": "org:wintercg Issues",
    "home_page_url": "https://azu.github.io/github-search-rss/wintercg.json",
    "feed_url": "https://azu.github.io/github-search-rss/wintercg.json",
    "description": "org:wintercg Issues on GitHub",
    "items": [
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/7239575?u=968ff1d4db2a12cc9ed8a543b5fbc0e6a3efc67e&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><p dir=\"auto\">The Concept of RRS maps directly to the MOJO::IPC dispatcher concept of ResourceIds that get resolved back to the real Resources</p>\n<h2 dir=\"auto\">Why?</h2>\n<ul dir=\"auto\">\n<li>see: <a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load title\" data-id=\"1415615970\" data-permission-text=\"Title is private\" data-url=\"https://github.com/wintercg/fetch/issues/12\" data-hovercard-type=\"issue\" data-hovercard-url=\"/wintercg/fetch/issues/12/hovercard\" href=\"https://github.com/wintercg/fetch/issues/12\">#12</a> - the comment about urls as replacement</li>\n</ul>\n<h2 dir=\"auto\">How?</h2>\n<ul dir=\"auto\">\n<li>the serviceWorker is the main browser context entrypoint for system modules builtIns it offers API's for that</li>\n<li>modifing the URL Implementation inside v8 makingit RRS Compilant with backward compat to whatwg url parsing.</li>\n</ul>\n<h2 dir=\"auto\">Usecases</h2>\n<h3 dir=\"auto\">Problem: Allow the user to load and use local code with the browser context</h3>\n<p dir=\"auto\">it is mainly a concept of exposing dynamic module loading to userland via filePicker or other methods.</p>\n<h3 dir=\"auto\">Problem: integrating a external graphics context directly into the canvas element or iframeelement videoelement imageelement</h3>\n<p dir=\"auto\">Allow Nativ HTML Elements to interact with dynamic registered nativ components.</p>\n<p dir=\"auto\">Creating a fullscreen snapshot if there would be a component called gpu::0 via directly memCopy of the GPU buffer.</p>\n<div class=\"highlight highlight-text-html-basic notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"&lt;img src=&quot;gpu::0&quot;&gt;&lt;/img&gt;\"><pre class=\"notranslate\"><span class=\"pl-kos\">&lt;</span><span class=\"pl-ent\">img</span> <span class=\"pl-c1\">src</span>=\"<span class=\"pl-s\">gpu::0</span>\"<span class=\"pl-kos\">&gt;</span><span class=\"pl-kos\">&lt;/</span><span class=\"pl-ent\">img</span><span class=\"pl-kos\">&gt;</span></pre></div>\n<h2 dir=\"auto\">Internals</h2>\n<p dir=\"auto\">The Compositor (Shell, Browser) is able to expose IPC Channels to the serviceWorker / nodejs / deno  which is able to translate the gpu::0 string to a real resourceId inside the IPC System and this way get a Handle Back for it to access.</p>\n<p dir=\"auto\">the serviceWorker solves also write locks and all that for multiple context instances.</p>\n<h2 dir=\"auto\">Successor over fetch proposal</h2>\n<p dir=\"auto\">as this allows to implement fetch as is with all its context restrictions as a none restricted fetch would be simply done by the net::<a href=\"https://domain.com/target.file\" rel=\"nofollow\">https://domain.com/target.file</a> call like it is already done internal on the C++ side.</p>\n<p dir=\"auto\">browser implementations need to request permissions for dynamic module loads while host runtimes do not if they do not want to. it is a Runtime Shell depend.</p>\n<p dir=\"auto\">think about it as Resolve Able Urls that do not get resolved by the Network Stack they are Internal ResolveableReferences defined as string Specifier.</p>\n<p dir=\"auto\">this defines a Winterop component system using RRS as Specifiers Identifiers</p>\n<p dir=\"auto\">Resolving a a module via reference inside v8</p>\n<div class=\"highlight highlight-source-ts notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"// result can be used after that via MessageChannels ports send to the context\n// result can be used to supply fetch responses.\nserviceWorker.load(fileHandle) // browser secure way without permissions as perimissions come from the fileHandle Request. Only localFiles\nserviceWorker.load() // browser secure way without permissions as perimissions come from the fileHandle Request.\nserviceWorker.load(&quot;net::https&quot;) \nserviceWorker.load(&quot;fs::/home/path/shared.so&quot;) \"><pre class=\"notranslate\"><span class=\"pl-c\">// result can be used after that via MessageChannels ports send to the context</span>\n<span class=\"pl-c\">// result can be used to supply fetch responses.</span>\n<span class=\"pl-s1\">serviceWorker</span><span class=\"pl-kos\">.</span><span class=\"pl-en\">load</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">fileHandle</span><span class=\"pl-kos\">)</span> <span class=\"pl-c\">// browser secure way without permissions as perimissions come from the fileHandle Request. Only localFiles</span>\n<span class=\"pl-s1\">serviceWorker</span><span class=\"pl-kos\">.</span><span class=\"pl-en\">load</span><span class=\"pl-kos\">(</span><span class=\"pl-kos\">)</span> <span class=\"pl-c\">// browser secure way without permissions as perimissions come from the fileHandle Request.</span>\n<span class=\"pl-s1\">serviceWorker</span><span class=\"pl-kos\">.</span><span class=\"pl-en\">load</span><span class=\"pl-kos\">(</span><span class=\"pl-s\">\"net::https\"</span><span class=\"pl-kos\">)</span> \n<span class=\"pl-s1\">serviceWorker</span><span class=\"pl-kos\">.</span><span class=\"pl-en\">load</span><span class=\"pl-kos\">(</span><span class=\"pl-s\">\"fs::/home/path/shared.so\"</span><span class=\"pl-kos\">)</span> </pre></div>",
            "url": "https://github.com/wintercg/fetch/issues/13",
            "title": "RRS: Resolveable Resource Specifier",
            "date_modified": "2022-11-10T18:57:38.000Z",
            "date_published": "2022-11-10T18:04:48.000Z",
            "author": {
                "name": "frank-dspeed",
                "url": "https://github.com/frank-dspeed"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/5900105?u=3a9f6d65f8ec7432d6ce35bb83c4a8c95ea10ca3&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><p dir=\"auto\">My company is looking for integrating WinterCG common minimum API into TypeScript config, in order to provide type checking, error highlighting, autocomplete, etc.</p>\n<h1 dir=\"auto\">1. <a href=\"https://github.com/tsconfig/bases/\">TypeScript base config</a></h1>\n<p dir=\"auto\">Developers may be able to write something like this in tsconfig.json:</p>\n<div class=\"highlight highlight-source-json notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{\n  &quot;extends&quot;: &quot;@tsconfig/wintercg/tsconfig.json&quot;\n}\"><pre class=\"notranslate\">{\n  <span class=\"pl-ent\">\"extends\"</span>: <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>@tsconfig/wintercg/tsconfig.json<span class=\"pl-pds\">\"</span></span>\n}</pre></div>\n<p dir=\"auto\">This tsconfig should at least support the common minimum APIs which are listed in <a href=\"https://blog.cloudflare.com/introducing-the-wintercg/\" rel=\"nofollow\">https://blog.cloudflare.com/introducing-the-wintercg/</a> and <a href=\"https://common-min-api.proposal.wintercg.org/\" rel=\"nofollow\">https://common-min-api.proposal.wintercg.org/</a>.</p>\n<p dir=\"auto\">Install the wintercg tsconfig:</p>\n<div class=\"highlight highlight-source-shell notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"npm install --save-dev @tsconfig/wintercg\nyarn add --dev @tsconfig/wintercg\"><pre class=\"notranslate\">npm install --save-dev @tsconfig/wintercg\nyarn add --dev @tsconfig/wintercg</pre></div>\n<h1 dir=\"auto\">2. <a href=\"https://www.typescriptlang.org/tsconfig#lib\" rel=\"nofollow\"><code class=\"notranslate\">lib</code></a></h1>\n<p dir=\"auto\">Provide WinterCG common minimum API access in the <code class=\"notranslate\">lib</code> configuration. For example: <code class=\"notranslate\">lib</code> can be set to <code class=\"notranslate\">WinterCG</code>.</p>\n<p dir=\"auto\"><a target=\"_blank\" rel=\"noopener noreferrer nofollow\" href=\"https://user-images.githubusercontent.com/5900105/199933617-f56dbf2c-3c99-4c58-83d2-28ecda2e1d64.png\"><img src=\"https://user-images.githubusercontent.com/5900105/199933617-f56dbf2c-3c99-4c58-83d2-28ecda2e1d64.png\" alt=\"Screenshot from 2022-11-04 16-59-36\" style=\"max-width: 100%;\"></a></p>",
            "url": "https://github.com/wintercg/proposal-common-minimum-api/issues/31",
            "title": "Provide TypeScript config for minimum common API",
            "date_modified": "2022-11-05T03:49:49.000Z",
            "date_published": "2022-11-04T06:31:36.000Z",
            "author": {
                "name": "ytxmobile98",
                "url": "https://github.com/ytxmobile98"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/16144158?u=82cadd66bfcfcd8340269a3c0ce30f503acaf7b4&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><p dir=\"auto\">As promised a few calls ago, I have been working on drafting the initial specification for WinterCG Fetch. I've had many discussions with multiple folks and I have arrived at two options for us. I'd like us to decide on one of them as the organization structure for our specification. Once agreed; I will continue <a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load title\" data-id=\"1371464266\" data-permission-text=\"Title is private\" data-url=\"https://github.com/wintercg/fetch/issues/11\" data-hovercard-type=\"pull_request\" data-hovercard-url=\"/wintercg/fetch/pull/11/hovercard\" href=\"https://github.com/wintercg/fetch/pull/11\">#11</a> and get our base line specification published.</p>\n<h3 dir=\"auto\">Option 1</h3>\n<p dir=\"auto\">The first option is to create a fork of <code class=\"notranslate\">whatwg/fetch</code> here in wintercg. We will utilize aspects of the <a href=\"https://tabatkins.github.io/bikeshed/\" rel=\"nofollow\">Bikeshed</a> language (which is what <code class=\"notranslate\">whatwg/fetch</code> is written in) to omit sections and include notes/extensions for aspects that we want to modify.</p>\n<p dir=\"auto\">We will be responsible for rebasing our modifications every time Fetch lands a change to the specification. This could be partially automated where we create a bot that watches the <code class=\"notranslate\">whatwg/fetch</code> repo, and anytime new commit(s) are merged to <code class=\"notranslate\">main</code>, it would open a branch and attempts to do the necessary git operations. Of course, if there are merge conflicts they would need to be settled by a contributor here in WinterCG.</p>\n<p dir=\"auto\">This will ensure our specification is always up to date with the latest whatwg version.</p>\n<p dir=\"auto\">This option has a long-term maintenance cost where members of WinterCG would be responsible for managing the rebasing overtime. As stated, it could be automated, but it wouldn't be a perfect solution as whenever conflicts arise someone would have to spend time fixing them.</p>\n<h3 dir=\"auto\">Option 2</h3>\n<p dir=\"auto\">The second option is to start with essentially an empty specification that states something along the lines of: \"Unless otherwise specified in this document, WinterCG Fetch is compatible with the latest edition of WHATWG Fetch specification\". Then, overtime as we agree on modifications to <code class=\"notranslate\">whatwg/fetch</code>, we will create new sections within our document that states the necessary changes. For example, lets pretend we agree to get rid of the entire concept of \"Forbidden Headers\". Our specification may include a section such as:</p>\n<blockquote>\n<p dir=\"auto\">Please note this is purely for demonstration purposes. The WinterCG has made no decisions regarding modifications to the Whatwg Fetch API and the content in the following example is purely hypothetical. Do not use this issue thread to discuss the nuance of the example.</p>\n</blockquote>\n<div class=\"snippet-clipboard-content notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"### Headers\n\n#### Modification of Forbidden Headers List\n\nSection [2.2.2 Headers #forbidden-header-name](https://fetch.spec.whatwg.org/#forbidden-header-name) of the whatwg/fetch specification states a list of header names that are considered &quot;forbidden&quot;. During runtime execution of the Fetch API, usage of a forbidden header results in an early return such as in the [Concept Headers append](https://fetch.spec.whatwg.org/#concept-headers-append) section.\n\nWinterCG Fetch deviates from this section by stating that there are **no** forbidden headers. A WinterCG Fetch API will not return early if it encounters one of these headers.\"><pre class=\"notranslate\"><code class=\"notranslate\">### Headers\n\n#### Modification of Forbidden Headers List\n\nSection [2.2.2 Headers #forbidden-header-name](https://fetch.spec.whatwg.org/#forbidden-header-name) of the whatwg/fetch specification states a list of header names that are considered \"forbidden\". During runtime execution of the Fetch API, usage of a forbidden header results in an early return such as in the [Concept Headers append](https://fetch.spec.whatwg.org/#concept-headers-append) section.\n\nWinterCG Fetch deviates from this section by stating that there are **no** forbidden headers. A WinterCG Fetch API will not return early if it encounters one of these headers.\n</code></pre></div>\n<p dir=\"auto\">This option has less maintenance burden as it could essentially stagnate while remaining \"up to date\". With the catch all statement stating that essentially WinterCG Fetch <strong>is</strong> WHATWG Fetch unless otherwise noted. The WHATWG Fetch could land changes and unless we need to deviate from those changes, we don't have to modify our specification.</p>\n<p dir=\"auto\">Unfortunately, this also means that if we are not on top of changes to WHATWG Fetch, we could incorrectly be supporting something they add that we want to deviate from. Arguably, implementations don't generally move as quickly as standards. And so even if there is a bit of a lag between us coming to decision on a hypothetical change to WHATWG Fetch, many implementers would already be apart of the conversation and it wouldn't have much impact.</p>\n<hr>\n<p dir=\"auto\">With these two options, please react to this post with which one you prefer more to give us a sense of what folks are preferring. We will also be discussing this at upcoming wintercg calls. When we come to a majority decision I will create the initial proposal draft. In the mean time, we can being making API decisions for WinterCG Fetch - capture the result in issues, and when we eventually get our proposal created, I can add those decisions to the initial draft. Also please feel free to use this issue to discuss details of either option too.</p>\n<p dir=\"auto\">Thank you!</p>\n<p dir=\"auto\">Option 1 - react with: <g-emoji class=\"g-emoji\" alias=\"smile\" fallback-src=\"https://github.githubassets.com/images/icons/emoji/unicode/1f604.png\">😄</g-emoji></p>\n<p dir=\"auto\">Option 2 - react with: <g-emoji class=\"g-emoji\" alias=\"rocket\" fallback-src=\"https://github.githubassets.com/images/icons/emoji/unicode/1f680.png\">🚀</g-emoji></p>",
            "url": "https://github.com/wintercg/fetch/issues/12",
            "title": "Specification outline",
            "date_modified": "2022-11-10T16:34:13.000Z",
            "date_published": "2022-10-19T21:40:11.000Z",
            "author": {
                "name": "Ethan-Arrowood",
                "url": "https://github.com/Ethan-Arrowood"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/241506?u=5c10f2bbf617c297b2ceb8d0e827906007a7d5a7&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><p dir=\"auto\">A lot of times I encounter the need to single a specific runtime out. For instance, all wintercg runtimes meet my criteria except <code class=\"notranslate\">node</code>.</p>\n<p dir=\"auto\">What I'm looking for is key setup which allows me to put specific runtimes infront of a wintercg catchall.</p>",
            "url": "https://github.com/wintercg/runtime-keys/issues/1",
            "title": "wintercg-specific fallback",
            "date_modified": "2022-11-11T01:58:28.000Z",
            "date_published": "2022-10-05T06:06:05.000Z",
            "author": {
                "name": "panva",
                "url": "https://github.com/panva"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/2842176?v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><p dir=\"auto\">For exceptions from <code class=\"notranslate\">Promise</code>, we can simply use <code class=\"notranslate\">unhandledrejection</code>. But how about exceptions that not come from <code class=\"notranslate\">Promise</code>? Is there any way to specify the behavior?</p>",
            "url": "https://github.com/wintercg/proposal-common-minimum-api/issues/29",
            "title": "How to deal with something like `UncaughtException`?",
            "date_modified": "2022-09-18T19:44:16.000Z",
            "date_published": "2022-09-14T06:54:55.000Z",
            "author": {
                "name": "XadillaX",
                "url": "https://github.com/XadillaX"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/439929?u=88483145a53c3d594ab68146c1a8bdecc3bcd1d3&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><p dir=\"auto\">Within Workers we have been having a discussion about how to communicate to users via Errors that the conditions leading to an error are temporary and that the user should retry their operation. The how and when to retry is not important here.</p>\n<p dir=\"auto\">For example, a <code class=\"notranslate\">fetch()</code> promise can fail for many reasons. The network path could temporarily be down, the URL could be blocked, the header could be malformated, etc. We want to be able to clearly indicate that the user can/should retry their operation <em>without</em> requiring that the user resort to parsing the error message.</p>\n<p dir=\"auto\">We have several possible paths forward, all of which have the same fundamental problem. We'd like to get consensus on which approach folks would find the most agreeable.</p>\n<h2 dir=\"auto\">Option 1: New error types</h2>\n<div class=\"highlight highlight-source-js notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"const err = new Error('an error occurred');\nObject.defineProperty(err, 'name', { value: 'RetriableError' });\"><pre class=\"notranslate\"><span class=\"pl-k\">const</span> <span class=\"pl-s1\">err</span> <span class=\"pl-c1\">=</span> <span class=\"pl-k\">new</span> <span class=\"pl-v\">Error</span><span class=\"pl-kos\">(</span><span class=\"pl-s\">'an error occurred'</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-v\">Object</span><span class=\"pl-kos\">.</span><span class=\"pl-en\">defineProperty</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">err</span><span class=\"pl-kos\">,</span> <span class=\"pl-s\">'name'</span><span class=\"pl-kos\">,</span> <span class=\"pl-kos\">{</span> <span class=\"pl-c1\">value</span>: <span class=\"pl-s\">'RetriableError'</span> <span class=\"pl-kos\">}</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">;</span></pre></div>\n<h2 dir=\"auto\">Option 2: Non-standard own properties on <code class=\"notranslate\">Error</code></h2>\n<div class=\"highlight highlight-source-js notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"const err = new Error('an error occurred');\nerr.retriable = true;\"><pre class=\"notranslate\"><span class=\"pl-k\">const</span> <span class=\"pl-s1\">err</span> <span class=\"pl-c1\">=</span> <span class=\"pl-k\">new</span> <span class=\"pl-v\">Error</span><span class=\"pl-kos\">(</span><span class=\"pl-s\">'an error occurred'</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-s1\">err</span><span class=\"pl-kos\">.</span><span class=\"pl-c1\">retriable</span> <span class=\"pl-c1\">=</span> <span class=\"pl-c1\">true</span><span class=\"pl-kos\">;</span></pre></div>\n<h2 dir=\"auto\">Option 3: Using <code class=\"notranslate\">cause</code></h2>\n<div class=\"highlight highlight-source-js notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"const err = new Error('an error occured', { cause: { retriable: true } })\"><pre class=\"notranslate\"><span class=\"pl-k\">const</span> <span class=\"pl-s1\">err</span> <span class=\"pl-c1\">=</span> <span class=\"pl-k\">new</span> <span class=\"pl-v\">Error</span><span class=\"pl-kos\">(</span><span class=\"pl-s\">'an error occured'</span><span class=\"pl-kos\">,</span> <span class=\"pl-kos\">{</span> <span class=\"pl-c1\">cause</span>: <span class=\"pl-kos\">{</span> <span class=\"pl-c1\">retriable</span>: <span class=\"pl-c1\">true</span> <span class=\"pl-kos\">}</span> <span class=\"pl-kos\">}</span><span class=\"pl-kos\">)</span></pre></div>\n<h2 dir=\"auto\">Option 4: Using <code class=\"notranslate\">AggregateError</code></h2>\n<div class=\"highlight highlight-source-js notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"// The first object is always an error but the additional things communicate\n// the additional structured information we want.\nconst err = new AggregateError([\n  new Error('an error occurred'),\n  { retriable: true }\n])\"><pre class=\"notranslate\"><span class=\"pl-c\">// The first object is always an error but the additional things communicate</span>\n<span class=\"pl-c\">// the additional structured information we want.</span>\n<span class=\"pl-k\">const</span> <span class=\"pl-s1\">err</span> <span class=\"pl-c1\">=</span> <span class=\"pl-k\">new</span> <span class=\"pl-v\">AggregateError</span><span class=\"pl-kos\">(</span><span class=\"pl-kos\">[</span>\n  <span class=\"pl-k\">new</span> <span class=\"pl-v\">Error</span><span class=\"pl-kos\">(</span><span class=\"pl-s\">'an error occurred'</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">,</span>\n  <span class=\"pl-kos\">{</span> <span class=\"pl-c1\">retriable</span>: <span class=\"pl-c1\">true</span> <span class=\"pl-kos\">}</span>\n<span class=\"pl-kos\">]</span><span class=\"pl-kos\">)</span></pre></div>\n<h2 dir=\"auto\">Option 5: ??</h2>\n<p dir=\"auto\">Other ideas?</p>\n<h2 dir=\"auto\">Current Thinking</h2>\n<p dir=\"auto\">My current thinking here is to prefer Option 3, using the <code class=\"notranslate\">cause</code> property.</p>\n<p dir=\"auto\">Specifically, pulling out to a logical level: The purpose of the <code class=\"notranslate\">cause</code> is to communicate the reason for this error. That reason might be that another <code class=\"notranslate\">Error</code> was thrown, or it might be that some other condition occurred. For instance, the network was down, or there was an internal error, etc. So let's differentiate between <code class=\"notranslate\">Error</code> and <code class=\"notranslate\">Condition</code>.</p>\n<p dir=\"auto\">If I have a transient condition and want to communicate that the user should retry their operation, then I could logically do something like:</p>\n<div class=\"highlight highlight-source-js notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"cont condition = {\n  // The condition is temporary....\n  transient: true,\n  // The operation is retriable...\n  retriable: true,\n};\nconst err = new Error('oops that failed', { cause: condition });\"><pre class=\"notranslate\"><span class=\"pl-s1\">cont</span> <span class=\"pl-s1\">condition</span> <span class=\"pl-c1\">=</span> <span class=\"pl-kos\">{</span>\n  <span class=\"pl-c\">// The condition is temporary....</span>\n  <span class=\"pl-c1\">transient</span>: <span class=\"pl-c1\">true</span><span class=\"pl-kos\">,</span>\n  <span class=\"pl-c\">// The operation is retriable...</span>\n  <span class=\"pl-c1\">retriable</span>: <span class=\"pl-c1\">true</span><span class=\"pl-kos\">,</span>\n<span class=\"pl-kos\">}</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-k\">const</span> <span class=\"pl-s1\">err</span> <span class=\"pl-c1\">=</span> <span class=\"pl-k\">new</span> <span class=\"pl-v\">Error</span><span class=\"pl-kos\">(</span><span class=\"pl-s\">'oops that failed'</span><span class=\"pl-kos\">,</span> <span class=\"pl-kos\">{</span> <span class=\"pl-c1\">cause</span>: <span class=\"pl-s1\">condition</span> <span class=\"pl-kos\">}</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">;</span></pre></div>\n<p dir=\"auto\">The challenge with this, of course, is interoperability. If workers chooses to use <code class=\"notranslate\">cause</code> in this way but other <code class=\"notranslate\">fetch()</code> implementations choose to use <code class=\"notranslate\">cause</code> in other ways then we can run into interop issues. To be clear, <em>ALL</em> of the options suffer from this exact problem.</p>\n<h2 dir=\"auto\">Proposal</h2>\n<p dir=\"auto\">The proposal I would like to make is to define a new <code class=\"notranslate\">ErrorCondition</code> interface specifically for use with <code class=\"notranslate\">cause</code></p>\n<p dir=\"auto\">Essentially (treat this as a discussion example to express intent... the <em>actual</em> proposal can be refined):</p>\n<div class=\"snippet-clipboard-content notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"dictionary ErrorConditionInit {\n  boolean transient = false;\n  boolean retriable = false;\n  DOMString name = &quot;&quot;;\n};\n\ninterface ErrorCondition {\n  constructor(optional DOMString message = &quot;&quot;, optional ConditionInit init = {});\n  readonly attribute boolean transient;\n  readonly attribute boolean retriable;\n  readonly attribute DOMString name;\n  readonly attribute DOMString message;\n}\"><pre class=\"notranslate\"><code class=\"notranslate\">dictionary ErrorConditionInit {\n  boolean transient = false;\n  boolean retriable = false;\n  DOMString name = \"\";\n};\n\ninterface ErrorCondition {\n  constructor(optional DOMString message = \"\", optional ConditionInit init = {});\n  readonly attribute boolean transient;\n  readonly attribute boolean retriable;\n  readonly attribute DOMString name;\n  readonly attribute DOMString message;\n}\n</code></pre></div>\n<p dir=\"auto\">Note that this interface <em>intentionally</em> mimics <code class=\"notranslate\">DOMException</code> with the inclusion of a <code class=\"notranslate\">name</code> and <code class=\"notranslate\">message</code> accessors.</p>\n<p dir=\"auto\">Example use (assuming the proposal to add <code class=\"notranslate\">cause</code> to <code class=\"notranslate\">DOMException</code> goes through):</p>\n<div class=\"snippet-clipboard-content notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"const err = new DOMException('The operation failed', {\n  name: 'NETWORK_ERR',\n  cause: new ErrorCondition('The network path is down', {\n    transient: true,\n    retriable: true,\n  })\n});\n\nconsole.log(err.cause.transient);  // true\nconsole.log(err.cause.retriable); // true\"><pre class=\"notranslate\"><code class=\"notranslate\">const err = new DOMException('The operation failed', {\n  name: 'NETWORK_ERR',\n  cause: new ErrorCondition('The network path is down', {\n    transient: true,\n    retriable: true,\n  })\n});\n\nconsole.log(err.cause.transient);  // true\nconsole.log(err.cause.retriable); // true\n</code></pre></div>\n<p dir=\"auto\">To be clear, I don't really have strong opinions on exactly how we solve this use case. My only requirement is that we have a mechanism for reliably communicating transient/retriable conditions that is interoperable across runtimes.</p>\n<h2 dir=\"auto\">Some questions</h2>\n<ol dir=\"auto\">\n<li>How are retriable errors like this handled elsewhere on the web?</li>\n</ol>",
            "url": "https://github.com/wintercg/fetch/issues/10",
            "title": "Error conditions, retry, and Error.cause",
            "date_modified": "2022-09-10T22:02:02.000Z",
            "date_published": "2022-09-08T18:15:41.000Z",
            "author": {
                "name": "jasnell",
                "url": "https://github.com/jasnell"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/1150298?v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><p dir=\"auto\">Already exists in at least Cloudflare Workers, Deno and Node.js...</p>",
            "url": "https://github.com/wintercg/proposal-common-minimum-api/issues/27",
            "title": "Expected `fetch` to be in the common minimum API",
            "date_modified": "2022-10-01T23:37:39.000Z",
            "date_published": "2022-09-08T14:52:54.000Z",
            "author": {
                "name": "timfish",
                "url": "https://github.com/timfish"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/8500303?u=50e30202b089c2c9bd355d8f86eae6ebcda67ffd&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><p dir=\"auto\"><a href=\"https://w3c.github.io/resource-timing/\" rel=\"nofollow\">Resource Timing</a> defines the interface <code class=\"notranslate\">PerformanceResourceTiming</code>, which represents an timing measurement entry of <a href=\"https://fetch.spec.whatwg.org/#concept-fetch\" rel=\"nofollow\">fetched</a> <a href=\"https://fetch.spec.whatwg.org/#http-scheme\" rel=\"nofollow\">http(s)</a> resources.</p>\n<p dir=\"auto\">Implementation Status:</p>\n<table role=\"table\">\n<thead>\n<tr>\n<th>Interface</th>\n<th>Node</th>\n<th>Deno</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code class=\"notranslate\">PerformanceResourceTiming</code></td>\n<td><a href=\"https://nodejs.org/dist/latest-v18.x/docs/api/perf_hooks.html#class-performanceresourcetiming\" rel=\"nofollow\"><g-emoji class=\"g-emoji\" alias=\"white_check_mark\" fallback-src=\"https://github.githubassets.com/images/icons/emoji/unicode/2705.png\">✅</g-emoji></a></td>\n<td><g-emoji class=\"g-emoji\" alias=\"question\" fallback-src=\"https://github.githubassets.com/images/icons/emoji/unicode/2753.png\">❓</g-emoji></td>\n</tr>\n<tr>\n<td><code class=\"notranslate\">Performance.clearResourceTiming</code></td>\n<td><g-emoji class=\"g-emoji\" alias=\"white_check_mark\" fallback-src=\"https://github.githubassets.com/images/icons/emoji/unicode/2705.png\">✅</g-emoji></td>\n<td><g-emoji class=\"g-emoji\" alias=\"question\" fallback-src=\"https://github.githubassets.com/images/icons/emoji/unicode/2753.png\">❓</g-emoji></td>\n</tr>\n<tr>\n<td><code class=\"notranslate\">Performance.setResourceTimingBufferSize</code></td>\n<td><g-emoji class=\"g-emoji\" alias=\"white_check_mark\" fallback-src=\"https://github.githubassets.com/images/icons/emoji/unicode/2705.png\">✅</g-emoji></td>\n<td><g-emoji class=\"g-emoji\" alias=\"question\" fallback-src=\"https://github.githubassets.com/images/icons/emoji/unicode/2753.png\">❓</g-emoji></td>\n</tr>\n</tbody>\n</table>",
            "url": "https://github.com/wintercg/performance/issues/5",
            "title": "Resource Timing",
            "date_modified": "2022-08-30T08:16:21.000Z",
            "date_published": "2022-08-25T16:29:59.000Z",
            "author": {
                "name": "legendecas",
                "url": "https://github.com/legendecas"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/8500303?u=50e30202b089c2c9bd355d8f86eae6ebcda67ffd&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><ul dir=\"auto\">\n<li>Fix auto-links to WebPerf documents.</li>\n<li>Fix auto-links to the terms defined in <a href=\"https://common-min-api.proposal.wintercg.org/\" rel=\"nofollow\">https://common-min-api.proposal.wintercg.org/</a>.</li>\n</ul>",
            "url": "https://github.com/wintercg/performance/issues/4",
            "title": "Editorial: autolinks to terms defined in other specs",
            "date_modified": "2022-08-11T17:29:55.000Z",
            "date_published": "2022-08-11T17:29:55.000Z",
            "author": {
                "name": "legendecas",
                "url": "https://github.com/legendecas"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/3468483?u=daf25d236ad2cc227470fa0da2d5bdf3dbb7feed&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><p dir=\"auto\">It's hard to use the wasm version of Canvas implementation on edge; because the size of the current implementation for canvas in npm is huge and slow.</p>\n<p dir=\"auto\">It would be nice if the runtime provide the native <code class=\"notranslate\">OffscreenCanvas</code> API.</p>",
            "url": "https://github.com/wintercg/proposal-common-minimum-api/issues/26",
            "title": "OffscreenCanvas",
            "date_modified": "2022-08-04T16:13:41.000Z",
            "date_published": "2022-08-04T13:47:00.000Z",
            "author": {
                "name": "Brooooooklyn",
                "url": "https://github.com/Brooooooklyn"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/8225977?u=ebf8bbc30918fe9c36833005bebc027a65984f34&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><p dir=\"auto\">The fetch spec includes APIs for interacting with form submissions. For example, there is the <code class=\"notranslate\">Request</code> and <code class=\"notranslate\">Response</code> constructors accepting <a href=\"https://url.spec.whatwg.org/#interface-urlsearchparams\" rel=\"nofollow\"><code class=\"notranslate\">URLSearchParams</code></a> and <a href=\"https://xhr.spec.whatwg.org/#interface-formdata\" rel=\"nofollow\"><code class=\"notranslate\">FormData</code></a> objects as the request/response body, which is generally useful and is expected to be part of the common minimum API.</p>\n<p dir=\"auto\">However, the fetch spec also defines the <a href=\"https://fetch.spec.whatwg.org/#dom-body-formdata\" rel=\"nofollow\"><code class=\"notranslate\">formData()</code></a> method of the <code class=\"notranslate\">Body</code> interface mixin, which is included in <code class=\"notranslate\">Request</code> and <code class=\"notranslate\">Response</code>. This method parses the HTTP body as a form submission enctype (either <code class=\"notranslate\">application/x-www-form-urlencoded</code> or <code class=\"notranslate\">multipart/form-data</code>) and returns a <code class=\"notranslate\">FormData</code> object. Since form submission bodies only generally make sense as requests, and it's rarely useful to parse a request body from an HTTP client, it wouldn't make much sense to include this method as part of the common minimum API – but it is certainly useful for fetch-based HTTP server APIs, as Deno and CFW have.</p>\n<p dir=\"auto\">For <code class=\"notranslate\">multipart/form-data</code> parsing, however, this method leaves things almost completely unspecified. While there is a formal definition of this format (in <a href=\"https://www.rfc-editor.org/rfc/rfc7578\" rel=\"nofollow\">RFC7578</a>, which relies on <a href=\"https://www.rfc-editor.org/rfc/rfc2046#section-5.1\" rel=\"nofollow\">the <code class=\"notranslate\">multipart</code> definitions in RFC2046</a>), it is in the form of an ABNF grammar rather than a parsing algorithms, and so different implementations differ in how they parse some input.</p>\n<p dir=\"auto\">What's more, browsers have not always escaped field names and filenames in <code class=\"notranslate\">multipart/form-data</code> payloads in the same way. For example, until last year Firefox escaped double quotes by prepending a backslash, and newlines by turning them into spaces; while Chromium and Webkit used percent-encoding. And while this percent-encoding behavior was added to the HTML spec (<a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load title\" data-id=\"784103377\" data-permission-text=\"Title is private\" data-url=\"https://github.com/whatwg/html/issues/6282\" data-hovercard-type=\"pull_request\" data-hovercard-url=\"/whatwg/html/pull/6282/hovercard\" href=\"https://github.com/whatwg/html/pull/6282\">whatwg/html#6282</a>), and FIrefox's behavior fixed in turn, no implementation of the parsing that I'm aware of (including Chromium and Webkit!) decode the percent-encoding escapes:</p>\n<div class=\"highlight highlight-source-js notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"const original = new FormData();\noriginal.set('a&quot;b', &quot;&quot;);\noriginal.set('c&quot;d', new File([], 'e&quot;f'));\nlog(original);  // a&quot;b c&quot;d e&quot;f\n\nconst parsed = await new Response(original).formData();\nlog(parsed);  // a%22b c%22d e%22f\n// (In CFW it's a%22b c%22d undefined, because it seems like files are not\n// distinguished from non-file values when parsing.)\n\nfunction log(formdata) {\n  // FormData is pair-iterable.\n  const entries = [...formdata];\n  const firstEntryName = entries[0][0];\n  const secondEntryName = entries[1][0];\n  const secondEntryFilename = entries[1][1].name;\n  console.log(firstEntryName, secondEntryName, secondEntryFilename);\n}\"><pre class=\"notranslate\"><span class=\"pl-k\">const</span> <span class=\"pl-s1\">original</span> <span class=\"pl-c1\">=</span> <span class=\"pl-k\">new</span> <span class=\"pl-v\">FormData</span><span class=\"pl-kos\">(</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-s1\">original</span><span class=\"pl-kos\">.</span><span class=\"pl-en\">set</span><span class=\"pl-kos\">(</span><span class=\"pl-s\">'a\"b'</span><span class=\"pl-kos\">,</span> <span class=\"pl-s\">\"\"</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-s1\">original</span><span class=\"pl-kos\">.</span><span class=\"pl-en\">set</span><span class=\"pl-kos\">(</span><span class=\"pl-s\">'c\"d'</span><span class=\"pl-kos\">,</span> <span class=\"pl-k\">new</span> <span class=\"pl-v\">File</span><span class=\"pl-kos\">(</span><span class=\"pl-kos\">[</span><span class=\"pl-kos\">]</span><span class=\"pl-kos\">,</span> <span class=\"pl-s\">'e\"f'</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-en\">log</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">original</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">;</span>  <span class=\"pl-c\">// a\"b c\"d e\"f</span>\n\n<span class=\"pl-k\">const</span> <span class=\"pl-s1\">parsed</span> <span class=\"pl-c1\">=</span> <span class=\"pl-k\">await</span> <span class=\"pl-k\">new</span> <span class=\"pl-v\">Response</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">original</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">.</span><span class=\"pl-en\">formData</span><span class=\"pl-kos\">(</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-en\">log</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">parsed</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">;</span>  <span class=\"pl-c\">// a%22b c%22d e%22f</span>\n<span class=\"pl-c\">// (In CFW it's a%22b c%22d undefined, because it seems like files are not</span>\n<span class=\"pl-c\">// distinguished from non-file values when parsing.)</span>\n\n<span class=\"pl-k\">function</span> <span class=\"pl-en\">log</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">formdata</span><span class=\"pl-kos\">)</span> <span class=\"pl-kos\">{</span>\n  <span class=\"pl-c\">// FormData is pair-iterable.</span>\n  <span class=\"pl-k\">const</span> <span class=\"pl-s1\">entries</span> <span class=\"pl-c1\">=</span> <span class=\"pl-kos\">[</span>...<span class=\"pl-s1\">formdata</span><span class=\"pl-kos\">]</span><span class=\"pl-kos\">;</span>\n  <span class=\"pl-k\">const</span> <span class=\"pl-s1\">firstEntryName</span> <span class=\"pl-c1\">=</span> <span class=\"pl-s1\">entries</span><span class=\"pl-kos\">[</span><span class=\"pl-c1\">0</span><span class=\"pl-kos\">]</span><span class=\"pl-kos\">[</span><span class=\"pl-c1\">0</span><span class=\"pl-kos\">]</span><span class=\"pl-kos\">;</span>\n  <span class=\"pl-k\">const</span> <span class=\"pl-s1\">secondEntryName</span> <span class=\"pl-c1\">=</span> <span class=\"pl-s1\">entries</span><span class=\"pl-kos\">[</span><span class=\"pl-c1\">1</span><span class=\"pl-kos\">]</span><span class=\"pl-kos\">[</span><span class=\"pl-c1\">0</span><span class=\"pl-kos\">]</span><span class=\"pl-kos\">;</span>\n  <span class=\"pl-k\">const</span> <span class=\"pl-s1\">secondEntryFilename</span> <span class=\"pl-c1\">=</span> <span class=\"pl-s1\">entries</span><span class=\"pl-kos\">[</span><span class=\"pl-c1\">1</span><span class=\"pl-kos\">]</span><span class=\"pl-kos\">[</span><span class=\"pl-c1\">1</span><span class=\"pl-kos\">]</span><span class=\"pl-kos\">.</span><span class=\"pl-c1\">name</span><span class=\"pl-kos\">;</span>\n  <span class=\"pl-smi\">console</span><span class=\"pl-kos\">.</span><span class=\"pl-en\">log</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">firstEntryName</span><span class=\"pl-kos\">,</span> <span class=\"pl-s1\">secondEntryName</span><span class=\"pl-kos\">,</span> <span class=\"pl-s1\">secondEntryFilename</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\">For browsers, specifying <code class=\"notranslate\">multipart/form-data</code> parsing is not a big priority, since there are not many use cases for them, and the <code class=\"notranslate\">formData()</code> method has been broken for 8 years or so. But for WinterCG runtimes with a fetch-based HTTP server API, being able to parse form submissions with the existing fetch API is crucial, and being able to accurately parse the form submissions that all browser engines are currently submitting is a large part of that. So this seems like a very interesting issue to tackle as part of the WinterCG project.</p>",
            "url": "https://github.com/wintercg/fetch/issues/9",
            "title": "Work on standardizing multipart/form-data parsing (for `Request.prototype.formData`)",
            "date_modified": "2022-10-12T07:46:08.000Z",
            "date_published": "2022-07-30T20:14:29.000Z",
            "author": {
                "name": "andreubotella",
                "url": "https://github.com/andreubotella"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/439929?u=88483145a53c3d594ab68146c1a8bdecc3bcd1d3&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><p dir=\"auto\">One of the active discussions at the whatwg/dom repo is creation of an AbortSignal that can follow other AbortSignals... see <a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load title\" data-id=\"740045062\" data-permission-text=\"Title is private\" data-url=\"https://github.com/whatwg/dom/issues/920\" data-hovercard-type=\"issue\" data-hovercard-url=\"/whatwg/dom/issues/920/hovercard\" href=\"https://github.com/whatwg/dom/issues/920\">whatwg/dom#920</a></p>\n<p dir=\"auto\">There is a proposal on the table for <code class=\"notranslate\">AbortSignal.any()</code> here: <a href=\"https://github.com/shaseley/abort-signal-any/blob/main/README.md\">https://github.com/shaseley/abort-signal-any/blob/main/README.md</a></p>\n<p dir=\"auto\">The key question for this group is whether the proposal looks good and whether wintercg has any feedback for the discussion.</p>",
            "url": "https://github.com/wintercg/proposal-common-minimum-api/issues/25",
            "title": "Use cases for AbortSignal.any()",
            "date_modified": "2022-07-30T15:35:16.000Z",
            "date_published": "2022-07-30T15:01:42.000Z",
            "author": {
                "name": "jasnell",
                "url": "https://github.com/jasnell"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/241506?u=5c10f2bbf617c297b2ceb8d0e827906007a7d5a7&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><p dir=\"auto\">I'd like to propose that <code class=\"notranslate\">Ed25519</code> EdDSA (proposed in <a href=\"https://wicg.github.io/webcrypto-secure-curves\" rel=\"nofollow\">Secure Curves in the Web Cryptography API</a>) be part of the Minimum Common Web Platform API proposal.</p>\n<p dir=\"auto\">Depending on feasibility possibly also <code class=\"notranslate\">X25519</code> key agreement.</p>",
            "url": "https://github.com/wintercg/proposal-common-minimum-api/issues/24",
            "title": "Include a subset of Web Crypto API Secure Curves",
            "date_modified": "2022-07-30T15:36:16.000Z",
            "date_published": "2022-07-14T16:34:37.000Z",
            "author": {
                "name": "panva",
                "url": "https://github.com/panva"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/2842176?v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><p dir=\"auto\">E.g. <code class=\"notranslate\">fetch('/foo')</code>, what should the whole URL should be?</p>",
            "url": "https://github.com/wintercg/fetch/issues/8",
            "title": "URL with relative uri",
            "date_modified": "2022-09-10T17:12:00.000Z",
            "date_published": "2022-06-30T17:13:19.000Z",
            "author": {
                "name": "XadillaX",
                "url": "https://github.com/XadillaX"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/1566869?u=2503348c06c35836486e92d9bcb983557dc4e955&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><h2 dir=\"auto\">Motivation</h2>\n<p dir=\"auto\">Platforms are not consistent in how they provide access to environment variables. We'd like to define a consistent API for environment variable access.</p>\n<h2 dir=\"auto\">Environment variables on existing platforms</h2>\n<h3 dir=\"auto\">Cloudflare</h3>\n<p dir=\"auto\">Environment variables are injected into the global. For example, an <code class=\"notranslate\">API_TOKEN</code> environment variable would be available directly on the global: <code class=\"notranslate\">console.log(API_TOKEN);</code></p>\n<p dir=\"auto\">Reference: <a href=\"https://developers.cloudflare.com/workers/platform/environment-variables/\" rel=\"nofollow\">https://developers.cloudflare.com/workers/platform/environment-variables/</a></p>\n<h3 dir=\"auto\">Vercel</h3>\n<p dir=\"auto\">Environment variables are defined on <code class=\"notranslate\">process.env</code> object. For example, an <code class=\"notranslate\">API_TOKEN</code> environment variable would be available by <code class=\"notranslate\">process.env.API_TOKEN</code>.</p>\n<p dir=\"auto\">Reference: <a href=\"https://vercel.com/docs/concepts/functions/serverless-functions#environment-variables\" rel=\"nofollow\">https://vercel.com/docs/concepts/functions/serverless-functions#environment-variables</a></p>\n<h3 dir=\"auto\">Deno</h3>\n<p dir=\"auto\">Environment variables are retrieved through a global <code class=\"notranslate\">Deno.env</code> object. For example, an <code class=\"notranslate\">API_TOKEN</code> environment variable would be available by <code class=\"notranslate\">Deno.env.get('API_TOKEN')</code></p>\n<p dir=\"auto\">Reference: <a href=\"https://doc.deno.land/deno/stable/~/Deno.env\" rel=\"nofollow\">https://doc.deno.land/deno/stable/~/Deno.env</a></p>\n<h3 dir=\"auto\">NodeJS</h3>\n<p dir=\"auto\">Environment variables are defined on a global <code class=\"notranslate\">process.env</code> object. For example, an <code class=\"notranslate\">API_TOKEN</code> environment variable would be available by <code class=\"notranslate\">process.env.API_TOKEN</code>.</p>\n<p dir=\"auto\">Reference: <a href=\"https://nodejs.org/docs/latest/api/process.html#processenv\" rel=\"nofollow\">https://nodejs.org/docs/latest/api/process.html#processenv</a></p>\n<h3 dir=\"auto\">Shopify Oxygen</h3>\n<p dir=\"auto\">Environment variables are defined on a global <code class=\"notranslate\">Oxygen.env</code> object. For example, an <code class=\"notranslate\">API_TOKEN</code> environment variable would be available by <code class=\"notranslate\">Oxygen.env.API_TOKEN</code>.</p>\n<p dir=\"auto\">Reference: <a href=\"https://shopify.dev/custom-storefronts/oxygen/environment-variables\" rel=\"nofollow\">https://shopify.dev/custom-storefronts/oxygen/environment-variables</a></p>\n<h2 dir=\"auto\">Options</h2>\n<h3 dir=\"auto\">Unify on one of the existing platform implementations</h3>\n<p dir=\"auto\">Which one?</p>\n<h3 dir=\"auto\"><code class=\"notranslate\">import.meta</code></h3>\n<p dir=\"auto\">The <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/import.meta\" rel=\"nofollow\"><code class=\"notranslate\">import.meta</code> object</a> exposes context-specific metadata to a JavaScript module. We could utilize that container for environment variables, <code class=\"notranslate\">import.meta.env.API_TOKEN</code>.</p>\n<p dir=\"auto\">There is precedent to <code class=\"notranslate\">import.meta.env</code> with <a href=\"https://vitejs.dev/guide/env-and-mode.html#env-variables\" rel=\"nofollow\">Vite's implementation</a>. The downside to this is that <code class=\"notranslate\">import.meta</code> is only available in ES Modules.</p>",
            "url": "https://github.com/wintercg/environment-metadata/issues/1",
            "title": "Environment variables",
            "date_modified": "2022-07-11T18:18:27.000Z",
            "date_published": "2022-06-29T21:16:43.000Z",
            "author": {
                "name": "blittle",
                "url": "https://github.com/blittle"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/11720408?u=81d18186faaee6e6a77cb714e55240f238480871&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><p dir=\"auto\">Platforms like <a href=\"https://developers.cloudflare.com/workers/runtime-apis/request/\" rel=\"nofollow\">Cloudflare Workers</a> or <a href=\"https://shopify.dev/custom-storefronts/oxygen/worker-runtime-apis#custom-headers\" rel=\"nofollow\">Shopify Oxygen</a> may need to add additional information to requests/responses. Cloudflare Workers has a proprietary <a href=\"https://developers.cloudflare.com/workers/runtime-apis/request/#incomingrequestcfproperties\" rel=\"nofollow\"><code class=\"notranslate\">.cf</code> property</a> which includes fields like geolocation data etc. Shopify's Oxygen runtime has similar needs but uses custom HTTP headers to pass the data.</p>\n<p dir=\"auto\">Since the standard doesn't offer any way to pass extra meta information along with <code class=\"notranslate\">Request</code>/<code class=\"notranslate\">Response</code> instances, it would be great to explore these and similar scenarios to see how the extra meta data may be added. There likely were no use cases for this in the browser world, but on the server side, the situation is different.</p>\n<p dir=\"auto\">Using extra HTTP custom headers might be the most obvious approach, but it has a clear downside that headers have tight size limits, aren't very suitable for holding complex data, and can't contain anything that isn't directly serialisable into a string.</p>\n<p dir=\"auto\">A custom property like <code class=\"notranslate\">.meta</code> or <code class=\"notranslate\">.metadata</code> (which should hold a JavaScript object, leaving its fields up to the vendor implementation) would be more flexible but needs to be standardised.</p>",
            "url": "https://github.com/wintercg/fetch/issues/7",
            "title": "Passing platform-specific meta information with the `Request`/`Response` instances",
            "date_modified": "2022-06-29T21:17:39.000Z",
            "date_published": "2022-06-28T15:46:25.000Z",
            "author": {
                "name": "maxshirshin",
                "url": "https://github.com/maxshirshin"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/189835?u=2d60c25c3f0cbdad0e8c9239a7283e887a3e490c&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><p dir=\"auto\">Many web platform features, including some of the ones in the WinterCG common minimum API list, are restricted to secure contexts (i.e. https websites). We should probably be explicit somewhere in the standard that WinterCG environments are generally meant to be treated similarly to secure contexts.</p>",
            "url": "https://github.com/wintercg/proposal-common-minimum-api/issues/23",
            "title": "Secure context features",
            "date_modified": "2022-06-25T22:06:36.000Z",
            "date_published": "2022-06-25T22:06:36.000Z",
            "author": {
                "name": "littledan",
                "url": "https://github.com/littledan"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/189835?u=2d60c25c3f0cbdad0e8c9239a7283e887a3e490c&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><p dir=\"auto\">When <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/generateKey\" rel=\"nofollow\">creating a key</a> in WebCrypto, the <code class=\"notranslate\">extractable</code> parameter/property indicates whether a key should be treated as opaque. This makes sense on the Web Platform where you could put something in IndexedDB and read it back out without compromising opacity, but makes less sense natively--how would it be used? Should WinterCG platforms be expected to support non-extractable keys?</p>",
            "url": "https://github.com/wintercg/proposal-common-minimum-api/issues/22",
            "title": "WebCrypto opaque/extractable keys?",
            "date_modified": "2022-06-26T06:41:28.000Z",
            "date_published": "2022-06-25T22:01:20.000Z",
            "author": {
                "name": "littledan",
                "url": "https://github.com/littledan"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/189835?u=2d60c25c3f0cbdad0e8c9239a7283e887a3e490c&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><p dir=\"auto\">ShadowRealms support some Web APIs, through the new notation <code class=\"notranslate\">[Exposed=*]</code> in WebIDL, see <a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load title\" data-id=\"1023918154\" data-permission-text=\"Title is private\" data-url=\"https://github.com/tc39/proposal-shadowrealm/issues/331\" data-hovercard-type=\"issue\" data-hovercard-url=\"/tc39/proposal-shadowrealm/issues/331/hovercard\" href=\"https://github.com/tc39/proposal-shadowrealm/issues/331\">tc39/proposal-shadowrealm#331</a>. We should consider examining the list of APIs exposed in this way and comparing it to the WinterCG list. I'd hope that, ideally, the <code class=\"notranslate\">[Exposed=*]</code> list is a subset of the WinterCG list; if we deviate from that, we should understand why.</p>",
            "url": "https://github.com/wintercg/proposal-common-minimum-api/issues/21",
            "title": "Explore relationship with ShadowRealms, [Exposed=*]",
            "date_modified": "2022-07-14T17:18:21.000Z",
            "date_published": "2022-06-25T21:54:07.000Z",
            "author": {
                "name": "littledan",
                "url": "https://github.com/littledan"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/6856458?u=215e33360b9ddfee4db978bab8a275a39972aa9f&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><p dir=\"auto\">While this initiative is focused on JavaScript interoperability for the web, it may also be valuable for JavaScript runtimes for embedded systems. Developers working in JavaScript on embedded systems are already using the programming language of the web. It makes sense for JavaScript developers who work on both embedded systems and the web to use interoperable APIs. While the resource constraints of some embedded systems limit where this is practical, there is already a significant intersection with the draft Common Minimum API.</p>\n<p dir=\"auto\">During OpenJS World 2022 in Austin, <a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/dtex/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/dtex\">@dtex</a> and I had a conversation with <a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/jasnell/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/jasnell\">@jasnell</a> about whether it would be appropriate for the WinterCG initiative to also address embedded systems. Given the overlap in technologies and developers, we agreed that it was worth exploring. To begin the conversation, it was suggested that I prepare a summary of the APIs under consideration by WinterCG that are also relevant to embedded systems from the perspective of my work with <a href=\"https://www.ecma-international.org/technical-committees/tc53/\" rel=\"nofollow\">Ecma TC53</a> (ECMAScript Modules for Embedded Systems) and <a href=\"https://www.moddable.com\" rel=\"nofollow\">Moddable</a>. The Moddable SDK provides the most complete implementation to-date of Ecma-419 and so informs these notes.</p>\n<p dir=\"auto\">The following notes are based on the \"Minimum Common Web Platform API\" draft of May 26, 2022. In all cases, any implementation referred to is a subset of the full web platform APIs.</p>\n<hr>\n<ul dir=\"auto\">\n<li><code class=\"notranslate\">TextDecoder</code></li>\n<li><code class=\"notranslate\">TextEncoder</code></li>\n</ul>\n<p dir=\"auto\">These are supported in the Moddable runtime. The <code class=\"notranslate\">TextDecoder</code> implementation accepts only UTF-8 input.</p>\n<p dir=\"auto\">In addition to API compatibility, there is a question about how code accesses the constructors. In the Moddable runtime, just about everything is a module, so these are accessed by <code class=\"notranslate\">import</code> of <code class=\"notranslate\">text/encoder</code> and <code class=\"notranslate\">text/decoder</code>. Our runtime environments can be set-up for compatibility that assign these modules to globals or provide access via alternate module paths. Will WinterCG address how these are accessed or is it implicit that it will always be via a global?</p>\n<hr>\n<ul dir=\"auto\">\n<li><code class=\"notranslate\">URL</code></li>\n<li><code class=\"notranslate\">URLPattern</code></li>\n<li><code class=\"notranslate\">URLSearchParams</code></li>\n</ul>\n<p dir=\"auto\"><code class=\"notranslate\">URLSearchParams</code> is implemented as part of the <code class=\"notranslate\">fetch</code> module in the Moddable SDK, which is built on the <a href=\"https://github.com/EcmaTC53/spec/blob/master/docs/proposals/Network%20Classes.md#network-http-request\">HTTP request</a> API proposal for Ecma-419 2nd Edition. <code class=\"notranslate\">URL</code> and <code class=\"notranslate\">URLPattern</code> could also be provided.</p>\n<p dir=\"auto\">This <code class=\"notranslate\">fetch</code> module also includes <code class=\"notranslate\">Headers</code> which is required for <code class=\"notranslate\">fetch</code>. Could <code class=\"notranslate\">Headers</code> be in-scope for WinterCG?</p>\n<hr>\n<ul dir=\"auto\">\n<li><code class=\"notranslate\">globalThis.console</code></li>\n</ul>\n<p dir=\"auto\">For compatibility with web platform code, embedded runtimes often include a minimal implementation of <code class=\"notranslate\">console</code>. It would be welcome to have a known subset of methods (and their required behaviors)  to target for interoperability.</p>\n<hr>\n<ul dir=\"auto\">\n<li><code class=\"notranslate\">globalThis.setTimeout()</code> / <code class=\"notranslate\">globalThis.clearTimeout()</code></li>\n<li><code class=\"notranslate\">globalThis.setInterval()</code> / <code class=\"notranslate\">globalThis.clearInterval()</code></li>\n</ul>\n<p dir=\"auto\">TC53 considered including these functions in the the first edition of the Ecma-419 standard but deferred them because of the overlap with other standards.</p>\n<p dir=\"auto\">The Moddable runtime implementation of Ecma-419 provides these functions by building on a lower level <code class=\"notranslate\">Timer</code> object. The implementation is not strictly web compatible, using an object for the timer rather than integer and ignoring the passthrough arguments.</p>\n<hr>\n<ul dir=\"auto\">\n<li>Streams</li>\n</ul>\n<p dir=\"auto\">Streams are not currently supported because they are too heavy as a foundational building block for many embedded devices. However, they are being evaluated as an option for scenarios and devices where they can work. For example, streaming with <code class=\"notranslate\">fetch</code> may be feasible only on more capable microcontrollers with the required memory and CPU power.</p>\n<hr>\n<ul dir=\"auto\">\n<li><code class=\"notranslate\">CompressionStream</code></li>\n<li><code class=\"notranslate\">DecompressionStream</code></li>\n</ul>\n<p dir=\"auto\">The Moddable runtime provides modules for zlib compression and decompression that emulate the <a href=\"https://www.npmjs.com/package/pako\" rel=\"nofollow\">pako</a> API. This could be used as a basis to implement <code class=\"notranslate\">CompressionStream</code> and <code class=\"notranslate\">DecompressStream</code> if Streams prove feasible.</p>\n<hr>\n<ul dir=\"auto\">\n<li><code class=\"notranslate\">globalThis.queueMicrotask()</code></li>\n<li><code class=\"notranslate\">globalThis.structuredClone()</code></li>\n</ul>\n<p dir=\"auto\">There are scenarios where these could be valuable, but they are not immediate. Consequently, while these global functions are not currently provided in the Moddable runtime, they could be.</p>\n<hr>\n<ul dir=\"auto\">\n<li>Crypto</li>\n</ul>\n<p dir=\"auto\">Ecma-419 does not specify functions or objects for cryptography. However, the need exists, especially because some microcontrollers contain hardware to accelerate and/or secure cryptographic primitives.</p>\n<hr>\n<ul dir=\"auto\">\n<li><code class=\"notranslate\">Event</code></li>\n<li><code class=\"notranslate\">EventTarget</code></li>\n</ul>\n<p dir=\"auto\">Neither Ecma-419 nor the Moddable runtime requires events. However, some web APIs which are relevant to embedded systems depend on events (see W3C Sensor below and the Moddable runtime implementation of <code class=\"notranslate\">WebSocket</code> using Ecma-419), making these relevant.</p>\n<hr>\n<ul dir=\"auto\">\n<li>W3C Sensor</li>\n</ul>\n<p dir=\"auto\">Ecma-419 defines the <a href=\"https://419.ecma-international.org/#-13-sensor-class-pattern\" rel=\"nofollow\">Sensor Class Pattern</a> for access to sensor data. The Sensor Class Pattern is designed to be a building block to implement W3C Sensor for various sensor types. Perhaps none of the non-browser web platform runtimes are using sensors yet, so this is outside the scope of WinterCG.</p>\n<p dir=\"auto\">FWIW, W3C Sensor support has been explored in the Moddable runtime using implementations of the Sensor Class Pattern. It works well. The main interoperability issue is with Events, as these assume the full Event API support of the browser. The Moddable runtime provides a minimal implementation of events for W3 Sensor. Perhaps</p>",
            "url": "https://github.com/wintercg/proposal-common-minimum-api/issues/20",
            "title": "Could embedded systems also use the Common Minimum API?",
            "date_modified": "2022-09-13T22:06:44.000Z",
            "date_published": "2022-06-21T20:03:39.000Z",
            "author": {
                "name": "phoddie",
                "url": "https://github.com/phoddie"
            }
        }
    ]
}