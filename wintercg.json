{
    "version": "https://jsonfeed.org/version/1",
    "title": "org:wintercg Issues",
    "home_page_url": "https://azu.github.io/github-search-rss/wintercg.json",
    "feed_url": "https://azu.github.io/github-search-rss/wintercg.json",
    "description": "org:wintercg Issues on GitHub",
    "items": [
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/21236?u=b06abb428eb56148f0d63ed53b83bcc4026226b1&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><p dir=\"auto\">APIs proposed here address the problem of hashing / signing / verifying content that is too large to hold in memory, which is great. Unfortunately it does not address use cases where you need to do those operations incrementally e.g. when large stream of data is transferred over some channel you may want to send checksums along the way.</p>\n<p dir=\"auto\">With the drafted API it would require replaying all the previous bytes. In contrast node's crypto APIs provide you with <code class=\"notranslate\">.copy()</code> method on a hasher so you can continue writing into hasher.</p>\n<p dir=\"auto\">Perhaps something along the same lines could be done here as well, e.g. instead of hashing / signing / verifying readable stream, one could create hasher / signer / verifier instance from readable stream, with a method method <code class=\"notranslate\">digest</code> / <code class=\"notranslate\">sign</code> / <code class=\"notranslate\">verify</code> to compute result for the bytes that had been written so far.</p>",
            "url": "https://github.com/wintercg/proposal-webcrypto-streams/issues/7",
            "title": "Incremental hashing / signing ",
            "date_modified": "2023-07-20T19:03:20.000Z",
            "date_published": "2023-07-20T19:03:20.000Z",
            "author": {
                "name": "Gozala",
                "url": "https://github.com/Gozala"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/4174848?v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><p dir=\"auto\">Take a look at these Native Messaging hosts written in JavaScript; Node.js, Deno, Bun, QuickJS, txiki.js. They implement reading stdin and writing stdout differently.</p>\n<p dir=\"auto\">The last time I check <code class=\"notranslate\">d8</code> (V8) and <code class=\"notranslate\">jsshell</code> (SpiderMonkey) provide no means to read stdin and write stdout using <code class=\"notranslate\">TypedArray</code>s (buffers).</p>\n<ul dir=\"auto\">\n<li><a href=\"https://github.com/guest271314/NativeMessagingHosts/blob/main/nm_nodejs.mjs\">https://github.com/guest271314/NativeMessagingHosts/blob/main/nm_nodejs.mjs</a></li>\n<li><a href=\"https://github.com/guest271314/NativeMessagingHosts/blob/main/nm_deno.js\">https://github.com/guest271314/NativeMessagingHosts/blob/main/nm_deno.js</a></li>\n<li><a href=\"https://github.com/guest271314/NativeMessagingHosts/blob/main/nm_qjs.js\">https://github.com/guest271314/NativeMessagingHosts/blob/main/nm_qjs.js</a></li>\n<li><a href=\"https://github.com/guest271314/NativeMessagingHosts/blob/main/nm_tjs.js\">https://github.com/guest271314/NativeMessagingHosts/blob/main/nm_tjs.js</a></li>\n<li><a href=\"https://github.com/guest271314/NativeMessagingHosts/blob/main/nm_bun.js\">https://github.com/guest271314/NativeMessagingHosts/blob/main/nm_bun.js</a></li>\n</ul>\n<p dir=\"auto\">Node.js does not write more than 65536 to stdout without <code class=\"notranslate\">process.stdout._handle.setBlocking(true)</code>, at least not during my testing; Deno, Node.js, Bun; txiki.js all require multiple reads to read 1 MB from stdin after reading the first 4 bytes, QuickJS reads the full 1 MB in one read.</p>\n<p dir=\"auto\">A common stdin/stdout.stderr module that can be imported (CommonJS, Ecmascript Modules, whatever) and is capable of assuming responsibility of writing string or buffer at author/application discretion will be very helpful as a common specification that can be implemented for JavaScript implementations.</p>",
            "url": "https://github.com/wintercg/proposal-common-minimum-api/issues/47",
            "title": "Common I/O (stdin/stdout/stderr) module specification",
            "date_modified": "2023-07-11T02:14:22.000Z",
            "date_published": "2023-07-11T02:14:22.000Z",
            "author": {
                "name": "guest271314",
                "url": "https://github.com/guest271314"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/8225977?u=ebf8bbc30918fe9c36833005bebc027a65984f34&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><p dir=\"auto\">In today's WinterCG meeting we agreed to add <code class=\"notranslate\">import.meta</code> to the common minimum API, including the web's <code class=\"notranslate\">url</code> property and <code class=\"notranslate\">resolve</code> method, but also Deno's <code class=\"notranslate\">main</code> property.</p>",
            "url": "https://github.com/wintercg/proposal-common-minimum-api/issues/46",
            "title": "Add `import.meta`",
            "date_modified": "2023-07-25T17:18:28.000Z",
            "date_published": "2023-07-06T19:10:03.000Z",
            "author": {
                "name": "andreubotella",
                "url": "https://github.com/andreubotella"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/67498?u=dcd3838813e80bc707de1a11a727294614196968&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><p dir=\"auto\">The <a href=\"https://wintercg.org/faq\" rel=\"nofollow\">https://wintercg.org/faq</a> page says:<br>\n<em>\"The group itself has a strict consensus policy outlined in the charter, which is oversought by the group chairs.\"</em><br>\n-- \"oversought\" should be replaced with \"overseen\".</p>\n<p dir=\"auto\">See <a href=\"https://github.com/wintercg/www/blob/main/main.jsx#L205\">https://github.com/wintercg/www/blob/main/main.jsx#L205</a></p>",
            "url": "https://github.com/wintercg/www/issues/34",
            "title": "Nit/typo in faq page",
            "date_modified": "2023-06-13T18:28:23.000Z",
            "date_published": "2023-06-13T18:26:41.000Z",
            "author": {
                "name": "cweekly",
                "url": "https://github.com/cweekly"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/297678?v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><p dir=\"auto\">These seem like great things to add.</p>\n<p dir=\"auto\">And just to start the conversation, additionally it would be amazing to spec Winter APIs out for WebAssembly, not just for JS, as a (web-friendly) alternative to WASI. It would be useful for compiling to native as well.</p>",
            "url": "https://github.com/wintercg/proposal-common-minimum-api/issues/44",
            "title": "request: WebAssembly, Worker, MessageChannel, postMessage, SharedArrayBuffer, Atomics",
            "date_modified": "2023-06-12T04:39:23.000Z",
            "date_published": "2023-06-12T01:40:38.000Z",
            "author": {
                "name": "trusktr",
                "url": "https://github.com/trusktr"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/8225977?u=ebf8bbc30918fe9c36833005bebc027a65984f34&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><p dir=\"auto\">The HTML spec defines a <a href=\"https://html.spec.whatwg.org/multipage/webappapis.html#runtime-script-errors\" rel=\"nofollow\"><code class=\"notranslate\">reportError</code></a> function which takes a JS value (usually an exception object) and acts as if that value had been thrown, without actually stopping the execution of the current function and its callstack. This seems fairly useful in server-side environments.</p>\n<p dir=\"auto\">Acting \"as if the value had been thrown\" in browsers includes firing an <code class=\"notranslate\">error</code> event at the global, propagating up the chain of workers if called inside a dedicated worker, and eventually, if the error is not handled at any step along the way, logging the corresponding error message on the console.</p>\n<p dir=\"auto\">However, specifying this for server-side runtimes would involve having to deal with the runtime's existing error handling mechanisms, which might be quite different to those in browsers. (See also <a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load title\" data-id=\"1372455065\" data-permission-text=\"Title is private\" data-url=\"https://github.com/wintercg/proposal-common-minimum-api/issues/29\" data-hovercard-type=\"issue\" data-hovercard-url=\"/wintercg/proposal-common-minimum-api/issues/29/hovercard\" href=\"https://github.com/wintercg/proposal-common-minimum-api/issues/29\">#29</a>)</p>",
            "url": "https://github.com/wintercg/proposal-common-minimum-api/issues/41",
            "title": "Consider adding `globalThis.reportError()`",
            "date_modified": "2023-05-10T15:51:44.000Z",
            "date_published": "2023-05-10T10:06:20.000Z",
            "author": {
                "name": "andreubotella",
                "url": "https://github.com/andreubotella"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/16144158?u=82cadd66bfcfcd8340269a3c0ce30f503acaf7b4&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><h2 dir=\"auto\">Introduction</h2>\n<p dir=\"auto\">As <em>runtime keys</em> have begun being adopted for individual platforms, some developers have  asked for some kind of common key indicating a package is compatible with the WinterCG <a href=\"https://common-min-api.proposal.wintercg.org/\" rel=\"nofollow\">Minimum Common API</a>, and thus the package will work in any framework that is also compatible with the Minimum Common API.</p>\n<p dir=\"auto\">The simplest solution is to add a <code class=\"notranslate\">\"wintercg\"</code> key that indicates Minimum Common API compliance. However, this solution is incomplete.</p>\n<p dir=\"auto\">Since the Minimum Common API specification can change overtime, discrepancies can form between frameworks and packages that both claim to be compliant with the standard. For example, consider ECMAScript. When a developer uses ES2020 features in their code, but the target system can only handle ES6 code, their project simply wont work. To parallel that to the Minimum Common API, imagine if the standard was to change and add a new interface. A developer then uses that new interface in their project, and expects to be able to run their project on any framework that indicates its <code class=\"notranslate\">\"wintercg\"</code> compatible. Lets assume a framework hasn't been able to add that new interface yet. This developer's project will not work in that particular framework.</p>\n<blockquote>\n<p dir=\"auto\">There are plenty more examples to demonstrate how \"wintercg\" key alone is insufficient, but lets move on to a better solution proposal</p>\n</blockquote>\n<h2 dir=\"auto\">Proposed Solution</h2>\n<p dir=\"auto\">There are multiple pieces to this problem</p>\n<ul dir=\"auto\">\n<li>How can frameworks reliably indicate they comply with the Minimum Common API?</li>\n<li>How can a library or application author indicate their thing is compatible with any framework that complies with the Minimum Common API?</li>\n<li>How can tools check at build-time and run-time that a given library or application is compatible with current framework?</li>\n</ul>\n<h3 dir=\"auto\">How can frameworks reliably indicate they comply with the Minimum Common API?</h3>\n<p dir=\"auto\">Browser have had a solution to this for a long time, web platform tests. If we create a similar test suite for the Minimum Common API (and maybe even use the existing WPT), frameworks can automatically test themselves against it and report the results to a public tool such as <a href=\"http://caniuse.com/\" rel=\"nofollow\">caniuse.com</a>.</p>\n<h3 dir=\"auto\">How can a library or application author indicate their thing is compatible with any framework that complies with the Minimum Common API?</h3>\n<p dir=\"auto\">Given the usage example in the Runtime Keys specification, libraries and applications can use the <code class=\"notranslate\">\"engines\"</code> fields in <code class=\"notranslate\">package.json</code> to indicate what framework version (or version range) they can be used in. By introducing a <code class=\"notranslate\">\"wintercg\"</code> key as well as <strong>versioning methodology</strong> for that represents compliance with the Minimum Common API, projects could specify exactly what version of the specification they are compliant with.</p>\n<h3 dir=\"auto\">How can tools check at build-time and run-time that a given library or application is compatible with current framework?</h3>\n<p dir=\"auto\">Incorporating the <strong>versioning methodology</strong> into the test suite compliance tool, build-time and run-time tooling can be instrumented to compare values between what specified in a project’s configuration file (like <code class=\"notranslate\">package.json</code>) with what has been publicly recorded and verify if the given project is supported.</p>\n<h3 dir=\"auto\">Versioning Methodology</h3>\n<blockquote>\n<p dir=\"auto\">This part of the proposal is where I believe much of the debate will be. Two options are provided to start the discussion. Please feel free to provide more options for consideration.</p>\n</blockquote>\n<p dir=\"auto\"><strong>Option 1</strong>: Annual versioning</p>\n<ul dir=\"auto\">\n<li>Works like ECMAScript</li>\n<li>At the beginning of the year, we release “WinterCG Minimum Common API ”, for example “WinterCG Minimum Common API 2023”</li>\n<li>Throughout the remainder of the year, changes are added to a “next” version of the spec.</li>\n<li>Keys could look like <code class=\"notranslate\">wintercg-2023</code> and <code class=\"notranslate\">wintercg-next</code></li>\n<li>But when used in something like <code class=\"notranslate\">engines</code>, they may be used like <code class=\"notranslate\">\"wintercg\": \"2023\"</code> instead</li>\n<li>For 2023 specifically, we would work to solidify and release the current spec as. And then we’d start the annual release format starting in 2024.</li>\n</ul>\n<p dir=\"auto\"><strong>Option 2:</strong> semver</p>\n<ul dir=\"auto\">\n<li>Works like many of the frameworks do</li>\n<li>Breaking changes are included in Major versions</li>\n<li>New features are included in Minor versions</li>\n<li>Fixes are included in Patch versions</li>\n<li>Keys could look like <code class=\"notranslate\">wintercg-1.0.0</code> and <code class=\"notranslate\">wintercg-2.3.4</code></li>\n<li>Similar to annual model, they keys could also be used like <code class=\"notranslate\">\"wintercg\": \"1.0.0\"</code></li>\n</ul>\n<h2 dir=\"auto\">Next Steps</h2>\n<p dir=\"auto\">Thank you for reading this proposal. Please comment your thoughts and feedback in this issue thread or in the WinterCG Matrix channel. We will discuss this proposal at the next WinterCG call on May 4th, 2023. It will also be presented during my talk at Open Source Summit on May 10th. <g-emoji class=\"g-emoji\" alias=\"rocket\" fallback-src=\"https://github.githubassets.com/images/icons/emoji/unicode/1f680.png\">🚀</g-emoji></p>",
            "url": "https://github.com/wintercg/runtime-keys/issues/5",
            "title": "WinterCG Common key proposal",
            "date_modified": "2023-05-11T02:02:41.000Z",
            "date_published": "2023-04-14T20:56:22.000Z",
            "author": {
                "name": "Ethan-Arrowood",
                "url": "https://github.com/Ethan-Arrowood"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/7829205?u=5a9294123bdf7301054aacbc88fda275f72ad4cb&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><p dir=\"auto\">Use the compliance modes from <a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load title\" data-id=\"1613807165\" data-permission-text=\"Title is private\" data-url=\"https://github.com/wintercg/fetch/issues/19\" data-hovercard-type=\"pull_request\" data-hovercard-url=\"/wintercg/fetch/pull/19/hovercard\" href=\"https://github.com/wintercg/fetch/pull/19\">#19</a> throughout the spec:</p>\n<ul class=\"contains-task-list\">\n<li class=\"task-list-item\"><input type=\"checkbox\" id=\"\" disabled=\"\" class=\"task-list-item-checkbox\"> CORS</li>\n<li class=\"task-list-item\"><input type=\"checkbox\" id=\"\" disabled=\"\" class=\"task-list-item-checkbox\"> Cookies</li>\n<li class=\"task-list-item\"><input type=\"checkbox\" id=\"\" disabled=\"\" class=\"task-list-item-checkbox\"> Caching</li>\n<li class=\"task-list-item\"><input type=\"checkbox\" id=\"\" disabled=\"\" class=\"task-list-item-checkbox\"> Service workers</li>\n<li class=\"task-list-item\"><input type=\"checkbox\" id=\"\" disabled=\"\" class=\"task-list-item-checkbox\"> Basic auth popup</li>\n</ul>",
            "url": "https://github.com/wintercg/fetch/issues/20",
            "title": "Use compliance modes throughout",
            "date_modified": "2023-03-31T10:02:38.000Z",
            "date_published": "2023-03-30T15:36:57.000Z",
            "author": {
                "name": "lucacasonato",
                "url": "https://github.com/lucacasonato"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/908303?v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><p dir=\"auto\">Hey <g-emoji class=\"g-emoji\" alias=\"wave\" fallback-src=\"https://github.githubassets.com/images/icons/emoji/unicode/1f44b.png\">👋</g-emoji> Thanks for working on this, and apologies for not looking at the spec earlier!</p>\n<p dir=\"auto\">As a high-level comment, I would argue <code class=\"notranslate\">EncryptionStream</code> should live in the same namespace as <code class=\"notranslate\">crypto.subtle.encrypt</code>. After all, it's equally \"subtle\" as that function, and people should be careful not to use unauthenticated algorithms by themselves, for example. So I think having some indication of that in the name (e.g. <code class=\"notranslate\">crypto.subtle.EncryptionStream</code>) would be good.</p>\n<p dir=\"auto\">Also, without necessarily advocating for doing so, if we ever want to add <code class=\"notranslate\">DecryptionStream</code>, that would be even more \"subtle\" (since you have to be careful not to accidentally use unauthenticated data), so that should definitely have to live under <code class=\"notranslate\">SubtleCrypto</code>, IMO.</p>",
            "url": "https://github.com/wintercg/proposal-webcrypto-streams/issues/6",
            "title": "Move EncryptionStream to SubtleCrypto?",
            "date_modified": "2023-02-08T19:02:23.000Z",
            "date_published": "2023-02-08T18:59:15.000Z",
            "author": {
                "name": "twiss",
                "url": "https://github.com/twiss"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/4174848?v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><p dir=\"auto\">What is the end-goal of this repository? What does a deliverable look like?</p>",
            "url": "https://github.com/wintercg/proposal-common-minimum-api/issues/37",
            "title": "Is this repository concerned with only Node.js and Deno - not QuickJS, txiki.js, Bun?",
            "date_modified": "2023-02-12T00:24:24.000Z",
            "date_published": "2023-01-14T16:49:17.000Z",
            "author": {
                "name": "guest271314",
                "url": "https://github.com/guest271314"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/1148376?u=97348b862d4820275f7e7567ad64a72edfec1443&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><p dir=\"auto\">I have played around with Deno's built in test runner before.<br>\nit's pretty nice. but i tend to not use it if i'm also writing test cases that should run in different env.</p>\n<p dir=\"auto\">When i write test cases for both NodeJS and Deno then i tend to simply just use a simple array or an object myself to define all test cases and import all files that i want to test. Then i just use a simple logic function that are very similar to <code class=\"notranslate\">console.assert</code> but it throws instead. then i simply just write a for loop to exec all functions, if the env match Deno then i use <code class=\"notranslate\">Deno.test</code> otherwise it have just been a classic for loop that execute. very simple and fast but lose a lot of shiny features for the cost of being more cross compatible. I'm not such a huge fan of any of the existing test framework that exist out there on npm atm.</p>\n<p dir=\"auto\">now i found out that NodeJS also have a test <a href=\"https://nodejs.org/api/test.html\" rel=\"nofollow\">runner built in</a></p>\n<p dir=\"auto\">it would be nice if both could play ball and work the same way...<br>\nI know this isn't something web related but it would be nice if i could write test cases the same way.<br>\nWould even wish for there to be some browserified version of it too.</p>\n<p dir=\"auto\">Bonus point if there where something like <code class=\"notranslate\">node --test --browsers</code> that could launch maybe a headless browser or where i could open up a own browser and navigate to url to hook it in.</p>\n<ul dir=\"auto\">\n<li>then it would dump everything to the console,</li>\n<li>talk with each other over websocket</li>\n<li>hook it into file changes</li>\n<li>have some good CI/CD that could execute all test cases in a browser and exit with either an error or a success in the terminal</li>\n</ul>",
            "url": "https://github.com/wintercg/proposal-common-minimum-api/issues/32",
            "title": "Same test api",
            "date_modified": "2022-12-18T06:20:35.000Z",
            "date_published": "2022-12-18T01:21:23.000Z",
            "author": {
                "name": "jimmywarting",
                "url": "https://github.com/jimmywarting"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/5900105?u=3a9f6d65f8ec7432d6ce35bb83c4a8c95ea10ca3&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><p dir=\"auto\">My company is looking for integrating WinterCG common minimum API into TypeScript config, in order to provide type checking, error highlighting, autocomplete, etc.</p>\n<h1 dir=\"auto\">1. <a href=\"https://github.com/tsconfig/bases/\">TypeScript base config</a></h1>\n<p dir=\"auto\">Developers may be able to write something like this in tsconfig.json:</p>\n<div class=\"highlight highlight-source-json notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{\n  &quot;extends&quot;: &quot;@tsconfig/wintercg/tsconfig.json&quot;\n}\"><pre class=\"notranslate\">{\n  <span class=\"pl-ent\">\"extends\"</span>: <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>@tsconfig/wintercg/tsconfig.json<span class=\"pl-pds\">\"</span></span>\n}</pre></div>\n<p dir=\"auto\">This tsconfig should at least support the common minimum APIs which are listed in <a href=\"https://blog.cloudflare.com/introducing-the-wintercg/\" rel=\"nofollow\">https://blog.cloudflare.com/introducing-the-wintercg/</a> and <a href=\"https://common-min-api.proposal.wintercg.org/\" rel=\"nofollow\">https://common-min-api.proposal.wintercg.org/</a>.</p>\n<p dir=\"auto\">Install the wintercg tsconfig:</p>\n<div class=\"highlight highlight-source-shell notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"npm install --save-dev @tsconfig/wintercg\nyarn add --dev @tsconfig/wintercg\"><pre class=\"notranslate\">npm install --save-dev @tsconfig/wintercg\nyarn add --dev @tsconfig/wintercg</pre></div>\n<h1 dir=\"auto\">2. <a href=\"https://www.typescriptlang.org/tsconfig#lib\" rel=\"nofollow\"><code class=\"notranslate\">lib</code></a></h1>\n<p dir=\"auto\">Provide WinterCG common minimum API access in the <code class=\"notranslate\">lib</code> configuration. For example: <code class=\"notranslate\">lib</code> can be set to <code class=\"notranslate\">WinterCG</code>.</p>\n<p dir=\"auto\"><a target=\"_blank\" rel=\"noopener noreferrer nofollow\" href=\"https://user-images.githubusercontent.com/5900105/199933617-f56dbf2c-3c99-4c58-83d2-28ecda2e1d64.png\"><img src=\"https://user-images.githubusercontent.com/5900105/199933617-f56dbf2c-3c99-4c58-83d2-28ecda2e1d64.png\" alt=\"Screenshot from 2022-11-04 16-59-36\" style=\"max-width: 100%;\"></a></p>",
            "url": "https://github.com/wintercg/proposal-common-minimum-api/issues/31",
            "title": "Provide TypeScript config for minimum common API",
            "date_modified": "2022-11-05T03:49:49.000Z",
            "date_published": "2022-11-04T06:31:36.000Z",
            "author": {
                "name": "ytxmobile98",
                "url": "https://github.com/ytxmobile98"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/16144158?u=82cadd66bfcfcd8340269a3c0ce30f503acaf7b4&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><p dir=\"auto\">As promised a few calls ago, I have been working on drafting the initial specification for WinterCG Fetch. I've had many discussions with multiple folks and I have arrived at two options for us. I'd like us to decide on one of them as the organization structure for our specification. Once agreed; I will continue <a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load title\" data-id=\"1549639442\" data-permission-text=\"Title is private\" data-url=\"https://github.com/wintercg/fetch/issues/11\" data-hovercard-type=\"issue\" data-hovercard-url=\"/wintercg/fetch/issues/11/hovercard\" href=\"https://github.com/wintercg/fetch/issues/11\">#11</a> and get our base line specification published.</p>\n<h3 dir=\"auto\">Option 1</h3>\n<p dir=\"auto\">The first option is to create a fork of <code class=\"notranslate\">whatwg/fetch</code> here in wintercg. We will utilize aspects of the <a href=\"https://tabatkins.github.io/bikeshed/\" rel=\"nofollow\">Bikeshed</a> language (which is what <code class=\"notranslate\">whatwg/fetch</code> is written in) to omit sections and include notes/extensions for aspects that we want to modify.</p>\n<p dir=\"auto\">We will be responsible for rebasing our modifications every time Fetch lands a change to the specification. This could be partially automated where we create a bot that watches the <code class=\"notranslate\">whatwg/fetch</code> repo, and anytime new commit(s) are merged to <code class=\"notranslate\">main</code>, it would open a branch and attempts to do the necessary git operations. Of course, if there are merge conflicts they would need to be settled by a contributor here in WinterCG.</p>\n<p dir=\"auto\">This will ensure our specification is always up to date with the latest whatwg version.</p>\n<p dir=\"auto\">This option has a long-term maintenance cost where members of WinterCG would be responsible for managing the rebasing overtime. As stated, it could be automated, but it wouldn't be a perfect solution as whenever conflicts arise someone would have to spend time fixing them.</p>\n<h3 dir=\"auto\">Option 2</h3>\n<p dir=\"auto\">The second option is to start with essentially an empty specification that states something along the lines of: \"Unless otherwise specified in this document, WinterCG Fetch is compatible with the latest edition of WHATWG Fetch specification\". Then, overtime as we agree on modifications to <code class=\"notranslate\">whatwg/fetch</code>, we will create new sections within our document that states the necessary changes. For example, lets pretend we agree to get rid of the entire concept of \"Forbidden Headers\". Our specification may include a section such as:</p>\n<blockquote>\n<p dir=\"auto\">Please note this is purely for demonstration purposes. The WinterCG has made no decisions regarding modifications to the Whatwg Fetch API and the content in the following example is purely hypothetical. Do not use this issue thread to discuss the nuance of the example.</p>\n</blockquote>\n<div class=\"snippet-clipboard-content notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"### Headers\n\n#### Modification of Forbidden Headers List\n\nSection [2.2.2 Headers #forbidden-header-name](https://fetch.spec.whatwg.org/#forbidden-header-name) of the whatwg/fetch specification states a list of header names that are considered &quot;forbidden&quot;. During runtime execution of the Fetch API, usage of a forbidden header results in an early return such as in the [Concept Headers append](https://fetch.spec.whatwg.org/#concept-headers-append) section.\n\nWinterCG Fetch deviates from this section by stating that there are **no** forbidden headers. A WinterCG Fetch API will not return early if it encounters one of these headers.\"><pre class=\"notranslate\"><code class=\"notranslate\">### Headers\n\n#### Modification of Forbidden Headers List\n\nSection [2.2.2 Headers #forbidden-header-name](https://fetch.spec.whatwg.org/#forbidden-header-name) of the whatwg/fetch specification states a list of header names that are considered \"forbidden\". During runtime execution of the Fetch API, usage of a forbidden header results in an early return such as in the [Concept Headers append](https://fetch.spec.whatwg.org/#concept-headers-append) section.\n\nWinterCG Fetch deviates from this section by stating that there are **no** forbidden headers. A WinterCG Fetch API will not return early if it encounters one of these headers.\n</code></pre></div>\n<p dir=\"auto\">This option has less maintenance burden as it could essentially stagnate while remaining \"up to date\". With the catch all statement stating that essentially WinterCG Fetch <strong>is</strong> WHATWG Fetch unless otherwise noted. The WHATWG Fetch could land changes and unless we need to deviate from those changes, we don't have to modify our specification.</p>\n<p dir=\"auto\">Unfortunately, this also means that if we are not on top of changes to WHATWG Fetch, we could incorrectly be supporting something they add that we want to deviate from. Arguably, implementations don't generally move as quickly as standards. And so even if there is a bit of a lag between us coming to decision on a hypothetical change to WHATWG Fetch, many implementers would already be apart of the conversation and it wouldn't have much impact.</p>\n<hr>\n<p dir=\"auto\">With these two options, please react to this post with which one you prefer more to give us a sense of what folks are preferring. We will also be discussing this at upcoming wintercg calls. When we come to a majority decision I will create the initial proposal draft. In the mean time, we can being making API decisions for WinterCG Fetch - capture the result in issues, and when we eventually get our proposal created, I can add those decisions to the initial draft. Also please feel free to use this issue to discuss details of either option too.</p>\n<p dir=\"auto\">Thank you!</p>\n<p dir=\"auto\">Option 1 - react with: <g-emoji class=\"g-emoji\" alias=\"smile\" fallback-src=\"https://github.githubassets.com/images/icons/emoji/unicode/1f604.png\">😄</g-emoji></p>\n<p dir=\"auto\">Option 2 - react with: <g-emoji class=\"g-emoji\" alias=\"rocket\" fallback-src=\"https://github.githubassets.com/images/icons/emoji/unicode/1f680.png\">🚀</g-emoji></p>",
            "url": "https://github.com/wintercg/fetch/issues/12",
            "title": "Specification outline",
            "date_modified": "2023-01-19T17:40:58.000Z",
            "date_published": "2022-10-19T21:40:11.000Z",
            "author": {
                "name": "Ethan-Arrowood",
                "url": "https://github.com/Ethan-Arrowood"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/241506?u=5c10f2bbf617c297b2ceb8d0e827906007a7d5a7&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><p dir=\"auto\">A lot of times I encounter the need to single a specific runtime out. For instance, all wintercg runtimes meet my criteria except <code class=\"notranslate\">node</code>.</p>\n<p dir=\"auto\">What I'm looking for is key setup which allows me to put specific runtimes infront of a wintercg catchall.</p>",
            "url": "https://github.com/wintercg/runtime-keys/issues/1",
            "title": "wintercg-specific fallback",
            "date_modified": "2023-05-05T20:07:31.000Z",
            "date_published": "2022-10-05T06:06:05.000Z",
            "author": {
                "name": "panva",
                "url": "https://github.com/panva"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/2842176?v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><p dir=\"auto\">For exceptions from <code class=\"notranslate\">Promise</code>, we can simply use <code class=\"notranslate\">unhandledrejection</code>. But how about exceptions that not come from <code class=\"notranslate\">Promise</code>? Is there any way to specify the behavior?</p>",
            "url": "https://github.com/wintercg/proposal-common-minimum-api/issues/29",
            "title": "How to deal with something like `UncaughtException`?",
            "date_modified": "2022-09-18T19:44:16.000Z",
            "date_published": "2022-09-14T06:54:55.000Z",
            "author": {
                "name": "XadillaX",
                "url": "https://github.com/XadillaX"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/439929?u=88483145a53c3d594ab68146c1a8bdecc3bcd1d3&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><p dir=\"auto\">Within Workers we have been having a discussion about how to communicate to users via Errors that the conditions leading to an error are temporary and that the user should retry their operation. The how and when to retry is not important here.</p>\n<p dir=\"auto\">For example, a <code class=\"notranslate\">fetch()</code> promise can fail for many reasons. The network path could temporarily be down, the URL could be blocked, the header could be malformated, etc. We want to be able to clearly indicate that the user can/should retry their operation <em>without</em> requiring that the user resort to parsing the error message.</p>\n<p dir=\"auto\">We have several possible paths forward, all of which have the same fundamental problem. We'd like to get consensus on which approach folks would find the most agreeable.</p>\n<h2 dir=\"auto\">Option 1: New error types</h2>\n<div class=\"highlight highlight-source-js notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"const err = new Error('an error occurred');\nObject.defineProperty(err, 'name', { value: 'RetriableError' });\"><pre class=\"notranslate\"><span class=\"pl-k\">const</span> <span class=\"pl-s1\">err</span> <span class=\"pl-c1\">=</span> <span class=\"pl-k\">new</span> <span class=\"pl-v\">Error</span><span class=\"pl-kos\">(</span><span class=\"pl-s\">'an error occurred'</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-v\">Object</span><span class=\"pl-kos\">.</span><span class=\"pl-en\">defineProperty</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">err</span><span class=\"pl-kos\">,</span> <span class=\"pl-s\">'name'</span><span class=\"pl-kos\">,</span> <span class=\"pl-kos\">{</span> <span class=\"pl-c1\">value</span>: <span class=\"pl-s\">'RetriableError'</span> <span class=\"pl-kos\">}</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">;</span></pre></div>\n<h2 dir=\"auto\">Option 2: Non-standard own properties on <code class=\"notranslate\">Error</code></h2>\n<div class=\"highlight highlight-source-js notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"const err = new Error('an error occurred');\nerr.retriable = true;\"><pre class=\"notranslate\"><span class=\"pl-k\">const</span> <span class=\"pl-s1\">err</span> <span class=\"pl-c1\">=</span> <span class=\"pl-k\">new</span> <span class=\"pl-v\">Error</span><span class=\"pl-kos\">(</span><span class=\"pl-s\">'an error occurred'</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-s1\">err</span><span class=\"pl-kos\">.</span><span class=\"pl-c1\">retriable</span> <span class=\"pl-c1\">=</span> <span class=\"pl-c1\">true</span><span class=\"pl-kos\">;</span></pre></div>\n<h2 dir=\"auto\">Option 3: Using <code class=\"notranslate\">cause</code></h2>\n<div class=\"highlight highlight-source-js notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"const err = new Error('an error occured', { cause: { retriable: true } })\"><pre class=\"notranslate\"><span class=\"pl-k\">const</span> <span class=\"pl-s1\">err</span> <span class=\"pl-c1\">=</span> <span class=\"pl-k\">new</span> <span class=\"pl-v\">Error</span><span class=\"pl-kos\">(</span><span class=\"pl-s\">'an error occured'</span><span class=\"pl-kos\">,</span> <span class=\"pl-kos\">{</span> <span class=\"pl-c1\">cause</span>: <span class=\"pl-kos\">{</span> <span class=\"pl-c1\">retriable</span>: <span class=\"pl-c1\">true</span> <span class=\"pl-kos\">}</span> <span class=\"pl-kos\">}</span><span class=\"pl-kos\">)</span></pre></div>\n<h2 dir=\"auto\">Option 4: Using <code class=\"notranslate\">AggregateError</code></h2>\n<div class=\"highlight highlight-source-js notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"// The first object is always an error but the additional things communicate\n// the additional structured information we want.\nconst err = new AggregateError([\n  new Error('an error occurred'),\n  { retriable: true }\n])\"><pre class=\"notranslate\"><span class=\"pl-c\">// The first object is always an error but the additional things communicate</span>\n<span class=\"pl-c\">// the additional structured information we want.</span>\n<span class=\"pl-k\">const</span> <span class=\"pl-s1\">err</span> <span class=\"pl-c1\">=</span> <span class=\"pl-k\">new</span> <span class=\"pl-v\">AggregateError</span><span class=\"pl-kos\">(</span><span class=\"pl-kos\">[</span>\n  <span class=\"pl-k\">new</span> <span class=\"pl-v\">Error</span><span class=\"pl-kos\">(</span><span class=\"pl-s\">'an error occurred'</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">,</span>\n  <span class=\"pl-kos\">{</span> <span class=\"pl-c1\">retriable</span>: <span class=\"pl-c1\">true</span> <span class=\"pl-kos\">}</span>\n<span class=\"pl-kos\">]</span><span class=\"pl-kos\">)</span></pre></div>\n<h2 dir=\"auto\">Option 5: ??</h2>\n<p dir=\"auto\">Other ideas?</p>\n<h2 dir=\"auto\">Current Thinking</h2>\n<p dir=\"auto\">My current thinking here is to prefer Option 3, using the <code class=\"notranslate\">cause</code> property.</p>\n<p dir=\"auto\">Specifically, pulling out to a logical level: The purpose of the <code class=\"notranslate\">cause</code> is to communicate the reason for this error. That reason might be that another <code class=\"notranslate\">Error</code> was thrown, or it might be that some other condition occurred. For instance, the network was down, or there was an internal error, etc. So let's differentiate between <code class=\"notranslate\">Error</code> and <code class=\"notranslate\">Condition</code>.</p>\n<p dir=\"auto\">If I have a transient condition and want to communicate that the user should retry their operation, then I could logically do something like:</p>\n<div class=\"highlight highlight-source-js notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"cont condition = {\n  // The condition is temporary....\n  transient: true,\n  // The operation is retriable...\n  retriable: true,\n};\nconst err = new Error('oops that failed', { cause: condition });\"><pre class=\"notranslate\"><span class=\"pl-s1\">cont</span> <span class=\"pl-s1\">condition</span> <span class=\"pl-c1\">=</span> <span class=\"pl-kos\">{</span>\n  <span class=\"pl-c\">// The condition is temporary....</span>\n  <span class=\"pl-c1\">transient</span>: <span class=\"pl-c1\">true</span><span class=\"pl-kos\">,</span>\n  <span class=\"pl-c\">// The operation is retriable...</span>\n  <span class=\"pl-c1\">retriable</span>: <span class=\"pl-c1\">true</span><span class=\"pl-kos\">,</span>\n<span class=\"pl-kos\">}</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-k\">const</span> <span class=\"pl-s1\">err</span> <span class=\"pl-c1\">=</span> <span class=\"pl-k\">new</span> <span class=\"pl-v\">Error</span><span class=\"pl-kos\">(</span><span class=\"pl-s\">'oops that failed'</span><span class=\"pl-kos\">,</span> <span class=\"pl-kos\">{</span> <span class=\"pl-c1\">cause</span>: <span class=\"pl-s1\">condition</span> <span class=\"pl-kos\">}</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">;</span></pre></div>\n<p dir=\"auto\">The challenge with this, of course, is interoperability. If workers chooses to use <code class=\"notranslate\">cause</code> in this way but other <code class=\"notranslate\">fetch()</code> implementations choose to use <code class=\"notranslate\">cause</code> in other ways then we can run into interop issues. To be clear, <em>ALL</em> of the options suffer from this exact problem.</p>\n<h2 dir=\"auto\">Proposal</h2>\n<p dir=\"auto\">The proposal I would like to make is to define a new <code class=\"notranslate\">ErrorCondition</code> interface specifically for use with <code class=\"notranslate\">cause</code></p>\n<p dir=\"auto\">Essentially (treat this as a discussion example to express intent... the <em>actual</em> proposal can be refined):</p>\n<div class=\"snippet-clipboard-content notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"dictionary ErrorConditionInit {\n  boolean transient = false;\n  boolean retriable = false;\n  DOMString name = &quot;&quot;;\n};\n\ninterface ErrorCondition {\n  constructor(optional DOMString message = &quot;&quot;, optional ConditionInit init = {});\n  readonly attribute boolean transient;\n  readonly attribute boolean retriable;\n  readonly attribute DOMString name;\n  readonly attribute DOMString message;\n}\"><pre class=\"notranslate\"><code class=\"notranslate\">dictionary ErrorConditionInit {\n  boolean transient = false;\n  boolean retriable = false;\n  DOMString name = \"\";\n};\n\ninterface ErrorCondition {\n  constructor(optional DOMString message = \"\", optional ConditionInit init = {});\n  readonly attribute boolean transient;\n  readonly attribute boolean retriable;\n  readonly attribute DOMString name;\n  readonly attribute DOMString message;\n}\n</code></pre></div>\n<p dir=\"auto\">Note that this interface <em>intentionally</em> mimics <code class=\"notranslate\">DOMException</code> with the inclusion of a <code class=\"notranslate\">name</code> and <code class=\"notranslate\">message</code> accessors.</p>\n<p dir=\"auto\">Example use (assuming the proposal to add <code class=\"notranslate\">cause</code> to <code class=\"notranslate\">DOMException</code> goes through):</p>\n<div class=\"snippet-clipboard-content notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"const err = new DOMException('The operation failed', {\n  name: 'NETWORK_ERR',\n  cause: new ErrorCondition('The network path is down', {\n    transient: true,\n    retriable: true,\n  })\n});\n\nconsole.log(err.cause.transient);  // true\nconsole.log(err.cause.retriable); // true\"><pre class=\"notranslate\"><code class=\"notranslate\">const err = new DOMException('The operation failed', {\n  name: 'NETWORK_ERR',\n  cause: new ErrorCondition('The network path is down', {\n    transient: true,\n    retriable: true,\n  })\n});\n\nconsole.log(err.cause.transient);  // true\nconsole.log(err.cause.retriable); // true\n</code></pre></div>\n<p dir=\"auto\">To be clear, I don't really have strong opinions on exactly how we solve this use case. My only requirement is that we have a mechanism for reliably communicating transient/retriable conditions that is interoperable across runtimes.</p>\n<h2 dir=\"auto\">Some questions</h2>\n<ol dir=\"auto\">\n<li>How are retriable errors like this handled elsewhere on the web?</li>\n</ol>",
            "url": "https://github.com/wintercg/fetch/issues/11",
            "title": "Error conditions, retry, and Error.cause",
            "date_modified": "2023-01-19T17:40:59.000Z",
            "date_published": "2022-09-08T18:15:41.000Z",
            "author": {
                "name": "jasnell",
                "url": "https://github.com/jasnell"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/1150298?v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><p dir=\"auto\">Already exists in at least Cloudflare Workers, Deno and Node.js...</p>",
            "url": "https://github.com/wintercg/proposal-common-minimum-api/issues/27",
            "title": "Expected `fetch` to be in the common minimum API",
            "date_modified": "2023-05-10T10:10:36.000Z",
            "date_published": "2022-09-08T14:52:54.000Z",
            "author": {
                "name": "timfish",
                "url": "https://github.com/timfish"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/8500303?u=50e30202b089c2c9bd355d8f86eae6ebcda67ffd&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><p dir=\"auto\"><a href=\"https://w3c.github.io/resource-timing/\" rel=\"nofollow\">Resource Timing</a> defines the interface <code class=\"notranslate\">PerformanceResourceTiming</code>, which represents an timing measurement entry of <a href=\"https://fetch.spec.whatwg.org/#concept-fetch\" rel=\"nofollow\">fetched</a> <a href=\"https://fetch.spec.whatwg.org/#http-scheme\" rel=\"nofollow\">http(s)</a> resources.</p>\n<p dir=\"auto\">Implementation Status:</p>\n<table role=\"table\">\n<thead>\n<tr>\n<th>Interface</th>\n<th>Node</th>\n<th>Deno</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code class=\"notranslate\">PerformanceResourceTiming</code></td>\n<td><a href=\"https://nodejs.org/dist/latest-v18.x/docs/api/perf_hooks.html#class-performanceresourcetiming\" rel=\"nofollow\"><g-emoji class=\"g-emoji\" alias=\"white_check_mark\" fallback-src=\"https://github.githubassets.com/images/icons/emoji/unicode/2705.png\">✅</g-emoji></a></td>\n<td>❓</td>\n</tr>\n<tr>\n<td><code class=\"notranslate\">Performance.clearResourceTiming</code></td>\n<td><g-emoji class=\"g-emoji\" alias=\"white_check_mark\" fallback-src=\"https://github.githubassets.com/images/icons/emoji/unicode/2705.png\">✅</g-emoji></td>\n<td><g-emoji class=\"g-emoji\" alias=\"question\" fallback-src=\"https://github.githubassets.com/images/icons/emoji/unicode/2753.png\">❓</g-emoji></td>\n</tr>\n<tr>\n<td><code class=\"notranslate\">Performance.setResourceTimingBufferSize</code></td>\n<td><g-emoji class=\"g-emoji\" alias=\"white_check_mark\" fallback-src=\"https://github.githubassets.com/images/icons/emoji/unicode/2705.png\">✅</g-emoji></td>\n<td><g-emoji class=\"g-emoji\" alias=\"question\" fallback-src=\"https://github.githubassets.com/images/icons/emoji/unicode/2753.png\">❓</g-emoji></td>\n</tr>\n</tbody>\n</table>",
            "url": "https://github.com/wintercg/performance/issues/5",
            "title": "Resource Timing",
            "date_modified": "2022-08-30T08:16:21.000Z",
            "date_published": "2022-08-25T16:29:59.000Z",
            "author": {
                "name": "legendecas",
                "url": "https://github.com/legendecas"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/8500303?u=50e30202b089c2c9bd355d8f86eae6ebcda67ffd&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><ul dir=\"auto\">\n<li>Fix auto-links to WebPerf documents.</li>\n<li>Fix auto-links to the terms defined in <a href=\"https://common-min-api.proposal.wintercg.org/\" rel=\"nofollow\">https://common-min-api.proposal.wintercg.org/</a>.</li>\n</ul>",
            "url": "https://github.com/wintercg/performance/issues/4",
            "title": "Editorial: autolinks to terms defined in other specs",
            "date_modified": "2022-08-11T17:29:55.000Z",
            "date_published": "2022-08-11T17:29:55.000Z",
            "author": {
                "name": "legendecas",
                "url": "https://github.com/legendecas"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/3468483?u=daf25d236ad2cc227470fa0da2d5bdf3dbb7feed&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><p dir=\"auto\">It's hard to use the wasm version of Canvas implementation on edge; because the size of the current implementation for canvas in npm is huge and slow.</p>\n<p dir=\"auto\">It would be nice if the runtime provide the native <code class=\"notranslate\">OffscreenCanvas</code> API.</p>",
            "url": "https://github.com/wintercg/proposal-common-minimum-api/issues/26",
            "title": "OffscreenCanvas",
            "date_modified": "2023-01-10T01:24:40.000Z",
            "date_published": "2022-08-04T13:47:00.000Z",
            "author": {
                "name": "Brooooooklyn",
                "url": "https://github.com/Brooooooklyn"
            }
        }
    ]
}