{
    "version": "https://jsonfeed.org/version/1",
    "title": "github/roadmap Issues",
    "home_page_url": "https://azu.github.io/github-search-rss/github-roadmap.json",
    "feed_url": "https://azu.github.io/github-search-rss/github-roadmap.json",
    "description": "github/roadmap Issues on GitHub",
    "items": [
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/67656570?u=71034939d8d88be6d9b9068038dfdc8158fa69c0&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><h3 dir=\"auto\">Summary</h3>\n<p dir=\"auto\">Secret scanning currently scans commit content for all supported patterns. We're extending the breadth of our scans for Advanced Security customers to cover pull requests and discussions, plus all related comments.</p>\n<h3 dir=\"auto\">Intended Outcome</h3>\n<p dir=\"auto\">While most secret leaks occur in code content, a portion do also leak in other content types, including pull requests and discussions. We're expanding the scope of our scans for more exhaustive coverage to better protect our users across GitHub.</p>\n<h3 dir=\"auto\">How will it work?</h3>\n<p dir=\"auto\">Advanced Security customers will be able to view detections found in private and public repositories for these content types within the secret scanning UI and REST API.</p>",
            "url": "https://github.com/github/roadmap/issues/735",
            "title": "Secret scanning detects secrets leaked in pull requests and discussions",
            "date_modified": "2023-04-10T20:34:32.000Z",
            "date_published": "2023-04-10T20:32:40.000Z",
            "author": {
                "name": "github-product-roadmap",
                "url": "https://github.com/github-product-roadmap"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/67656570?u=71034939d8d88be6d9b9068038dfdc8158fa69c0&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><h3 dir=\"auto\">Summary</h3>\n<p dir=\"auto\">Secret scanning scans high-confidence tokens (those with a low false positive rate) and blocks a remote push if secrets are detected, thereby flagging secrets before exposure. Last quarter, w<a href=\"https://github.com/github/roadmap/issues/496\" data-hovercard-type=\"issue\" data-hovercard-url=\"/github/roadmap/issues/496/hovercard\">e expanded push protection to custom patterns defined at the repository and organization levels</a>. Now, we're also supporting push protection for any custom pattern defined at the enterprise level.</p>\n<h3 dir=\"auto\">Intended Outcome</h3>\n<p dir=\"auto\">Advanced Security customers can enable push protection for our set of highly-identifiable, built-in patterns. While these patterns provide preventative support for customers, organizations want to also protect their developers from leaking their own, specific patterns. Push protection support for enterprise level custom patterns will fill this coverage need (repository and organization levels already supported).</p>\n<h3 dir=\"auto\">How will it work?</h3>\n<p dir=\"auto\">Advanced Security customers will be able to enable push protection for their enterprise-level custom patterns from the UI.</p>",
            "url": "https://github.com/github/roadmap/issues/734",
            "title": "Secret scanning: Support push protection for enterprise level custom patterns",
            "date_modified": "2023-04-10T20:34:31.000Z",
            "date_published": "2023-04-10T20:32:37.000Z",
            "author": {
                "name": "github-product-roadmap",
                "url": "https://github.com/github-product-roadmap"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/67656570?u=71034939d8d88be6d9b9068038dfdc8158fa69c0&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><h3 dir=\"auto\">Summary</h3>\n<p dir=\"auto\">The UI for a secret scanning alert will surface metadata about any leaked GitHub token.</p>\n<h3 dir=\"auto\">Intended Outcome</h3>\n<p dir=\"auto\">Metadata on tokens can help users decide whether or not they should revoke a detected token or when. Certain metadata, like token owner, can also aid quicker remediation action.</p>\n<h3 dir=\"auto\">How will it work?</h3>\n<p dir=\"auto\">When a user navigates to their alert for a detected GitHub token, they will see metadata about the token in that alert view.</p>",
            "url": "https://github.com/github/roadmap/issues/733",
            "title": "Secret scanning: Surface GitHub token metadata in alert view",
            "date_modified": "2023-04-10T20:34:31.000Z",
            "date_published": "2023-04-10T20:32:34.000Z",
            "author": {
                "name": "github-product-roadmap",
                "url": "https://github.com/github-product-roadmap"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/67656570?u=71034939d8d88be6d9b9068038dfdc8158fa69c0&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><h3 dir=\"auto\">Summary</h3>\n<p dir=\"auto\">Code scanning will allow users to filter alerts by file path, in order for individual developers and security teams to be able to focus on the part of the code they know (and care about) most.</p>\n<h3 dir=\"auto\">Intended Outcome</h3>\n<p dir=\"auto\">The code scanning file path filter will help users to sort and manage alerts efficiently by focusing on a specific part of the code related to the project. It will also enable users who work on big repositories (like monorepos) to review all alerts specific to the part of the code they are responsible for.</p>\n<h3 dir=\"auto\">How will it work?</h3>\n<p dir=\"auto\">Users will be able to filter alerts by file path on the code scanning page on the 'Security' tab at the repository level. Filtering will work based on file path and extension, which means it will work for all code scanning tools, including the CodeQL engine.</p>",
            "url": "https://github.com/github/roadmap/issues/732",
            "title": "Code scanning: Filter alerts by file path",
            "date_modified": "2023-04-10T20:34:30.000Z",
            "date_published": "2023-04-10T20:32:32.000Z",
            "author": {
                "name": "github-product-roadmap",
                "url": "https://github.com/github-product-roadmap"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/67656570?u=71034939d8d88be6d9b9068038dfdc8158fa69c0&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><h3 dir=\"auto\">Summary</h3>\n<p dir=\"auto\">Today on GHES, Dependabot alerts can only be enabled or disabled at the enterprise-level.</p>\n<p dir=\"auto\">This release adds support to GHES 3.9 and later versions, so that enterprise customers can:</p>\n<ul dir=\"auto\">\n<li>\"Enable\" or \"disable\" for a single repository</li>\n<li>\"Enable all\" or \"disable all\" for a single organization</li>\n<li>\"Enable all\" or \"disable all\" for the enterprise</li>\n<li>\"Enabling incoming\" repositories at the organization or enterprise level.</li>\n<li>Still opt-in to Dependabot alerts (approving outbound calls) via GitHub Connect</li>\n</ul>\n<h3 dir=\"auto\">Intended Outcome</h3>\n<p dir=\"auto\">You can now enable Dependabot alerts at a more granular level.</p>",
            "url": "https://github.com/github/roadmap/issues/731",
            "title": "GHES 3.9: Dependabot alerts can be enabled at the repository, organization, and enterprise levels",
            "date_modified": "2023-04-10T20:34:29.000Z",
            "date_published": "2023-04-10T20:32:28.000Z",
            "author": {
                "name": "github-product-roadmap",
                "url": "https://github.com/github-product-roadmap"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/67656570?u=71034939d8d88be6d9b9068038dfdc8158fa69c0&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><h3 dir=\"auto\">Summary</h3>\n<p dir=\"auto\">In order to provide users with a consistent sorting experience across all layouts in Projects, the ability to sort board views by field values will be supported. This will allow users to further customize and tailor their views by reordering their items in a way that is most helpful to them.</p>\n<h3 dir=\"auto\">Intended Outcome</h3>\n<p dir=\"auto\">Supporting the ability to sort work items on a project will allow users to automatically order their items, removing the need to manually reorder work items in board columns and lessening confusion about default sorting order.</p>\n<h3 dir=\"auto\">How will it work?</h3>\n<p dir=\"auto\">Users will be able to specify the field they would like to sort their project items by from the view configuration menu, alongside other project customizations.</p>",
            "url": "https://github.com/github/roadmap/issues/730",
            "title": "Projects: Sorting on board layout",
            "date_modified": "2023-04-10T20:34:29.000Z",
            "date_published": "2023-04-10T20:32:25.000Z",
            "author": {
                "name": "github-product-roadmap",
                "url": "https://github.com/github-product-roadmap"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/67656570?u=71034939d8d88be6d9b9068038dfdc8158fa69c0&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><h3 dir=\"auto\">Summary</h3>\n<p dir=\"auto\">Users will be able to create a Roadmap view to visualize issues and their relationships across a timespan and track a body of work towards a deadline.</p>\n<h3 dir=\"auto\">Intended Outcome</h3>\n<p dir=\"auto\">Providing users with a Roadmap layout will allow them to plan and track their work over time and towards a deadline. It gives users a visual component to understand the timing and progress of their initiatives and communicate with stakeholders.</p>\n<p dir=\"auto\">In addition to the table and board layout types, a roadmap layout will provide users with a visual at-a-glance view of their work items.</p>\n<h3 dir=\"auto\">How will it work?</h3>\n<p dir=\"auto\">When creating a new project or project view, a user will be able to select a Roadmap layout alongside the table and board layouts. This will populate their work items along a time-based axis, driven by date or iteration fields within the project. They can customize their roadmap view by grouping, sorting, and filtering their work items, as well as selecting a zoom level depending on the granularity they would like to see.</p>\n<p dir=\"auto\">More details can be found in the <a href=\"https://docs.github.com/en/issues/planning-and-tracking-with-projects/customizing-views-in-your-project/customizing-the-roadmap-layout\">documentation</a>.</p>",
            "url": "https://github.com/github/roadmap/issues/729",
            "title": "Projects: Roadmap Layout [GA] ",
            "date_modified": "2023-04-10T20:34:28.000Z",
            "date_published": "2023-04-10T20:32:22.000Z",
            "author": {
                "name": "github-product-roadmap",
                "url": "https://github.com/github-product-roadmap"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/67656570?u=71034939d8d88be6d9b9068038dfdc8158fa69c0&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><h3 dir=\"auto\">Summary</h3>\n<p dir=\"auto\">Manual review of <a href=\"https://github.blog/2022-10-18-introducing-fine-grained-personal-access-tokens-for-github/\" rel=\"nofollow\">fine-grained PATs</a> that have access to an organization doesn't scale well, so we're adding APIs to manage these approvals. These APIs will allow a GitHub app to view pending token requests, accept or deny them, and also review and revoke existing fine-grained PATs for an organization.</p>\n<h3 dir=\"auto\">Intended Outcome</h3>\n<p dir=\"auto\">Organization administrators have the strongest understanding of their security posture and requirements around the use of PATs.  With access to the full lifecycle of fine-grained PATs, administrators can create exactly the rules-based automation they need, with integration into other sources of data (such as group membership, project lifetimes, and directory data).</p>\n<h3 dir=\"auto\">How will it work?</h3>\n<p dir=\"auto\">A GitHub app with a new <code class=\"notranslate\">tokens:write</code> permission will be able to register for a webhook event, signalling that a new fine-grained PAT has been created or approved. The app can then review that token and use its business logic to decide if the token should be approved or not.</p>\n<p dir=\"auto\">Apps will also be able to review existing fine-grained PATs, in case that business logic changes and all previous tokens need to be re-evaluated or audited. Using this new API, apps will be able to revoke those existing tokens, attaching a message to the user explaining why this occurred.</p>",
            "url": "https://github.com/github/roadmap/issues/728",
            "title": "Organization APIs to manage fine-grained PATs",
            "date_modified": "2023-04-10T20:34:28.000Z",
            "date_published": "2023-04-10T20:32:19.000Z",
            "author": {
                "name": "github-product-roadmap",
                "url": "https://github.com/github-product-roadmap"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/67656570?u=71034939d8d88be6d9b9068038dfdc8158fa69c0&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><h3 dir=\"auto\">Summary</h3>\n<p dir=\"auto\">Developers that use temporary private forks to privately fix their draft security advisories cannot currently take advantage of their test automation in GitHub Actions. We will add support for GitHub Actions in temporary private forks for draft security advisories so developers can run test automation.</p>\n<h3 dir=\"auto\">Intended Outcome</h3>\n<p dir=\"auto\">Private forks are currently used to fix security issues behind closed doors.</p>\n<p dir=\"auto\">However, if you can't test your code before merging the fix, you could be introducing new bugs as an accidental byproduct. This leads to project maintainers releasing a fix, realizing it has bugs, and then releasing a fix for the fix.</p>\n<p dir=\"auto\">Allowing GitHub Actions to run on private forks will help developers resolve security vulnerabilities faster and safer.</p>\n<h3 dir=\"auto\">How will it work?</h3>\n<p dir=\"auto\">Developers who open a temporary private fork to fix a security issue will be able to use most GitHub Actions workflows in that private fork as normal. However, because these repositories often have untrusted external collaborators, workflows will be unable to use organization secrets.</p>",
            "url": "https://github.com/github/roadmap/issues/727",
            "title": "GitHub Security Advisory private forks support Actions",
            "date_modified": "2023-04-10T20:34:27.000Z",
            "date_published": "2023-04-10T20:32:16.000Z",
            "author": {
                "name": "github-product-roadmap",
                "url": "https://github.com/github-product-roadmap"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/67656570?u=71034939d8d88be6d9b9068038dfdc8158fa69c0&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><h3 dir=\"auto\">Summary</h3>\n<p dir=\"auto\">Developers can export their dependency graph as a Software Bill of Materials (SBOM), a formal, machine-readable inventory of their dependencies and associated information (versions, licenses, etc).</p>\n<h3 dir=\"auto\">Intended Outcome</h3>\n<p dir=\"auto\">SBOMs are required for companies that provide software to the US federal government per <a href=\"https://www.gsa.gov/technology/technology-products-services/it-security/executive-order-14028-improving-the-nations-cybersecurity\" rel=\"nofollow\">Executive Order 14028</a>. SBOMs also make auditing easier and helps companies comply with their organisation's regulatory and legal requirements.</p>\n<h3 dir=\"auto\">How will it work?</h3>\n<p dir=\"auto\">Developers will be able to visit their repository's dependency graph page and export the current state of their dependency graph as a JSON file using an industry standard format like <a href=\"https://spdx.dev/\" rel=\"nofollow\">SPDX</a>. Developers will also be able to retrieve the SBOM from their repository using an API.</p>",
            "url": "https://github.com/github/roadmap/issues/726",
            "title": "Dependency graph produces SBOMs",
            "date_modified": "2023-04-10T20:34:26.000Z",
            "date_published": "2023-04-10T20:32:13.000Z",
            "author": {
                "name": "github-product-roadmap",
                "url": "https://github.com/github-product-roadmap"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/67656570?u=71034939d8d88be6d9b9068038dfdc8158fa69c0&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><h3 dir=\"auto\">Summary</h3>\n<p dir=\"auto\">The dependency graph will add support for pnpm manifest files. This will allow developers to view their pnpm dependencies in the dependency graph and receive Dependabot alerts for any known vulnerabilities.</p>\n<h3 dir=\"auto\">Intended Outcome</h3>\n<p dir=\"auto\">Adding pnpm support gives developers building pnpm projects the supply chain coverage needed to identify and remediate vulnerabilities within GitHub.</p>\n<h3 dir=\"auto\">How will it work?</h3>\n<p dir=\"auto\">Dependency graph will parse and ingest pnpm <code class=\"notranslate\">package.json</code> and <code class=\"notranslate\">pnpm-lock.yaml</code> files automatically, and the included dependencies will appear in the dependency graph. Dependabot alerts will work for pnpm dependencies.</p>",
            "url": "https://github.com/github/roadmap/issues/725",
            "title": "Dependabot alerts and dependency graph support for pnpm ",
            "date_modified": "2023-04-10T20:34:26.000Z",
            "date_published": "2023-04-10T20:32:10.000Z",
            "author": {
                "name": "github-product-roadmap",
                "url": "https://github.com/github-product-roadmap"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/67656570?u=71034939d8d88be6d9b9068038dfdc8158fa69c0&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><h3 dir=\"auto\">Summary</h3>\n<p dir=\"auto\">Today it's hard to know where a npm package came from - what's the source code and how was the package built? Maintainers can optionally specify this information, but it's easy for malicious folks to spoof.</p>\n<p dir=\"auto\">Provenance creates verifiable links back to the source code and build instructions for public npm packages. This gives users of these packages a way to verify the package does what it says. This is a new security capability for package managers, in collaboration with the Sigstore open source project, and it is debuting on npm.</p>\n<h3 dir=\"auto\">Intended Outcome</h3>\n<p dir=\"auto\">To increase confidence of supply chain security in the npm ecosystem.</p>\n<h3 dir=\"auto\">How will it work?</h3>\n<p dir=\"auto\">Provenance starts when you build your npm package in a cloud CI/CD provider, like GitHub Actions.</p>\n<p dir=\"auto\">While the build is running, we request an OIDC token from GitHub Actions, which is a signed JWT that includes information about the organization, repository, commit, branch, workflow... all the metadata associated with the build. That signed JWT is sent to Sigstore's public servers, where they verify it came from GitHub, issue a signing certificate to the build with the build metadata stored in X.509 extension OIDs, and record the information on a public ledger.</p>\n<p dir=\"auto\">When the build publishes to npm, it uses a special flag (<code class=\"notranslate\">npm publish --provenance</code>) that includes the Sigstore signing certificate along with the built package. The npm registry records this information and displays it to users via the website and API.</p>",
            "url": "https://github.com/github/roadmap/issues/724",
            "title": "npm package provenance - GA",
            "date_modified": "2023-04-10T20:34:25.000Z",
            "date_published": "2023-04-10T20:32:07.000Z",
            "author": {
                "name": "github-product-roadmap",
                "url": "https://github.com/github-product-roadmap"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/67656570?u=71034939d8d88be6d9b9068038dfdc8158fa69c0&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><h3 dir=\"auto\">Summary</h3>\n<p dir=\"auto\">For many of our security features (e.g., Dependabot alerts, secret scanning, code scanning), you can enable the feature for all repositories in an organization or for one repository at a time. We intend to provide a solution for organizations to easily filter their repositories on security overview's security coverage page and enable security features for the filtered set of  repositories all with a few clicks.</p>\n<h3 dir=\"auto\">Intended Outcome</h3>\n<p dir=\"auto\">Enabling and configuring security features on multiple repositories will make it easier to quickly roll out security features across an entire organization.</p>",
            "url": "https://github.com/github/roadmap/issues/723",
            "title": "Bulk-enable security features for multiple repositories",
            "date_modified": "2023-04-10T20:34:25.000Z",
            "date_published": "2023-04-10T20:32:04.000Z",
            "author": {
                "name": "github-product-roadmap",
                "url": "https://github.com/github-product-roadmap"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/67656570?u=71034939d8d88be6d9b9068038dfdc8158fa69c0&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><h3 dir=\"auto\">Summary</h3>\n<p dir=\"auto\">Today, organizations can see only the current status of security alerts and security feature enablement for their repositories.  It's not possible to get a historical view.  We intend to provide trends graphs at the organization level for both security feature enablement and security alerts.</p>\n<h3 dir=\"auto\">Intended Outcome</h3>\n<p dir=\"auto\">Trend graphs will enable organizations to analyze their security program's performance and gauge overall changes in their security posture.</p>\n<h3 dir=\"auto\">How will it work?</h3>\n<p dir=\"auto\">We will offer two new pages in security overview: security coverage trends and risk trends that will house trends graphs for the following security features:</p>\n<ul dir=\"auto\">\n<li>Dependabot alerts</li>\n<li>Code scanning alerts</li>\n<li>Secret scanning alerts</li>\n<li>Push protection <em>(enablement trends graph only)</em></li>\n<li>GitHub Advanced Security <em>(enablement trends graph only)</em></li>\n</ul>",
            "url": "https://github.com/github/roadmap/issues/722",
            "title": "View a trend of security feature enablement/security alerts",
            "date_modified": "2023-04-10T20:34:24.000Z",
            "date_published": "2023-04-10T20:32:01.000Z",
            "author": {
                "name": "github-product-roadmap",
                "url": "https://github.com/github-product-roadmap"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/67656570?u=71034939d8d88be6d9b9068038dfdc8158fa69c0&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><h3 dir=\"auto\">Summary</h3>\n<p dir=\"auto\">Currently developers use the <a href=\"https://docs.github.com/en/actions/deployment/targeting-different-environments/using-environments-for-deployment#environment-protection-rules\">environment protection rules</a> to require specific conditions to pass before a deployment job referencing the environment can proceed.</p>\n<p dir=\"auto\">We are now enabling repository administrators to bypass all the protection rules on a given environment (break glass) by default and force the pending jobs referencing the environment to proceed.</p>\n<h3 dir=\"auto\">Intended Outcome</h3>\n<p dir=\"auto\">Previously, deployments (jobs) gated on the protection rules defined on an environment had to wait until all the configured protection rules passed.</p>\n<p dir=\"auto\">This new feature provides the ncessary granular control for administrators to allow/disallow bypassing the protection rules on specific environments.</p>\n<h3 dir=\"auto\">How will it work?</h3>\n<p dir=\"auto\">During a workflow run executing multiple deployment Jobs referencing environments, Admins can now choose the specific environments where they would like to bypass the protection rules and force deployments.</p>\n<p dir=\"auto\">We allow admins to bypass protection rules and manually force deployments by default. Alternatively, Environments can also be configured in advance to disallow the bypass feature and enforce the protection rules for all deployments to the environment.</p>",
            "url": "https://github.com/github/roadmap/issues/721",
            "title": "Actions - Granular control for admins to bypass protection rules on an environment (break glass) - [GA] ",
            "date_modified": "2023-04-10T20:34:24.000Z",
            "date_published": "2023-04-10T20:31:58.000Z",
            "author": {
                "name": "github-product-roadmap",
                "url": "https://github.com/github-product-roadmap"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/67656570?u=71034939d8d88be6d9b9068038dfdc8158fa69c0&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><p dir=\"auto\"><strong>Summary</strong><br>\nActions will add the ability to run your workflow jobs on the latest macOS version from Apple, Ventura.<br>\n<strong>Intended Outcome</strong><br>\nRun your Actions workflow jobs on the latest iteration of Apple's macOS platform.</p>\n<p dir=\"auto\"><strong>How will it work</strong><br>\nUpdate your workflow jobs to include <code class=\"notranslate\">runs-on: macos-13</code></p>\n<div class=\"snippet-clipboard-content notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"jobs:\n  build:\n    runs-on: macos-13\n    steps:\n      - uses: actions/checkout@v2\n      - name: Build\n        run: swift build\n      - name: Run tests\n        run: swift test\"><pre class=\"notranslate\"><code class=\"notranslate\">jobs:\n  build:\n    runs-on: macos-13\n    steps:\n      - uses: actions/checkout@v2\n      - name: Build\n        run: swift build\n      - name: Run tests\n        run: swift test\n</code></pre></div>",
            "url": "https://github.com/github/roadmap/issues/720",
            "title": "Actions: macOS 13 (Ventura) on GitHub-hosted runners (Beta)",
            "date_modified": "2023-04-10T20:34:23.000Z",
            "date_published": "2023-04-10T20:27:56.000Z",
            "author": {
                "name": "github-product-roadmap",
                "url": "https://github.com/github-product-roadmap"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/67656570?u=71034939d8d88be6d9b9068038dfdc8158fa69c0&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><h3 dir=\"auto\">Summary</h3>\n<p dir=\"auto\">With this ship, the use of a new<code class=\"notranslate\">read:audit_log</code> scope will be required to provide personal access tokens (classic) and OAuth apps with the ability to read audit log events.</p>\n<h3 dir=\"auto\">Intended Outcome</h3>\n<p dir=\"auto\">Stolen and compromised credentials are the number one cause of data breaches across the industry. To mitigate the risk of compromised credentials, GitHub recommends adhering to the <a href=\"https://en.wikipedia.org/wiki/Principle_of_least_privilege\" rel=\"nofollow\">principle of least privilege</a> which promotes \"giving a user account or process only those privileges which are essential to perform its intended function.\" The new scope will enable access to the audit log endpoints, without requiring full administrative privileges.</p>\n<h3 dir=\"auto\">How will it work?</h3>\n<p dir=\"auto\">Enterprise and organizations administrators can create personal access tokens (classic) and OAuth apps without any change, but will do so with the <code class=\"notranslate\">read:audit_log</code> scope.</p>",
            "url": "https://github.com/github/roadmap/issues/719",
            "title": "Create read:audit_log scope for least privileged access to audit log API",
            "date_modified": "2023-04-10T20:29:21.000Z",
            "date_published": "2023-04-10T20:27:53.000Z",
            "author": {
                "name": "github-product-roadmap",
                "url": "https://github.com/github-product-roadmap"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/67656570?u=71034939d8d88be6d9b9068038dfdc8158fa69c0&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><h3 dir=\"auto\">Summary</h3>\n<p dir=\"auto\">CodeQL is the analysis engine that provides the vast majority of our code scanning results. Three CodeQL suites are <a href=\"https://docs.github.com/en/code-security/code-scanning/automatically-scanning-your-code-for-vulnerabilities-and-errors/configuring-code-scanning#using-queries-in-ql-packs\">available</a> at this time: <code class=\"notranslate\">code-scanning</code>, <code class=\"notranslate\">security-extended</code>, and <code class=\"notranslate\">security-and-quality</code>. We're adding another <code class=\"notranslate\">experimental</code> suite, to enable users to easily run nearly 100 additional highly experimental security queries.</p>\n<h3 dir=\"auto\">Intended Outcome</h3>\n<p dir=\"auto\">Experimental queries are queries in development, or community-contributed queries that have not (yet) been promoted to one of the existing suites. By providing an easier way to run these queries against user source code, more potential security issues could be detected.</p>\n<h3 dir=\"auto\">How will it work?</h3>\n<p dir=\"auto\">Suites for a CodeQL analysis can be <a href=\"https://docs.github.com/en/code-security/code-scanning/automatically-scanning-your-code-for-vulnerabilities-and-errors/configuring-code-scanning#running-additional-queries\">specified in the analysis workflow file</a>.</p>\n<p dir=\"auto\">Note that experimental queries can be highly unstable, are subject to change, might produce unexpected results, and could lead to analysis failure on any given codebase. It is not recommended to enable experimental queries for production use cases.</p>",
            "url": "https://github.com/github/roadmap/issues/718",
            "title": "CodeQL adds an experimental security query suite",
            "date_modified": "2023-04-10T20:29:19.000Z",
            "date_published": "2023-04-10T20:27:50.000Z",
            "author": {
                "name": "github-product-roadmap",
                "url": "https://github.com/github-product-roadmap"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/67656570?u=71034939d8d88be6d9b9068038dfdc8158fa69c0&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><h3 dir=\"auto\">Summary</h3>\n<p dir=\"auto\">The <a href=\"https://docs.github.com/en/code-security/code-scanning/automatically-scanning-your-code-for-vulnerabilities-and-errors/about-code-scanning-with-codeql\">CodeQL analysis engine</a> for <a href=\"https://docs.github.com/en/code-security/code-scanning/automatically-scanning-your-code-for-vulnerabilities-and-errors/about-code-scanning\">GitHub code scanning</a> will be able to analyze projects written with using new C# 11 language features.</p>\n<h3 dir=\"auto\">Intended Outcome</h3>\n<p dir=\"auto\">Currently, <a href=\"https://codeql.github.com/docs/codeql-overview/supported-languages-and-frameworks/\">CodeQL supports builds and standard language features up to C# 10</a>. C# 11 is due to be released before EOY 2022. Updating CodeQL support will allow customers who want to adopt C# 11 to benefit from CodeQL's comprehensive security analysis, while using C#11 latest features.</p>\n<h3 dir=\"auto\">How will it work?</h3>\n<p dir=\"auto\">If a project contains C# 11 code, or if C# has been <a href=\"https://docs.github.com/en/code-security/code-scanning/automatically-scanning-your-code-for-vulnerabilities-and-errors/configuring-code-scanning#changing-the-languages-that-are-analyzed\">configured as a language to be analyzed</a> in the <a href=\"https://docs.github.com/en/code-security/code-scanning/automatically-scanning-your-code-for-vulnerabilities-and-errors/configuring-code-scanning#about-code-scanning-configuration\">code scanning workflow</a>, CodeQL will pick up code using C# 11 language features automatically. No further configuration changes are needed. As soon as the analysis is finished, the CodeQL results will then become visible to you in the \"Security\" tab and on pull requests. C# 11 support will also be available through the <a href=\"https://codeql.github.com/docs/codeql-cli/about-the-codeql-cli/\">CodeQL CLI</a>.</p>",
            "url": "https://github.com/github/roadmap/issues/717",
            "title": "CodeQL Support for C# 11 language features",
            "date_modified": "2023-04-10T20:34:22.000Z",
            "date_published": "2023-04-10T20:27:47.000Z",
            "author": {
                "name": "github-product-roadmap",
                "url": "https://github.com/github-product-roadmap"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/67656570?u=71034939d8d88be6d9b9068038dfdc8158fa69c0&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><h3 dir=\"auto\">Summary</h3>\n<p dir=\"auto\">Secret scanning currently scans commit content for all supported patterns. We're extending the breadth of our scans for Advanced Security customers to cover pull requests and discussions, plus all related comments.</p>\n<h3 dir=\"auto\">Intended Outcome</h3>\n<p dir=\"auto\">While most secret leaks occur in code content, a portion do also leak in other content types, including pull requests and discussions. We're expanding the scope of our scans for more exhaustive coverage to better protect our users across GitHub.</p>\n<h3 dir=\"auto\">How will it work?</h3>\n<p dir=\"auto\">Advanced Security customers will be able to view detections found in private and public repositories for these content types within the secret scanning UI and REST API.</p>",
            "url": "https://github.com/github/roadmap/issues/715",
            "title": "Secret scanning detects secrets leaked in pull requests and discussions",
            "date_modified": "2023-04-10T20:34:20.000Z",
            "date_published": "2023-04-10T20:27:41.000Z",
            "author": {
                "name": "github-product-roadmap",
                "url": "https://github.com/github-product-roadmap"
            }
        }
    ]
}