{
    "version": "https://jsonfeed.org/version/1",
    "title": "github/roadmap Issues",
    "home_page_url": "https://azu.github.io/github-search-rss/github-roadmap.json",
    "feed_url": "https://azu.github.io/github-search-rss/github-roadmap.json",
    "description": "github/roadmap Issues on GitHub",
    "items": [
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/67656570?u=71034939d8d88be6d9b9068038dfdc8158fa69c0&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><h3 dir=\"auto\">Summary</h3>\n<p dir=\"auto\">This is a private Beta for the 3.12 release. Goal of this enhancement is to enable customers to more confidently remove a node and ensuring that no traffic is routed to the offline node to minimize service disruption. It will be supported for Cluster customers (not Cluster HA or Standalone HA)</p>\n<hr>\n<p dir=\"auto\">This new command will allow Cluster customers to remove and ensure that no traffic is routed to it.</p>\n<p dir=\"auto\">How it works:<br>\nPass in the host name<br>\nRun <code class=\"notranslate\">ghe-remove-node &lt;hostname&gt;</code></p>\n<ul dir=\"auto\">\n<li>this will evacuate git and storage data from the node*</li>\n<li>services will be disabled</li>\n<li>node will then be removed from the cluster</li>\n</ul>\n<p dir=\"auto\">*If you do not want to evacuate the node:<br>\nRun <code class=\"notranslate\">ghe-remove-node --no-evacuate &lt;hostname&gt;</code></p>",
            "url": "https://github.com/github/roadmap/issues/925",
            "title": "Node Removal Enhancement",
            "date_modified": "2024-01-31T20:57:39.000Z",
            "date_published": "2024-01-31T20:57:02.000Z",
            "author": {
                "name": "github-product-roadmap",
                "url": "https://github.com/github-product-roadmap"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/67656570?u=71034939d8d88be6d9b9068038dfdc8158fa69c0&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><h3 dir=\"auto\">Summary</h3>\n<p dir=\"auto\">Each Enterprise will have the ability to configure a total of 3 streams across our <a href=\"https://docs.github.com/en/enterprise-cloud@latest/admin/monitoring-activity-in-your-enterprise/reviewing-audit-logs-for-your-enterprise/streaming-the-audit-log-for-your-enterprise#setting-up-audit-log-streaming\">supported streaming endpoints.</a></p>\n<hr>\n<p dir=\"auto\">The objective of GitHub's Enterprise audit log is to serve as a robust and flexible telemetry source for Enterprises to demonstrate compliance while securing their assets. To do so, we aim to enable and empower customers to employ their preferred tools for log storage and analysis. Audit log streaming allows customers to deploy log storage and analysis tooling by selecting a destination from our <a href=\"https://docs.github.com/en/enterprise-cloud@latest/admin/monitoring-activity-in-your-enterprise/reviewing-audit-logs-for-your-enterprise/streaming-the-audit-log-for-your-enterprise#setting-up-audit-log-streaming\">list of supported streaming endpoints</a> for GitHub to write an Enterprise's audit log events in near real time. Since becoming <a href=\"https://github.blog/changelog/2022-01-20-audit-log-streaming-is-generally-available/\" rel=\"nofollow\">generally available in January of 2022</a>, over 1,000 Enterprises have configured audit log streaming!</p>\n<p dir=\"auto\">However, Enterprises often need to employ multiple tools to ensure compliance and maintain a strong security posture. This often involves many different teams, requiring different levels of access, employing different technology to accomplish their piece of the broader security and compliance mission. To ensure GitHub's Enterprise audit log can support the deployment of a diverse security and compliance technology stack, each Enterprise will now have the ability to configure a total of 3 streams across our <a href=\"https://docs.github.com/en/enterprise-cloud@latest/admin/monitoring-activity-in-your-enterprise/reviewing-audit-logs-for-your-enterprise/streaming-the-audit-log-for-your-enterprise#setting-up-audit-log-streaming\">supported streaming endpoints.</a>.</p>",
            "url": "https://github.com/github/roadmap/issues/924",
            "title": "Streaming Enterprise audit logs to multiple endpoints [Beta]",
            "date_modified": "2024-01-31T20:57:38.000Z",
            "date_published": "2024-01-31T20:56:59.000Z",
            "author": {
                "name": "github-product-roadmap",
                "url": "https://github.com/github-product-roadmap"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/67656570?u=71034939d8d88be6d9b9068038dfdc8158fa69c0&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><h3 dir=\"auto\">Summary</h3>\n<p dir=\"auto\">SAML single sign-on (SSO) gives organization owners and enterprise owners a way to control and secure access to organization resources like repositories, issues, and pull requests. Organization owners can invite your personal account to join their organization that uses SAML SSO, which allows you to contribute to the organization and retain your existing identity and contributions on GitHub - while also enforcing a SAML SSO check to access the organization's resources.</p>\n<p dir=\"auto\">This feature augments existing audit log events with the SAML identity associated with the user who took the relevant action. In doing so, customers using GitHub Enterprise will be able to track activity associated with a specific SAML identity in the enterprise and organization audit logs.</p>\n<h3 dir=\"auto\">Intended Outcome</h3>\n<p dir=\"auto\">Enterprise and Organization owners will be able to track audit log activity associated with specific SAML SSO identities. By providing the SAML SSO identity as part of the audit log, enterprise and organization owners can quickly and easily link logs from multiple sourcing using the same SAML SSO identity identifiers. This allows Enterprise owners to attribute audit log activity to a user's corporate identity.</p>\n<h3 dir=\"auto\">How will it work?</h3>\n<p dir=\"auto\">The external_identity_nameid or external_identity_username, depending on the IdP provider, will be displayed in all audit log events where the SAML SSO identity is associated with the actor in a SAML enabled organization or enterprise.</p>",
            "url": "https://github.com/github/roadmap/issues/923",
            "title": "SAML SSO identity displayed in enterprise audit log events - [GA]",
            "date_modified": "2024-01-31T20:57:37.000Z",
            "date_published": "2024-01-31T20:56:56.000Z",
            "author": {
                "name": "github-product-roadmap",
                "url": "https://github.com/github-product-roadmap"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/67656570?u=71034939d8d88be6d9b9068038dfdc8158fa69c0&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><h3 dir=\"auto\">Summary</h3>\n<p dir=\"auto\">Code search can be a powerful feature for navigating and finding content on GitHub. However, code search can also be used by malicious actors to perform searches aimed to discovering potentially exploitable vulnerabilities within a code base. By crafting targeted search terms, a malicious actor can discover secrets and other sensitive data that may have inadvertently been pushed to the code base or accidentally shared in other elements of the GitHub development ecosystem.</p>\n<p dir=\"auto\">To combat abuse of the code search tool, we aim to make code searches targeting Enterprise's private assets auditable by exposing the target asset (ex. repo, org, etc) and the search parameters in Enterprise's audit logs. This will provide Enterprise owners with the ability to audit code search use and design specific detections to alert on potential malicious code search activity.</p>\n<p dir=\"auto\">To protect our customers' privacy, code search audit log events will only cover code searches targeting private Enterprise assets. As such, the audit log entries not cover global code searches or searches targeting public assets (ex. public repos).</p>",
            "url": "https://github.com/github/roadmap/issues/922",
            "title": "Creating audit log events for code searches targeting Enterprise's private assets [Beta]",
            "date_modified": "2024-01-31T20:57:36.000Z",
            "date_published": "2024-01-31T20:56:53.000Z",
            "author": {
                "name": "github-product-roadmap",
                "url": "https://github.com/github-product-roadmap"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/67656570?u=71034939d8d88be6d9b9068038dfdc8158fa69c0&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><h3 dir=\"auto\">Summary</h3>\n<p dir=\"auto\">Customers are currently able to access and export 7 days worth git events and 6 months of all other audit log events via the audit log API and audit log exports. To retain access to events beyond these retention periods, Enterprise customers are able to stream their audit logs to a supported streaming endpoint. If a customer is not an Enterprise or has not set up streaming, the customer must contact support to secure access to git data greater than 7 days old, or other audit log activity greater than 6 months.</p>\n<p dir=\"auto\">By expanding access to historical log data via audit log exports, we will enable customers to access 6 months of git events and 1 year of all other audit log events using audit log exports. In doing so, customers will be empowered to independently access and export data equivalent to that historically provided by GitHub's support team. In addition, customer's adopting streaming will have the ability to backfill a broader set of historical logs into one of GitHub's supported streaming endpoints.</p>",
            "url": "https://github.com/github/roadmap/issues/921",
            "title": "Expanding access to historical log data via audit log exports [Beta]",
            "date_modified": "2024-01-31T20:55:25.000Z",
            "date_published": "2024-01-31T20:54:41.000Z",
            "author": {
                "name": "github-product-roadmap",
                "url": "https://github.com/github-product-roadmap"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/67656570?u=71034939d8d88be6d9b9068038dfdc8158fa69c0&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><h3 dir=\"auto\">Summary</h3>\n<p dir=\"auto\">Enable CodeQL to scan Java applications, without requiring a build command or a configuration that can be automatically recognized to reproduce the build. The improvements to Java scanning will increase the number of applications that can be scanned with minimal configuration.</p>\n<h3 dir=\"auto\">Intended Outcome</h3>\n<p dir=\"auto\">Java applications that are scanned with CodeQL need to be able to specify a build command or be compiled with the CodeQL autobuilders. This new approach will allow users to scan significantly more Java repos without requiring additional configuration. This will improve the overall adoption of CodeQL for Java.</p>\n<h3 dir=\"auto\">How will it work?</h3>\n<p dir=\"auto\">In the current state, CodeQL requires a working build that can be automatically replicated by CodeQL's autobuilders or a manual build command supplied in the configuration. After this change, users will be able to point CodeQL to Java applications which previously did not have a working autobuilder or a manual build command in the configuration. CodeQL will automatically extract as much of the Java code as possible and run a security analysis.</p>",
            "url": "https://github.com/github/roadmap/issues/920",
            "title": "CodeQL can scan Java applications without requiring a supported build configuration or build command (public beta)",
            "date_modified": "2024-01-31T20:55:24.000Z",
            "date_published": "2024-01-31T20:54:38.000Z",
            "author": {
                "name": "github-product-roadmap",
                "url": "https://github.com/github-product-roadmap"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/67656570?u=71034939d8d88be6d9b9068038dfdc8158fa69c0&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><h3 dir=\"auto\">Summary</h3>\n<p dir=\"auto\">The <a href=\"https://docs.github.com/en/code-security/code-scanning/automatically-scanning-your-code-for-vulnerabilities-and-errors/about-code-scanning-with-codeql\">CodeQL analysis engine</a> for <a href=\"https://docs.github.com/en/code-security/code-scanning/automatically-scanning-your-code-for-vulnerabilities-and-errors/about-code-scanning\">GitHub code scanning</a> will be able to analyze projects built with Java 22.</p>\n<h3 dir=\"auto\">Intended Outcome</h3>\n<p dir=\"auto\">Currently, <a href=\"https://codeql.github.com/docs/codeql-overview/supported-languages-and-frameworks/\">CodeQL supports Java language features up to and including</a> Java 21. Java version 22 is due to be released early 2024. Adding support to CodeQL will allow users of Java 22 to benefit from CodeQL's comprehensive security analysis.</p>\n<h3 dir=\"auto\">How will it work?</h3>\n<p dir=\"auto\">If a project contains code build with Java 22, CodeQL will be able to scan the code. As soon as the analysis is finished, the CodeQL results will become visible to you in the \"Security\" tab and on pull requests. Java 22 support will also be available through the <a href=\"https://codeql.github.com/docs/codeql-cli/about-the-codeql-cli/\">CodeQL CLI</a> and <a href=\"https://marketplace.visualstudio.com/items?itemName=GitHub.vscode-codeql\" rel=\"nofollow\">CodeQL VS Code extension</a>.</p>",
            "url": "https://github.com/github/roadmap/issues/919",
            "title": "Code scanning with CodeQL supports Java 22",
            "date_modified": "2024-01-31T20:55:23.000Z",
            "date_published": "2024-01-31T20:54:35.000Z",
            "author": {
                "name": "github-product-roadmap",
                "url": "https://github.com/github-product-roadmap"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/67656570?u=71034939d8d88be6d9b9068038dfdc8158fa69c0&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><h3 dir=\"auto\">Summary</h3>\n<p dir=\"auto\">The <a href=\"https://docs.github.com/en/code-security/code-scanning/automatically-scanning-your-code-for-vulnerabilities-and-errors/about-code-scanning-with-codeql\">CodeQL analysis engine</a> for <a href=\"https://docs.github.com/en/code-security/code-scanning/automatically-scanning-your-code-for-vulnerabilities-and-errors/about-code-scanning\">GitHub code scanning</a> will be able to analyze projects built with Go 1.22.</p>\n<h3 dir=\"auto\">Intended Outcome</h3>\n<p dir=\"auto\">Currently, <a href=\"https://codeql.github.com/docs/codeql-overview/supported-languages-and-frameworks/\">CodeQL supports Go language features up to and including</a>Go 1.21. Go version 1.22 is due to be released early 2024. Adding support to CodeQL will allow users of Go 1.22 to benefit from CodeQL's comprehensive security analysis.</p>\n<h3 dir=\"auto\">How will it work?</h3>\n<p dir=\"auto\">If a project contains code built with Go 1.22, CodeQL will be able to scan the code. As soon as the analysis is finished, the CodeQL results will become visible to you in the \"Security\" tab and on pull requests. Go 1.22 support will also be available through the <a href=\"https://codeql.github.com/docs/codeql-cli/about-the-codeql-cli/\">CodeQL CLI</a> and <a href=\"https://marketplace.visualstudio.com/items?itemName=GitHub.vscode-codeql\" rel=\"nofollow\">CodeQL VS Code extension</a>.</p>",
            "url": "https://github.com/github/roadmap/issues/918",
            "title": "Code scanning with CodeQL supports Go 1.22",
            "date_modified": "2024-01-31T20:55:22.000Z",
            "date_published": "2024-01-31T20:54:32.000Z",
            "author": {
                "name": "github-product-roadmap",
                "url": "https://github.com/github-product-roadmap"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/67656570?u=71034939d8d88be6d9b9068038dfdc8158fa69c0&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><h3 dir=\"auto\">Summary</h3>\n<p dir=\"auto\">Secret scanning's push protection, currently available as an opt-in feature at the user level, prevents secrets from being leaked in repositories. It will be enabled by default for all free users on GitHub, and will notify developers on push attempt if their push to a free public repository contains a secret. Users will have the option to opt out.</p>\n<h3 dir=\"auto\">Intended Outcome</h3>\n<p dir=\"auto\">Push protection offers another level of security for users by preventing credential leaks in their codebases. With enabling push protection by default at the user level, open source developers across GitHub don't need to rely on the security settings of the particular repository they are pushing to. They are protected on all pushes to public repositories across GitHub.</p>\n<h3 dir=\"auto\">How will it work?</h3>\n<p dir=\"auto\">Push protection will be enabled at the user level by default. If a push to a public repository contains a secret, the push will be blocked and the developer will have the option to remove the secret from the code, or bypass push protection.</p>\n<p dir=\"auto\">The public repository does not need to have secret scanning or push protection enabled. If the developer bypasses the block and the repository does not have secret scanning enabled, secret scanning alerts are not created.</p>\n<p dir=\"auto\">Users can disable push protection for themselves in the \"Code security and analysis\" section of their user settings.</p>",
            "url": "https://github.com/github/roadmap/issues/917",
            "title": "Secret scanning push protection is enabled for users by default",
            "date_modified": "2024-01-31T20:55:21.000Z",
            "date_published": "2024-01-31T20:54:29.000Z",
            "author": {
                "name": "github-product-roadmap",
                "url": "https://github.com/github-product-roadmap"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/67656570?u=71034939d8d88be6d9b9068038dfdc8158fa69c0&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><h3 dir=\"auto\">Summary</h3>\n<p dir=\"auto\">By default, code scanning with CodeQL scans code in pull requests, and code on all default/protected branches. This helps our users <em>stay clean</em> (by scanning pull requests) and <em>get clean</em> (by scanning default/protected branches). We <a href=\"https://github.blog/2023-11-08-ai-powered-appsec/\" rel=\"nofollow\">recently shipped our AI-powered autofixes for alerts in pull requests</a>. In the future, code scanning will also provide AI-generated fixes for CodeQL alerts that are present on default and protected branches, outside the pull request experience. To help developers interact with these fixes more easily and quickly, we will integrate alerts and autofixes into VS Code.</p>\n<h3 dir=\"auto\">Intended Outcome</h3>\n<p dir=\"auto\">AI-powered autofixes will help developers fix existing security vulnerabilities on the main or default branches more quickly and with less effort, straight in their code editor on their local machine, without leaving their flow. This helps reduce the number of active vulnerabilities and improves the security posture.</p>\n<h3 dir=\"auto\">How will it work?</h3>\n<p dir=\"auto\">The VS Code extension will integrate code scanning alerts (and autofixes) into VS Code.</p>",
            "url": "https://github.com/github/roadmap/issues/916",
            "title": "Code scanning: AI-powered autofixes for CodeQL alerts on all branches, integrated into VS Code",
            "date_modified": "2024-01-31T20:55:20.000Z",
            "date_published": "2024-01-31T20:54:26.000Z",
            "author": {
                "name": "github-product-roadmap",
                "url": "https://github.com/github-product-roadmap"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/67656570?u=71034939d8d88be6d9b9068038dfdc8158fa69c0&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><h3 dir=\"auto\">Summary</h3>\n<p dir=\"auto\">As <a href=\"https://github.blog/2023-01-20-sunsetting-subversion-support/\" rel=\"nofollow\">announced</a> last year, Subversion support will be turned off in GitHub Enterprise Server 3.13, which is tentatively <a href=\"https://docs.github.com/en/enterprise-server@3.11/admin/all-releases\">scheduled</a> for release in June 2024.</p>\n<p dir=\"auto\">Subversion support was <a href=\"https://github.blog/changelog/2024-01-08-subversion-has-been-sunset/\" rel=\"nofollow\">removed</a> from GitHub.com on January 8, 2024.</p>\n<h3 dir=\"auto\">Intended Outcome</h3>\n<p dir=\"auto\">Subversion support is little-used by GitHub customers (in aggregate) but represents an above-average ongoing support and maintenance burden. Removing it will free up resources to focus on features and support that is more relevant to the vast majority of our customers.</p>",
            "url": "https://github.com/github/roadmap/issues/915",
            "title": "Sunset Subversion support in GitHub Enterprise Server",
            "date_modified": "2024-01-31T20:55:19.000Z",
            "date_published": "2024-01-31T20:54:23.000Z",
            "author": {
                "name": "github-product-roadmap",
                "url": "https://github.com/github-product-roadmap"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/67656570?u=71034939d8d88be6d9b9068038dfdc8158fa69c0&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><h3 dir=\"auto\">Summary</h3>\n<p dir=\"auto\">With this feature, you will be able to configure how Dependabot groups multiple dependency updates related to Dependabot alerts into single pull requests.</p>\n<h3 dir=\"auto\">Intended Outcome</h3>\n<p dir=\"auto\">This will reduce the number of Dependabot security PRs that get opened.</p>\n<h3 dir=\"auto\">How will it work?</h3>\n<p dir=\"auto\">You will be able to either click a button in the repository settings page to tell Dependabot to group all security updates, or use dependabot.yml checked into the repository to configure which updates to include. You will be able to configure grouping rules based on:</p>\n<ul dir=\"auto\">\n<li>Package name and patterns (e.g. <code class=\"notranslate\">eslint</code> or <code class=\"notranslate\">*</code>)</li>\n<li>Dependency type (<code class=\"notranslate\">production</code> or <code class=\"notranslate\">development</code>)</li>\n<li>Semver update (e.g. <code class=\"notranslate\">semver-patch</code>, <code class=\"notranslate\">semver-major</code>)</li>\n<li>Directories</li>\n</ul>",
            "url": "https://github.com/github/roadmap/issues/914",
            "title": "Dependabot Grouped Security Updates GA",
            "date_modified": "2024-01-31T20:55:17.000Z",
            "date_published": "2024-01-31T20:54:20.000Z",
            "author": {
                "name": "github-product-roadmap",
                "url": "https://github.com/github-product-roadmap"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/67656570?u=71034939d8d88be6d9b9068038dfdc8158fa69c0&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><h3 dir=\"auto\">Summary</h3>\n<p dir=\"auto\">Dependabot is migrating to Actions. With this change, there will be no interruption or change to the functionality of Dependabot, but you will be able to see Dependabot's jobs in the Actions tab and leverage Actions-related tools to manage Dependabot, including running Dependabot on self-hosted runners.</p>\n<p dir=\"auto\">Note about GHES: this feature is already available on GHES, so this particular ship will not be going to any version of GHES.</p>\n<h3 dir=\"auto\">Intended Outcome</h3>\n<p dir=\"auto\">This will consolidate Dependabot further onto GitHub infrastructure, and enable customers to have greater control over Dependabot runs.</p>\n<h3 dir=\"auto\">How will it work?</h3>\n<p dir=\"auto\">With this release, you will be able to opt-in to migrating Dependabot to run on Actions. There will be no interruption to Dependabot's runs. Following the migration, you will be able to:</p>\n<ul dir=\"auto\">\n<li>Configure Dependabot for self-hosted runners (for example, in order to allow Dependabot to access firewalled private registries for updates)</li>\n<li>Leverage the Actions API to track Dependabot job failures</li>\n<li>See Dependabot job logs in the Actions tab</li>\n</ul>",
            "url": "https://github.com/github/roadmap/issues/913",
            "title": "Dependabot on Actions for GHEC",
            "date_modified": "2024-01-31T20:55:16.000Z",
            "date_published": "2024-01-31T20:54:17.000Z",
            "author": {
                "name": "github-product-roadmap",
                "url": "https://github.com/github-product-roadmap"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/67656570?u=71034939d8d88be6d9b9068038dfdc8158fa69c0&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><h3 dir=\"auto\">Summary</h3>\n<p dir=\"auto\">In late 2023 we released the EMU public SCIM schema. This is the same set of APIs that our integration partners (Microsoft, Okta, Ping) used to create their app integrations for EMU identity management. Our next step is to allow customers to integrate any SAML 2.0 and SCIM identity implementation with Enterprise Managed Users by following GitHub's guidance.</p>\n<h3 dir=\"auto\">Intended Outcome</h3>\n<p dir=\"auto\">Customers who have standardized on identity systems that we have not directly supported now have more flexibility when integrating with GitHub's enterprise managed users feature. SCIM is required to provision and manage users and groups with EMUs, but we no longer require that the same identity system to be the source of both SSO and SCIM calls.</p>\n<h3 dir=\"auto\">How will it work?</h3>\n<p dir=\"auto\">As an example, a customer can choose Okta for SAML SSO and use another system like Sailpoint or a custom implementation for user lifecycle management via SCIM. We primarily require that users are distinguishable as the same unique user through SSO and SCIM calls. GitHub will provide guidance on implementation expectations.</p>",
            "url": "https://github.com/github/roadmap/issues/912",
            "title": "Bring your own identity provider to EMUs - Mixed SSO and SCIM support",
            "date_modified": "2024-01-31T20:55:15.000Z",
            "date_published": "2024-01-31T20:54:14.000Z",
            "author": {
                "name": "github-product-roadmap",
                "url": "https://github.com/github-product-roadmap"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/67656570?u=71034939d8d88be6d9b9068038dfdc8158fa69c0&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><h3 dir=\"auto\">Summary</h3>\n<p dir=\"auto\">On February 1, 2024, we will deprecate the Copilot Chat API endpoints currently being routed through <a href=\"https://copilot-proxy.githubusercontent.com/\" rel=\"nofollow\">https://copilot-proxy.githubusercontent.com/</a>. Instead, these requests will go through <a href=\"https://api.githubcopilot.com/\" rel=\"nofollow\">https://api.githubcopilot.com/</a>. New versions of the Copilot extension already route chat traffic through <a href=\"https://api.githubcopilot.com/\" rel=\"nofollow\">https://api.githubcopilot.com/</a>.</p>\n<p dir=\"auto\">Please ensure your firewall and network settings allow communication to <a href=\"https://api.githubcopilot.com/\" rel=\"nofollow\">https://api.githubcopilot.com/</a> in order for Copilot Chat to continue working on February 1, 2024.</p>\n<p dir=\"auto\">For more information, see the <a href=\"https://docs.github.com/en/enterprise-cloud@latest/copilot/troubleshooting-github-copilot/troubleshooting-firewall-settings-for-github-copilot\">Troubleshooting firewall settings for GitHub Copilot documentation</a>.</p>",
            "url": "https://github.com/github/roadmap/issues/905",
            "title": "Deprecation of Copilot Proxy Chat API Endpoints",
            "date_modified": "2024-01-31T20:42:07.000Z",
            "date_published": "2024-01-31T20:07:06.000Z",
            "author": {
                "name": "github-product-roadmap",
                "url": "https://github.com/github-product-roadmap"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/67656570?u=71034939d8d88be6d9b9068038dfdc8158fa69c0&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><h3 dir=\"auto\">Summary</h3>\n<p dir=\"auto\">Enterprise customers can now set up Actions to connect with their internal networks. GitHub has introduced a turnkey set of tools that allow enterprise admins to give GitHub Actions access to the resources their teams need inside their private networks. This means that teams can now access their internal APIs, Databases, Artifactory instances and more from GitHub’s hosted runners.</p>\n<h3 dir=\"auto\">Intended Outcome</h3>\n<p dir=\"auto\">Using GitHub-hosted runners within Azure VNET allows you to perform the following actions.</p>\n<ul dir=\"auto\">\n<li>Privately connect a runner to resources inside an Azure VNET without opening internet ports, including on-premises resources accessible from the Azure VNET.</li>\n<li>Restrict what GitHub-hosted runners can access or connect to with full control over outbound network policies.</li>\n<li>Monitor network logs for GitHub-hosted runners and view all connectivity to and from a runner.</li>\n</ul>\n<h3 dir=\"auto\">How will it work?</h3>\n<p dir=\"auto\">To facilitate communication between GitHub networks and your VNET, a <a href=\"https://docs.github.com/en/enterprise-cloud@latest/admin/configuration/configuring-private-networking-for-hosted-compute-products/about-using-github-hosted-runners-in-your-azure-virtual-network#about-network-communication\">GitHub-hosted runner's network interface card (NIC) deploys into your Azure VNET</a>. Enterprise and organization admins can configure Azure private networking by creating one or more network configurations with desired Azure VNETs. Once created, network configurations can be associated with required runner groups for underlying runners to inherit the networking policies.</p>\n<p dir=\"auto\"><a href=\"https://docs.github.com/en/enterprise-cloud@latest/admin/configuration/configuring-private-networking-for-hosted-compute-products/about-networking-for-hosted-compute-products\">Learn more about Azure private networking ad network configurations here. </a></p>",
            "url": "https://github.com/github/roadmap/issues/904",
            "title": "GitHub-hosted runners: Private networking for secure connections to customer Azure VNETs",
            "date_modified": "2024-01-31T20:42:17.000Z",
            "date_published": "2024-01-31T20:07:03.000Z",
            "author": {
                "name": "github-product-roadmap",
                "url": "https://github.com/github-product-roadmap"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/67656570?u=71034939d8d88be6d9b9068038dfdc8158fa69c0&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><h3 dir=\"auto\">Summary</h3>\n<p dir=\"auto\">The <a href=\"https://docs.github.com/en/code-security/code-scanning/automatically-scanning-your-code-for-vulnerabilities-and-errors/about-code-scanning-with-codeql\">CodeQL analysis engine</a> for <a href=\"https://docs.github.com/en/code-security/code-scanning/automatically-scanning-your-code-for-vulnerabilities-and-errors/about-code-scanning\">GitHub code scanning</a> will be able to analyze projects built with C# 12 / .NET 8.</p>\n<h3 dir=\"auto\">Intended Outcome</h3>\n<p dir=\"auto\">Currently, CodeQL supports <a href=\"https://codeql.github.com/docs/codeql-overview/supported-languages-and-frameworks/\"> language features up to and including </a> C# 11 / .NET 7. A new C# version 12 and .NET version 8 are due to be released before the end of 2023. Adding support to CodeQL will allow users of C# 12 / .NET 8 to benefit from CodeQL's comprehensive security analysis.</p>\n<h3 dir=\"auto\">How will it work?</h3>\n<p dir=\"auto\">If a project contains code that uses C# 12 / .NET 8, CodeQL will be able to scan the code. As soon as the analysis is finished, the CodeQL results will become visible to you in the \"Security\" tab and on pull requests. C# 12 / .NET 8 support will also be available through the <a href=\"https://codeql.github.com/docs/codeql-cli/about-the-codeql-cli/\">CodeQL CLI</a> and <a href=\"https://marketplace.visualstudio.com/items?itemName=GitHub.vscode-codeql\" rel=\"nofollow\">CodeQL VS Code extension</a>.</p>",
            "url": "https://github.com/github/roadmap/issues/902",
            "title": "Code scanning with CodeQL supports C#12 / .NET 8",
            "date_modified": "2024-01-31T20:41:43.000Z",
            "date_published": "2024-01-31T20:06:57.000Z",
            "author": {
                "name": "github-product-roadmap",
                "url": "https://github.com/github-product-roadmap"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/67656570?u=71034939d8d88be6d9b9068038dfdc8158fa69c0&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><h3 dir=\"auto\">Summary</h3>\n<p dir=\"auto\">Dependabot version updates creates updates to proactively update out-of-date dependencies. It currently creates one pull request per dependency, but that doesn't make sense for every repository. This feature will allow maintainers to configure their updates to group certain sets of dependencies together.</p>\n<p dir=\"auto\">This is a continuation from the public beta: <a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load title\" data-id=\"785401555\" data-permission-text=\"Title is private\" data-url=\"https://github.com/github/roadmap/issues/148\" data-hovercard-type=\"issue\" data-hovercard-url=\"/github/roadmap/issues/148/hovercard\" href=\"https://github.com/github/roadmap/issues/148\">#148</a></p>\n<h3 dir=\"auto\">Intended Outcome</h3>\n<p dir=\"auto\">This will help developers better manage the many PRs that Dependabot opens.</p>\n<h3 dir=\"auto\">How will it work?</h3>\n<p dir=\"auto\">Once the developer specifies grouping rules in their <code class=\"notranslate\">dependabot.yml</code> file, they will start seeing Dependabot open PRs with multiple dependencies based on those rules.</p>",
            "url": "https://github.com/github/roadmap/issues/874",
            "title": "Dependabot Grouped Version Updates GA",
            "date_modified": "2023-12-20T19:01:43.000Z",
            "date_published": "2023-12-20T19:00:25.000Z",
            "author": {
                "name": "github-product-roadmap",
                "url": "https://github.com/github-product-roadmap"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/67656570?u=71034939d8d88be6d9b9068038dfdc8158fa69c0&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><h3 dir=\"auto\">Summary</h3>\n<p dir=\"auto\">Code scanning default setup can now be enabled on repositories which don't contain any CodeQL supported languages and will automatically update to include any supported languages when they are added to the repository.</p>\n<h3 dir=\"auto\">Intended Outcome</h3>\n<p dir=\"auto\">You can enable default setup on any repository and have confidence that it will automatically give the best possible protection when the repository changes to include CodeQL supported languages.</p>\n<h3 dir=\"auto\">How will it work?</h3>\n<p dir=\"auto\">When default setup is enabled on a repository without any CodeQL supported languages, the repository will watch for CodeQL supported languages that added to the repository and automatically update to analyse them.</p>",
            "url": "https://github.com/github/roadmap/issues/854",
            "title": "Code scanning default setup can be enabled on repositories before code in supported languages are added to the repositories",
            "date_modified": "2024-01-31T20:59:49.000Z",
            "date_published": "2023-12-20T18:20:38.000Z",
            "author": {
                "name": "github-product-roadmap",
                "url": "https://github.com/github-product-roadmap"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/67656570?u=71034939d8d88be6d9b9068038dfdc8158fa69c0&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><h3 dir=\"auto\">Summary</h3>\n<p dir=\"auto\">Code scanning default setup will be available for self-hosted runners on GHEC.</p>\n<h3 dir=\"auto\">Intended Outcome</h3>\n<p dir=\"auto\">Customers with self-hosted runners on GHEC can use code scanning default setup on their repositories.</p>\n<h3 dir=\"auto\">How will it work?</h3>\n<p dir=\"auto\">Code scanning default setup will use self-hosted runners on GHEC if a repository has access to self-hosted runners with the label <code class=\"notranslate\">code-scanning</code>. Default setup will only use one runner type per repository, either hosted or self-hosted.</p>",
            "url": "https://github.com/github/roadmap/issues/852",
            "title": "Code scanning default setup supports self-hosted runners on GHEC",
            "date_modified": "2024-01-31T20:59:48.000Z",
            "date_published": "2023-12-20T18:20:32.000Z",
            "author": {
                "name": "github-product-roadmap",
                "url": "https://github.com/github-product-roadmap"
            }
        }
    ]
}