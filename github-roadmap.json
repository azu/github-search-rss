{
    "version": "https://jsonfeed.org/version/1",
    "title": "github/roadmap Issues",
    "home_page_url": "https://azu.github.io/github-search-rss/github-roadmap.json",
    "feed_url": "https://azu.github.io/github-search-rss/github-roadmap.json",
    "description": "github/roadmap Issues on GitHub",
    "items": [
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/67656570?u=71034939d8d88be6d9b9068038dfdc8158fa69c0&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><h3 dir=\"auto\">Summary</h3>\n<p dir=\"auto\">In public beta, secret scanning scans high-confidence tokens (those with a low false positive rate) and blocks a remote push if secrets are detected, thereby flagging secrets before exposure. Now, we're expanding push protections to support custom patterns!</p>\n<h3 dir=\"auto\">Intended Outcome</h3>\n<p dir=\"auto\">Advanced Security customers can enable push protection for our set of highly-identifiable, built-in patterns. While these patterns provide preventative support for customers, organizations want to also protect their developers from leaking organization-specific patterns. Push protection support for custom patterns will fill this coverage need.</p>\n<h3 dir=\"auto\">How will it work?</h3>\n<p dir=\"auto\">Advanced Security customers will be able to enable push protection for default patterns and custom patterns at the repository and organization levels.</p>",
            "url": "https://github.com/github/roadmap/issues/496",
            "title": "Secret scanning as a push protection (GA)",
            "date_modified": "2022-04-13T20:50:54.000Z",
            "date_published": "2022-04-13T20:50:09.000Z",
            "author": {
                "name": "github-product-roadmap",
                "url": "https://github.com/github-product-roadmap"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/67656570?u=71034939d8d88be6d9b9068038dfdc8158fa69c0&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><h3 dir=\"auto\">Summary</h3>\n<p dir=\"auto\">This feature will expose information about Dependabot alerts and Dependabot updates in a new REST API.</p>\n<h3 dir=\"auto\">Intended Outcome</h3>\n<p dir=\"auto\">While users can already access information about Dependabot alerts and Dependabot updates from the GraphQL API, many users have indicated a preference for working with a REST API instead.</p>\n<h3 dir=\"auto\">How will it work?</h3>\n<p dir=\"auto\"><em>No response</em></p>",
            "url": "https://github.com/github/roadmap/issues/495",
            "title": "Dependabot REST API",
            "date_modified": "2022-04-13T20:49:36.000Z",
            "date_published": "2022-04-13T20:49:00.000Z",
            "author": {
                "name": "github-product-roadmap",
                "url": "https://github.com/github-product-roadmap"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/67656570?u=71034939d8d88be6d9b9068038dfdc8158fa69c0&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><h3 dir=\"auto\">Summary</h3>\n<p dir=\"auto\">Dependabot alerts will surface more information about transitive dependencies, including direct dependency information and transitive dependency paths.</p>\n<h3 dir=\"auto\">Intended Outcome</h3>\n<p dir=\"auto\">In this initial ship, we expect to add filtering ability for alerts on direct and indirect dependencies, as well as surfacing of the direct dependencies that pull in a transitive dependency.</p>\n<h3 dir=\"auto\">How will it work?</h3>\n<p dir=\"auto\"><em>No response</em></p>",
            "url": "https://github.com/github/roadmap/issues/494",
            "title": "Dependabot alerts: transitive dependency paths",
            "date_modified": "2022-04-13T20:49:35.000Z",
            "date_published": "2022-04-13T20:48:57.000Z",
            "author": {
                "name": "github-product-roadmap",
                "url": "https://github.com/github-product-roadmap"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/67656570?u=71034939d8d88be6d9b9068038dfdc8158fa69c0&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><h3 dir=\"auto\">Summary</h3>\n<p dir=\"auto\">As testing tool, a dry-run scan at the enterprise level will allow users to hone their custom regex patterns by determining the estimated number and quality of alerts generated for a specified pattern. This feature follows our release of repository and organization level dry-runs.</p>\n<h3 dir=\"auto\">Intended Outcome</h3>\n<p dir=\"auto\">A poorly authored regular expression can spawn thousands of results across an enterprise. Dry-run scans will allow users to prevent a bloat of results by testing their patterns before submission.</p>\n<h3 dir=\"auto\">How will it work?</h3>\n<p dir=\"auto\">Users can easily test their patterns before publishing at the repository, organization, and now enterprise levels. The dry-run scan will provide users with an estimate of the number of alerts that their pattern would create if published, as well as a sample set of detected secrets in the relevant repositories.</p>",
            "url": "https://github.com/github/roadmap/issues/493",
            "title": "Secret scanning: dry-runs for enterprise-level custom patterns (cloud)",
            "date_modified": "2022-04-13T20:49:34.000Z",
            "date_published": "2022-04-13T20:48:54.000Z",
            "author": {
                "name": "github-product-roadmap",
                "url": "https://github.com/github-product-roadmap"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/67656570?u=71034939d8d88be6d9b9068038dfdc8158fa69c0&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><h3 dir=\"auto\">Summary</h3>\n<p dir=\"auto\">As testing tool, a dry-run scan at the enterprise level will allow users to hone their custom regex patterns by determining the estimated number and quality of alerts generated for a specified pattern. This feature follows our release of repository and organization level dry-runs.</p>\n<h3 dir=\"auto\">Intended Outcome</h3>\n<p dir=\"auto\">A poorly authored regular expression can spawn thousands of results across an enterprise. Dry-run scans will allow users to prevent a bloat of results by testing their patterns before submission.</p>\n<h3 dir=\"auto\">How will it work?</h3>\n<p dir=\"auto\">Users can easily test their patterns before publishing at the repository, organization, and now enterprise levels. The dry-run scan will provide users with an estimate of the number of alerts that their pattern would create if published, as well as a sample set of detected secrets in the relevant repositories.</p>",
            "url": "https://github.com/github/roadmap/issues/492",
            "title": "Secret scanning: dry-runs for enterprise-level custom patterns (server)",
            "date_modified": "2022-04-13T20:49:33.000Z",
            "date_published": "2022-04-13T20:48:51.000Z",
            "author": {
                "name": "github-product-roadmap",
                "url": "https://github.com/github-product-roadmap"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/67656570?u=71034939d8d88be6d9b9068038dfdc8158fa69c0&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><h3 dir=\"auto\">Summary</h3>\n<p dir=\"auto\">CodeQL is the analysis engine that provides the vast majority of our code scanning results. In Q4 of CY2022, Ruby support will transition from beta to GA - a change that brings more security coverage, library &amp; framework support, and support for the latest Ruby language features.</p>\n<h3 dir=\"auto\">Intended Outcome</h3>\n<p dir=\"auto\">Ruby is a very popular language, both within the open-source community and with our enterprise customers. Building Ruby support for CodeQL means that we'll be able to flag up security alerts in Ruby codebases.</p>\n<h3 dir=\"auto\">How will it work?</h3>\n<p dir=\"auto\">Analyzing Ruby codebases with CodeQL in code scanning works much the same as scanning other source code in languages that we already support. After you've set up CodeQL analysis in an Actions workflow on a Ruby repository, the analysis job will be triggered as configured. As soon as the analysis is finished, CodeQL will export the results, which will then become visible to you in the \"Security\" tab and on pull requests.</p>",
            "url": "https://github.com/github/roadmap/issues/491",
            "title": "Ruby support for CodeQL code scanning (GA)",
            "date_modified": "2022-04-13T20:46:22.000Z",
            "date_published": "2022-04-13T20:45:38.000Z",
            "author": {
                "name": "github-product-roadmap",
                "url": "https://github.com/github-product-roadmap"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/67656570?u=71034939d8d88be6d9b9068038dfdc8158fa69c0&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><h3 dir=\"auto\">Summary</h3>\n<p dir=\"auto\">Users can add a comment when dismissing code scanning alerts.</p>\n<h3 dir=\"auto\">Intended Outcome</h3>\n<p dir=\"auto\">This will let users record the context of an alert dismissal which can be used as justification during auditing and reporting.</p>\n<h3 dir=\"auto\">How will it work?</h3>\n<p dir=\"auto\">Users will be able to add a comment when dismissing a code scanning alert. This will be optional and in addition to selecting a dismissal reason. The comment be recorded in the code scanning alert timeline and REST API.</p>",
            "url": "https://github.com/github/roadmap/issues/490",
            "title": "Users can comment when dismissing code scanning alerts (GitHub.com)",
            "date_modified": "2022-04-13T20:46:21.000Z",
            "date_published": "2022-04-13T20:45:35.000Z",
            "author": {
                "name": "github-product-roadmap",
                "url": "https://github.com/github-product-roadmap"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/67656570?u=71034939d8d88be6d9b9068038dfdc8158fa69c0&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><h3 dir=\"auto\">Summary</h3>\n<p dir=\"auto\">Users can add a comment when dismissing code scanning alerts.</p>\n<h3 dir=\"auto\">Intended Outcome</h3>\n<p dir=\"auto\">This will let users record the context of an alert dismissal which can be used as justification during auditing and reporting.</p>\n<h3 dir=\"auto\">How will it work?</h3>\n<p dir=\"auto\">Users will be able to add a comment when dismissing a code scanning alert. This will be optional and in addition to selecting a dismissal reason. The comment be recorded in the code scanning alert timeline and REST API.</p>",
            "url": "https://github.com/github/roadmap/issues/489",
            "title": "Users can comment when dismissing code scanning alerts (GHES)",
            "date_modified": "2022-04-13T20:46:20.000Z",
            "date_published": "2022-04-13T20:45:32.000Z",
            "author": {
                "name": "github-product-roadmap",
                "url": "https://github.com/github-product-roadmap"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/67656570?u=71034939d8d88be6d9b9068038dfdc8158fa69c0&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><h3 dir=\"auto\">Summary</h3>\n<p dir=\"auto\">Code scanning will post security alerts to the PR’s conversation tab in a new way: a PR review composed of annotations. Users will be able to comment on any individual alert (annotation) to discuss it. The functionality will be available on GHES 3.6.</p>\n<h3 dir=\"auto\">Intended Outcome</h3>\n<p dir=\"auto\">Currently, code scanning alerts are posted as PR checks and are sometimes missed by developers. At the same time, alerts can't be discussed in the PR itself. Tight integration in the conversation tab will address both points.</p>\n<h3 dir=\"auto\">How will it work?</h3>\n<p dir=\"auto\">Code scanning uses <a href=\"https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/collaborating-on-repositories-with-code-quality-features/about-status-checks\">checks (annotations)</a> to communicate that an analysis is in progress and block the PR when an alert is flagged up. This behavior will remain unchanged.</p>\n<p dir=\"auto\">In addition to these checks, the code scanning annotations will appear on the PR’s conversation tab as a PR review.</p>",
            "url": "https://github.com/github/roadmap/issues/488",
            "title": "Code scanning alerts on the PR’s Conversation tab  (GHES)",
            "date_modified": "2022-04-13T20:46:19.000Z",
            "date_published": "2022-04-13T20:45:29.000Z",
            "author": {
                "name": "github-product-roadmap",
                "url": "https://github.com/github-product-roadmap"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/67656570?u=71034939d8d88be6d9b9068038dfdc8158fa69c0&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><h3 dir=\"auto\">Summary</h3>\n<p dir=\"auto\">This feature is the GHES version of <a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load title\" data-id=\"785401602\" data-permission-text=\"Title is private\" data-url=\"https://github.com/github/roadmap/issues/149\" data-hovercard-type=\"issue\" data-hovercard-url=\"/github/roadmap/issues/149/hovercard\" href=\"https://github.com/github/roadmap/issues/149\">#149</a>. In the initial version, it will be delivered as an API which allows developers to block pull requests which include vulnerable dependencies using an app or GitHub Action. We will deliver an open-source GitHub action which implements this functionality.</p>\n<h3 dir=\"auto\">Intended Outcome</h3>\n<p dir=\"auto\">Developers will check in fewer vulnerable dependencies by preventing accidental inclusion of vulnerable dependencies, leaving their end customers more secure.</p>\n<h3 dir=\"auto\">How will it work?</h3>\n<p dir=\"auto\">We will provide an API and a GitHub action which implement this functionality.</p>",
            "url": "https://github.com/github/roadmap/issues/487",
            "title": "Dependency review enforcement (GHES beta)",
            "date_modified": "2022-04-13T20:46:18.000Z",
            "date_published": "2022-04-13T20:45:26.000Z",
            "author": {
                "name": "github-product-roadmap",
                "url": "https://github.com/github-product-roadmap"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/67656570?u=71034939d8d88be6d9b9068038dfdc8158fa69c0&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><h3 dir=\"auto\">Summary</h3>\n<p dir=\"auto\">This is the GitHub Enterprise Server version of <a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load title\" data-id=\"1128882387\" data-permission-text=\"Title is private\" data-url=\"https://github.com/github/roadmap/issues/467\" data-hovercard-type=\"issue\" data-hovercard-url=\"/github/roadmap/issues/467/hovercard\" href=\"https://github.com/github/roadmap/issues/467\">#467</a>.</p>\n<p dir=\"auto\">The dependency graph today uses manifest parsing to understand the set of dependencies in a repository. This approach has some shortcomings: we can't easily support complex dependency systems which use executable code in the build to resolve dependencies (like Gradle), and users of an ecosystem need to wait for GitHub to add support for it.</p>\n<p dir=\"auto\">The dependency submission API will allow users to upload details of their dependencies directly, via an API request. It will be designed to work with the output of build tools and package managers. The dependency graph will store this data and, if an ecosystem is supported in the <a href=\"https://github.com/advisories\">advisory database</a>, GitHub will send alerts if/when a vulnerable dependency is present.</p>\n<p dir=\"auto\">This release will be a public beta.</p>\n<h3 dir=\"auto\">Intended Outcome</h3>\n<p dir=\"auto\">We are building this so that GitHub can better track dependencies from package managers like Gradle which generally require a build to take place to get reliable results.</p>\n<h3 dir=\"auto\">How will it work?</h3>\n<p dir=\"auto\">We are providing a new API which allows developers to submit a snapshot of their dependencies at a particular point in time. This can be called easily from any GitHub Actions or similar CI environment to provide this information.</p>",
            "url": "https://github.com/github/roadmap/issues/486",
            "title": "Dependency submission API (server beta)",
            "date_modified": "2022-04-13T20:46:17.000Z",
            "date_published": "2022-04-13T20:45:23.000Z",
            "author": {
                "name": "github-product-roadmap",
                "url": "https://github.com/github-product-roadmap"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/67656570?u=71034939d8d88be6d9b9068038dfdc8158fa69c0&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><h3 dir=\"auto\">Summary</h3>\n<p dir=\"auto\">Prebuilds enable developers to startup Codespaces in seconds – <em>regardless of repository size or complexity</em> – by building your development environment beforehand. You can think of a \"prebuild\" as a template with all your source code, editor extensions, project dependencies, commands, and configurations ready-to-go.</p>\n<p dir=\"auto\">Previously, prebuilds could only be updated on every push to a prebuild-enabled branch. With this release, repository admins have new options to update the prebuilt image on push, configuration change, or on a schedule.</p>\n<h3 dir=\"auto\">Intended Outcome</h3>\n<p dir=\"auto\">With this release, repository admins will be able to decide how and when to update prebuild configurations. With increased control, admins can make more nuanced trade-offs between between environment \"freshness\" and Actions usage. For example, an admin working in a large organization may decide to update their prebuild configuration every hour rather than on every push to get the most economy and efficiency out of their Actions usage.</p>\n<h3 dir=\"auto\">How will it work?</h3>\n<p dir=\"auto\">While creating or updating prebuilds for a given repo and branch, admins can choose from three triggers to initiate a refresh:</p>\n<ul dir=\"auto\">\n<li><strong>Every push (default):</strong> With this setting, prebuild configurations are updated on every push made to the given branch. This ensures that new Codespaces always contain the latest configuration, including any recently added or updated dependencies.</li>\n<li><strong>On configuration change:</strong> With this setting, prebuild configurations are updated every time configuration files change. This ensures the latest configuration changes appear in new Codespaces. The Actions workflow that generates the prebuild template will run less often, so this option will use fewer Actions minutes. However, this option will not guarantee that Codespaces always include recently added or updated dependencies. Consequently, developers may may need to update these changes manually.</li>\n<li><strong>Scheduled:</strong> With this setting, you can have your prebuild configurations update on a custom schedule. This can reduce consumption of Actions minutes, and reduce the amount of time during which prebuilds are unavailable because they are being updated. However, with this option, codespaces may be created that do not use the latest dev container configuration changes.</li>\n</ul>\n<p dir=\"auto\">Prebuild configurations will only be updated at a cadence/trigger based on the option selected.</p>\n<p><a target=\"_blank\" rel=\"noopener noreferrer\" href=\"https://user-images.githubusercontent.com/30297258/161166551-990c043e-8cd5-471f-8469-6a332c99d92d.png\"><img width=\"950\" alt=\"image\" src=\"https://user-images.githubusercontent.com/30297258/161166551-990c043e-8cd5-471f-8469-6a332c99d92d.png\" style=\"max-width: 100%;\"></a></p>",
            "url": "https://github.com/github/roadmap/issues/485",
            "title": "Codespaces:  Scheduled prebuild configurations ",
            "date_modified": "2022-04-13T20:46:16.000Z",
            "date_published": "2022-04-13T20:45:20.000Z",
            "author": {
                "name": "github-product-roadmap",
                "url": "https://github.com/github-product-roadmap"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/67656570?u=71034939d8d88be6d9b9068038dfdc8158fa69c0&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><h3 dir=\"auto\">Summary</h3>\n<p dir=\"auto\">Organization admins can use APIs to manage codespaces.</p>\n<h3 dir=\"auto\">Intended Outcome</h3>\n<p dir=\"auto\">As organizations start to scale with Codespaces, we've heard feedback around admins needing more more flexibility, beyond UI-only settings, around managing codespaces settings for their organization. This functionality aims at providing organization admins access to APIs that will enable them automate and manage codespaces and codespaces settings more efficiently across various repositories within their org.</p>\n<h3 dir=\"auto\">How will it work?</h3>\n<p dir=\"auto\">Provides org admins APIs to manage org-owned codespaces with support for the following APIs:</p>\n<ul dir=\"auto\">\n<li>Manage codespaces access</li>\n<li>View org owned codespaces across repositories by user and cost</li>\n<li>Stop org owned codespaces across repositories</li>\n<li>Set repo level and org level secrets</li>\n<li>Configure prebuilds for desired repositories</li>\n<li>Set &amp; update policies across repositories</li>\n</ul>",
            "url": "https://github.com/github/roadmap/issues/484",
            "title": "Codespaces: APIs for organization administration ",
            "date_modified": "2022-04-13T20:46:14.000Z",
            "date_published": "2022-04-13T20:45:17.000Z",
            "author": {
                "name": "github-product-roadmap",
                "url": "https://github.com/github-product-roadmap"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/67656570?u=71034939d8d88be6d9b9068038dfdc8158fa69c0&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><h3 dir=\"auto\">Summary</h3>\n<p dir=\"auto\">In order to help teams migrate over from projects classic, we have a number of areas where we are working towards feature parity. Following on from our work <a href=\"https://github.com/github/roadmap/issues/287\" data-hovercard-type=\"issue\" data-hovercard-url=\"/github/roadmap/issues/287/hovercard\">last quarter</a>, in progress for this quarter are:</p>\n<ul class=\"contains-task-list\">\n<li class=\"task-list-item\"><input type=\"checkbox\" id=\"\" disabled=\"\" class=\"task-list-item-checkbox\"> Project events are included in issue / pull request timelines</li>\n<li class=\"task-list-item\"><input type=\"checkbox\" id=\"\" disabled=\"\" class=\"task-list-item-checkbox\"> Ability to delete a project</li>\n</ul>",
            "url": "https://github.com/github/roadmap/issues/483",
            "title": "Projects beta parity with projects classic (milestone 2)",
            "date_modified": "2022-04-13T20:46:13.000Z",
            "date_published": "2022-04-13T20:45:14.000Z",
            "author": {
                "name": "github-product-roadmap",
                "url": "https://github.com/github-product-roadmap"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/67656570?u=71034939d8d88be6d9b9068038dfdc8158fa69c0&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><h3 dir=\"auto\">Summary</h3>\n<p dir=\"auto\">Today we have a limited GraphQL API for projects beta, during this quarter we will both be expanding the API and improving how you can interact with it.</p>\n<h3 dir=\"auto\">How will it work?</h3>\n<p dir=\"auto\">This work will be split into two areas:</p>\n<p dir=\"auto\"><strong>1. Improving the coverage of the API</strong></p>\n<p dir=\"auto\">In addition to the existing API, you will be able to:</p>\n<ul dir=\"auto\">\n<li>Fetch the values of all fields in a project.</li>\n<li>Access the settings of iteration and single select field types.</li>\n<li>Fetch the configuration options for a given view.</li>\n<li>Fetch the values of all fields in a project, including linked pull requests.</li>\n<li>Fetch all items in a project, including draft issues.</li>\n<li>Given an item, the user can determine its type.</li>\n<li>Create draft issues.</li>\n<li>Re-order an item within a project.</li>\n</ul>\n<p dir=\"auto\"><strong>2. Create a new permissions scope for projects</strong></p>\n<p dir=\"auto\">This will simplify and reduce the amount of permissions you will need to request when generating an API token to work with projects.</p>",
            "url": "https://github.com/github/roadmap/issues/482",
            "title": "Projects beta GraphQL API",
            "date_modified": "2022-04-13T20:46:12.000Z",
            "date_published": "2022-04-13T20:45:12.000Z",
            "author": {
                "name": "github-product-roadmap",
                "url": "https://github.com/github-product-roadmap"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/67656570?u=71034939d8d88be6d9b9068038dfdc8158fa69c0&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><h3 dir=\"auto\">Summary</h3>\n<p dir=\"auto\">Automatic license sync enables you to manage license usage across your GitHub Enterprise deployments by automatically syncing user licenses from your GitHub Enterprise Server instance to GitHub Enterprise Cloud.</p>\n<p dir=\"auto\">In an effort to reduce enterprise administration of the license sync process, we are making improvements to the matching experience.</p>\n<h3 dir=\"auto\">Intended Outcome</h3>\n<p dir=\"auto\">The goal is to provide you with more clarity when viewing license sync results and total licenses consumed.</p>\n<h3 dir=\"auto\">How will it work?</h3>\n<p dir=\"auto\">Enterprise account owners will be presented with better license sync data and more details around licenses consumed.</p>",
            "url": "https://github.com/github/roadmap/issues/481",
            "title": "Automatic user license sync improvements",
            "date_modified": "2022-04-13T20:50:53.000Z",
            "date_published": "2022-03-15T22:46:33.000Z",
            "author": {
                "name": "github-product-roadmap",
                "url": "https://github.com/github-product-roadmap"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/67656570?u=71034939d8d88be6d9b9068038dfdc8158fa69c0&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><h3 dir=\"auto\">Summary</h3>\n<p dir=\"auto\">Today, when a repository with <a href=\"https://docs.github.com/en/enterprise-cloud@latest/repositories/managing-your-repositorys-settings-and-features/managing-repository-settings/setting-repository-visibility\">internal visibility</a> is forked, the fork is automatically created in the user's personal account space and its visibility is changed to private. With this feature, users will be able to fork an internal repository to an organization in the same enterprise, and the fork will retain its internal visibility.</p>\n<h3 dir=\"auto\">Intended Outcome</h3>\n<p dir=\"auto\">An obstacle to enterprise collaboration is that internal repositories cannot be forked without losing their internal visibility. Today when an internal repository is forked, it cannot be forked to an enterprise organization. It automatically becomes a private fork in the user’s personal account. Any collaborators must be granted explicit access to the user’s private fork. This feature will improve discoverability and open collaboration.</p>\n<h3 dir=\"auto\">How will it work?</h3>\n<p dir=\"auto\">When forking an internal repository, users will be able to choose which of the enterprise's organizations should receive the fork – similar to forking a public repository, except that:</p>\n<ol dir=\"auto\">\n<li>The destination organizations will be limited to those within the enterprise of the parent repository.</li>\n<li>The user will not be permitted to change the internal visibility of the fork while forking it.</li>\n</ol>\n<p dir=\"auto\"><a target=\"_blank\" rel=\"noopener noreferrer\" href=\"https://user-images.githubusercontent.com/1767415/127061527-d5633279-0fed-4bf5-8606-ce7c59ec8acc.png\"><img src=\"https://user-images.githubusercontent.com/1767415/127061527-d5633279-0fed-4bf5-8606-ce7c59ec8acc.png\" alt=\"image\" style=\"max-width: 100%;\"></a><br>\n<em>Screenshot provided for illustration purposes only. The actual user interface will be different.</em></p>",
            "url": "https://github.com/github/roadmap/issues/480",
            "title": "Fork internal repositories to enterprise organizations",
            "date_modified": "2022-04-13T20:55:36.000Z",
            "date_published": "2022-03-15T22:33:45.000Z",
            "author": {
                "name": "github-product-roadmap",
                "url": "https://github.com/github-product-roadmap"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/67656570?u=71034939d8d88be6d9b9068038dfdc8158fa69c0&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><h3 dir=\"auto\">Summary</h3>\n<p dir=\"auto\">Organizations need additional controls over how users can use codespaces. We've started providing policies for <a href=\"https://docs.github.com/en/codespaces/managing-codespaces-for-your-organization/restricting-access-to-machine-types\">controlling costs</a>, and this expands policies to include additional constraints that make codespaces more secure and complaint:</p>\n<ul dir=\"auto\">\n<li>Limiting what port forwarding visibility options can be used (e.g. \"disallow public port forwarding\")</li>\n<li>Limiting which regions can host codespaces (e.g. \"only allow Codespaces in western Europe\")</li>\n<li>Limiting the base container images that a codespace can be created from (e.g. \"only allow creation from approved container images\")</li>\n</ul>\n<h3 dir=\"auto\">Intended Outcome</h3>\n<p dir=\"auto\">As organizations start scaling with Codespaces, this enables organization admins to ensure codespaces are secure and compliant.</p>\n<h3 dir=\"auto\">How will it work?</h3>\n<p dir=\"auto\">All of these policies build off our policy framework, as first implemented with the \"<a href=\"https://github.blog/changelog/2022-01-10-codespaces-now-offers-organization-policies-to-restrict-machine-types/\" rel=\"nofollow\">allowed machine type</a>\" policy:</p>\n<p dir=\"auto\"><a target=\"_blank\" rel=\"noopener noreferrer\" href=\"https://user-images.githubusercontent.com/2575327/152439415-b750fd10-0ca9-4b66-a3b8-b5eb7ff0b623.png\"><img src=\"https://user-images.githubusercontent.com/2575327/152439415-b750fd10-0ca9-4b66-a3b8-b5eb7ff0b623.png\" alt=\"image\" style=\"max-width: 100%;\"></a></p>\n<h2 dir=\"auto\">Allowed port visibility options</h2>\n<p dir=\"auto\">Codespaces allows developers to forward ports from their codespace, for instance forwarding a web server on port 3000 to test an API or view a website under development. This port can be forwarded privately (just to the developer), to every signed in user in the organization, or publicly to anyone with the URL.</p>\n<p dir=\"auto\">This policy lets org admins restrict <code class=\"notranslate\">public</code> and <code class=\"notranslate\">org</code> visibility by disallowing those visibility options, making codespaces viewable only to authenticated users or only to the individual developer.</p>\n<p><a target=\"_blank\" rel=\"noopener noreferrer\" href=\"https://user-images.githubusercontent.com/30297258/155809598-72c44576-70f3-44e1-a051-c705ae3ec71c.png\"><img width=\"596\" alt=\"image\" src=\"https://user-images.githubusercontent.com/30297258/155809598-72c44576-70f3-44e1-a051-c705ae3ec71c.png\" style=\"max-width: 100%;\"></a></p>\n<h2 dir=\"auto\">Allowed regions</h2>\n<p dir=\"auto\">Codespaces currently pick the closest (lowest latency) region to the developer, which may be in any of our current regions.</p>\n<p dir=\"auto\">This policy lets org admins set allowed regions for codespaces to be created in, and will ensure that developers are routed to the closest allowed region only.</p>\n<h2 dir=\"auto\">Allowed base container images</h2>\n<p dir=\"auto\">Codespaces currently lets developers pick any container image for their dev container (or GitHub provides a base image with lots of common tools built in), as specified in their <code class=\"notranslate\">devcontainer.json</code>.</p>\n<p dir=\"auto\">This policy lets org admins provide a set of allowed base images (e.g. only allow specific<br>\nimages the organization has created and stored in GitHub Container Registry or Azure Container Registry) that can be used in Codespaces created in that org (or on a specific repo).</p>",
            "url": "https://github.com/github/roadmap/issues/479",
            "title": "Codespaces: Policies for Security/Compliance",
            "date_modified": "2022-04-13T20:49:32.000Z",
            "date_published": "2022-03-15T22:05:10.000Z",
            "author": {
                "name": "github-product-roadmap",
                "url": "https://github.com/github-product-roadmap"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/67656570?u=71034939d8d88be6d9b9068038dfdc8158fa69c0&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><h3 dir=\"auto\">Summary</h3>\n<p dir=\"auto\">This feature will allow admins to block two potentially dangerous Git commands that are difficult to recover from:</p>\n<ol dir=\"auto\">\n<li>\n<p dir=\"auto\"><code class=\"notranslate\">git push --mirror</code><br>\nThis is a potentially destructive command for making the remote exactly match the local clone. When run by accident, it can cause many branch deletes and force-pushes at the remote without a warning.</p>\n</li>\n<li>\n<p dir=\"auto\"><code class=\"notranslate\">git push --force</code> when <code class=\"notranslate\">push.default=matching</code><br>\nPrior to Git v2.0, the command <code class=\"notranslate\">git push --force</code> behaved like <code class=\"notranslate\">git push --mirror</code> because of the then-default Git configuration of <code class=\"notranslate\">push.default=matching</code>.</p>\n</li>\n</ol>\n<h3 dir=\"auto\">Intended Outcome</h3>\n<p dir=\"auto\">This feature will allow blocking potentially destructive <code class=\"notranslate\">--mirror</code> force pushes or pushes that include multiple branch rewrites.</p>\n<h3 dir=\"auto\">How will it work?</h3>\n<p dir=\"auto\">Admins will be able to enable or disable this feature in repository settings. When enabled, pushes will be rejected when they include multiple branch rewrites and the person who pushed will see an error.</p>\n<p><a target=\"_blank\" rel=\"noopener noreferrer\" href=\"https://user-images.githubusercontent.com/1767415/155635938-e56007bd-80f4-4fd7-808f-8779b74a8a29.png\"><img src=\"https://user-images.githubusercontent.com/1767415/155635938-e56007bd-80f4-4fd7-808f-8779b74a8a29.png\" height=\"200\" style=\"max-width: 100%;\"></a></p>",
            "url": "https://github.com/github/roadmap/issues/478",
            "title": "Admins can block pushes that destructively force push with --mirror",
            "date_modified": "2022-04-13T20:49:31.000Z",
            "date_published": "2022-03-15T22:05:07.000Z",
            "author": {
                "name": "github-product-roadmap",
                "url": "https://github.com/github-product-roadmap"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/67656570?u=71034939d8d88be6d9b9068038dfdc8158fa69c0&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><h3 dir=\"auto\">Summary</h3>\n<p dir=\"auto\">Today, many organizations have requirements for the naming of branches and tags. For example, a repository owner might require branch names to include the creating user's username in a pattern like <code class=\"notranslate\">/users/my-username</code>. But such requirements can be overlooked and are difficult to enforce. Users with write permission can create branches and tags with any name of their choosing.</p>\n<p dir=\"auto\">This feature will allow admins to configure required patterns for branch and tag names. Repository users will not be able to create branches and tags unless their names comply with these patterns.</p>\n<h3 dir=\"auto\">Intended Outcome</h3>\n<p dir=\"auto\">This will allow admins to block branches and tags from being created unless their names match configured patterns.</p>\n<h3 dir=\"auto\">How will it work?</h3>\n<p dir=\"auto\">Admins will be able to configure required patterns for branch and tag names. Repository users will see an error if they attempt to create branches or tags with names that don't comply with the patterns.</p>",
            "url": "https://github.com/github/roadmap/issues/477",
            "title": "Admins can block noncompliant branch and tag names",
            "date_modified": "2022-04-13T20:49:30.000Z",
            "date_published": "2022-03-15T22:05:04.000Z",
            "author": {
                "name": "github-product-roadmap",
                "url": "https://github.com/github-product-roadmap"
            }
        }
    ]
}