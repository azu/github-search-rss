{
    "version": "https://jsonfeed.org/version/1",
    "title": "github/roadmap Issues",
    "home_page_url": "https://azu.github.io/github-search-rss/github-roadmap.json",
    "feed_url": "https://azu.github.io/github-search-rss/github-roadmap.json",
    "description": "github/roadmap Issues on GitHub",
    "items": [
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/67656570?u=71034939d8d88be6d9b9068038dfdc8158fa69c0&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><h3 dir=\"auto\">Summary</h3>\n<p dir=\"auto\">Automatic license sync enables you to manage license usage across your GitHub Enterprise deployments by automatically syncing user licenses from your GitHub Enterprise Server instance to GitHub Enterprise Cloud.</p>\n<p dir=\"auto\">In an effort to reduce enterprise administration of the license sync process, we are making improvements to the matching experience.</p>\n<h3 dir=\"auto\">Intended Outcome</h3>\n<p dir=\"auto\">The goal is to provide you with more clarity when viewing license sync results and total licenses consumed.</p>\n<h3 dir=\"auto\">How will it work?</h3>\n<p dir=\"auto\">Enterprise account owners will be presented with better license sync data and more details around licenses consumed.</p>",
            "url": "https://github.com/github/roadmap/issues/481",
            "title": "Automatic user license sync improvements",
            "date_modified": "2022-03-15T22:55:32.000Z",
            "date_published": "2022-03-15T22:46:33.000Z",
            "author": {
                "name": "github-product-roadmap",
                "url": "https://github.com/github-product-roadmap"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/67656570?u=71034939d8d88be6d9b9068038dfdc8158fa69c0&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><h3 dir=\"auto\">Summary</h3>\n<p dir=\"auto\">Today, when a repository with <a href=\"https://docs.github.com/en/enterprise-cloud@latest/repositories/managing-your-repositorys-settings-and-features/managing-repository-settings/setting-repository-visibility\">internal visibility</a> is forked, the fork is automatically created in the user's personal account space and its visibility is changed to private. With this feature, users will be able to fork an internal repository to an organization in the same enterprise, and the fork will retain its internal visibility.</p>\n<h3 dir=\"auto\">Intended Outcome</h3>\n<p dir=\"auto\">An obstacle to enterprise collaboration is that internal repositories cannot be forked without losing their internal visibility. Today when an internal repository is forked, it cannot be forked to an enterprise organization. It automatically becomes a private fork in the user’s personal account. Any collaborators must be granted explicit access to the user’s private fork. This feature will improve discoverability and open collaboration.</p>\n<h3 dir=\"auto\">How will it work?</h3>\n<p dir=\"auto\">When forking an internal repository, users will be able to choose which of the enterprise's organizations should receive the fork – similar to forking a public repository, except that:</p>\n<ol dir=\"auto\">\n<li>The destination organizations will be limited to those within the enterprise of the parent repository.</li>\n<li>The user will not be permitted to change the internal visibility of the fork while forking it.</li>\n</ol>\n<p dir=\"auto\"><a target=\"_blank\" rel=\"noopener noreferrer\" href=\"https://user-images.githubusercontent.com/1767415/127061527-d5633279-0fed-4bf5-8606-ce7c59ec8acc.png\"><img src=\"https://user-images.githubusercontent.com/1767415/127061527-d5633279-0fed-4bf5-8606-ce7c59ec8acc.png\" alt=\"image\" style=\"max-width: 100%;\"></a><br>\n<em>Screenshot provided for illustration purposes only. The actual user interface will be different.</em></p>",
            "url": "https://github.com/github/roadmap/issues/480",
            "title": "Fork internal repositories to enterprise organizations",
            "date_modified": "2022-03-15T22:55:31.000Z",
            "date_published": "2022-03-15T22:33:45.000Z",
            "author": {
                "name": "github-product-roadmap",
                "url": "https://github.com/github-product-roadmap"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/67656570?u=71034939d8d88be6d9b9068038dfdc8158fa69c0&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><h3 dir=\"auto\">Summary</h3>\n<p dir=\"auto\">Organizations need additional controls over how users can use codespaces. We've started providing policies for <a href=\"https://docs.github.com/en/codespaces/managing-codespaces-for-your-organization/restricting-access-to-machine-types\">controlling costs</a>, and this expands policies to include additional constraints that make codespaces more secure and complaint:</p>\n<ul dir=\"auto\">\n<li>Limiting what port forwarding visibility options can be used (e.g. \"disallow public port forwarding\")</li>\n<li>Limiting which regions can host codespaces (e.g. \"only allow Codespaces in western Europe\")</li>\n<li>Limiting the base container images that a codespace can be created from (e.g. \"only allow creation from approved container images\")</li>\n</ul>\n<h3 dir=\"auto\">Intended Outcome</h3>\n<p dir=\"auto\">As organizations start scaling with Codespaces, this enables organization admins to ensure codespaces are secure and compliant.</p>\n<h3 dir=\"auto\">How will it work?</h3>\n<p dir=\"auto\">All of these policies build off our policy framework, as first implemented with the \"<a href=\"https://github.blog/changelog/2022-01-10-codespaces-now-offers-organization-policies-to-restrict-machine-types/\" rel=\"nofollow\">allowed machine type</a>\" policy:</p>\n<p dir=\"auto\"><a target=\"_blank\" rel=\"noopener noreferrer\" href=\"https://user-images.githubusercontent.com/2575327/152439415-b750fd10-0ca9-4b66-a3b8-b5eb7ff0b623.png\"><img src=\"https://user-images.githubusercontent.com/2575327/152439415-b750fd10-0ca9-4b66-a3b8-b5eb7ff0b623.png\" alt=\"image\" style=\"max-width: 100%;\"></a></p>\n<h2 dir=\"auto\">Allowed port visibility options</h2>\n<p dir=\"auto\">Codespaces allows developers to forward ports from their codespace, for instance forwarding a web server on port 3000 to test an API or view a website under development. This port can be forwarded privately (just to the developer), to every signed in user in the organization, or publicly to anyone with the URL.</p>\n<p dir=\"auto\">This policy lets org admins restrict <code>public</code> and <code>org</code> visibility by disallowing those visibility options, making codespaces viewable only to authenticated users or only to the individual developer.</p>\n<p><a target=\"_blank\" rel=\"noopener noreferrer\" href=\"https://user-images.githubusercontent.com/30297258/155809598-72c44576-70f3-44e1-a051-c705ae3ec71c.png\"><img width=\"596\" alt=\"image\" src=\"https://user-images.githubusercontent.com/30297258/155809598-72c44576-70f3-44e1-a051-c705ae3ec71c.png\" style=\"max-width: 100%;\"></a></p>\n<h2 dir=\"auto\">Allowed regions</h2>\n<p dir=\"auto\">Codespaces currently pick the closest (lowest latency) region to the developer, which may be in any of our current regions.</p>\n<p dir=\"auto\">This policy lets org admins set allowed regions for codespaces to be created in, and will ensure that developers are routed to the closest allowed region only.</p>\n<h2 dir=\"auto\">Allowed base container images</h2>\n<p dir=\"auto\">Codespaces currently lets developers pick any container image for their dev container (or GitHub provides a base image with lots of common tools built in), as specified in their <code>devcontainer.json</code>.</p>\n<p dir=\"auto\">This policy lets org admins provide a set of allowed base images (e.g. only allow specific<br>\nimages the organization has created and stored in GitHub Container Registry or Azure Container Registry) that can be used in Codespaces created in that org (or on a specific repo).</p>",
            "url": "https://github.com/github/roadmap/issues/479",
            "title": "Codespaces: Policies for Security/Compliance",
            "date_modified": "2022-04-05T20:11:23.000Z",
            "date_published": "2022-03-15T22:05:10.000Z",
            "author": {
                "name": "github-product-roadmap",
                "url": "https://github.com/github-product-roadmap"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/67656570?u=71034939d8d88be6d9b9068038dfdc8158fa69c0&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><h3 dir=\"auto\">Summary</h3>\n<p dir=\"auto\">This feature will allow admins to block two potentially dangerous Git commands that are difficult to recover from:</p>\n<ol dir=\"auto\">\n<li>\n<p dir=\"auto\"><code>git push --mirror</code><br>\nThis is a potentially destructive command for making the remote exactly match the local clone. When run by accident, it can cause many branch deletes and force-pushes at the remote without a warning.</p>\n</li>\n<li>\n<p dir=\"auto\"><code>git push --force</code> when <code>push.default=matching</code><br>\nPrior to Git v2.0, the command <code>git push --force</code> behaved like <code>git push --mirror</code> because of the then-default Git configuration of <code>push.default=matching</code>.</p>\n</li>\n</ol>\n<h3 dir=\"auto\">Intended Outcome</h3>\n<p dir=\"auto\">This feature will allow blocking potentially destructive <code>--mirror</code> force pushes or pushes that include multiple branch rewrites.</p>\n<h3 dir=\"auto\">How will it work?</h3>\n<p dir=\"auto\">Admins will be able to enable or disable this feature in repository settings. When enabled, pushes will be rejected when they include multiple branch rewrites and the person who pushed will see an error.</p>\n<p><a target=\"_blank\" rel=\"noopener noreferrer\" href=\"https://user-images.githubusercontent.com/1767415/155635938-e56007bd-80f4-4fd7-808f-8779b74a8a29.png\"><img src=\"https://user-images.githubusercontent.com/1767415/155635938-e56007bd-80f4-4fd7-808f-8779b74a8a29.png\" height=\"200\" style=\"max-width: 100%;\"></a></p>",
            "url": "https://github.com/github/roadmap/issues/478",
            "title": "Admins can block pushes that destructively force push with --mirror",
            "date_modified": "2022-03-15T22:55:29.000Z",
            "date_published": "2022-03-15T22:05:07.000Z",
            "author": {
                "name": "github-product-roadmap",
                "url": "https://github.com/github-product-roadmap"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/67656570?u=71034939d8d88be6d9b9068038dfdc8158fa69c0&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><h3 dir=\"auto\">Summary</h3>\n<p dir=\"auto\">Today, many organizations have requirements for the naming of branches and tags. For example, a repository owner might require branch names to include the creating user's username in a pattern like <code>/users/my-username</code>. But such requirements can be overlooked and are difficult to enforce. Users with write permission can create branches and tags with any name of their choosing.</p>\n<p dir=\"auto\">This feature will allow admins to configure required patterns for branch and tag names. Repository users will not be able to create branches and tags unless their names comply with these patterns.</p>\n<h3 dir=\"auto\">Intended Outcome</h3>\n<p dir=\"auto\">This will allow admins to block branches and tags from being created unless their names match configured patterns.</p>\n<h3 dir=\"auto\">How will it work?</h3>\n<p dir=\"auto\">Admins will be able to configure required patterns for branch and tag names. Repository users will see an error if they attempt to create branches or tags with names that don't comply with the patterns.</p>",
            "url": "https://github.com/github/roadmap/issues/477",
            "title": "Admins can block noncompliant branch and tag names",
            "date_modified": "2022-03-15T22:55:28.000Z",
            "date_published": "2022-03-15T22:05:04.000Z",
            "author": {
                "name": "github-product-roadmap",
                "url": "https://github.com/github-product-roadmap"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/67656570?u=71034939d8d88be6d9b9068038dfdc8158fa69c0&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><h3 dir=\"auto\">Summary</h3>\n<p dir=\"auto\">Today, many organizations have requirements for the contents of commit messages. For example, a repository owner might require commit messages to reference an issue or tracking number. But such requirements can be overlooked and are difficult to enforce. Users can commit changes to a repository with any commit message they choose.</p>\n<p dir=\"auto\">This feature will allow admins to configure required patterns for commit messages. Repository users will not be able to commit unless the commit messages comply with these patterns.</p>\n<h3 dir=\"auto\">Intended Outcome</h3>\n<p dir=\"auto\">This feature will allow admins to block commits unless their commit messages match certain patterns.</p>\n<h3 dir=\"auto\">How will it work?</h3>\n<p dir=\"auto\">Admins will be able to configure required patterns for commit messages. Repository users will see an error if they attempt to commit with a commit message that doesn't comply with the patterns.</p>",
            "url": "https://github.com/github/roadmap/issues/476",
            "title": "Admins can block commits with noncompliant messages",
            "date_modified": "2022-03-15T22:55:27.000Z",
            "date_published": "2022-03-15T22:05:01.000Z",
            "author": {
                "name": "github-product-roadmap",
                "url": "https://github.com/github-product-roadmap"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/67656570?u=71034939d8d88be6d9b9068038dfdc8158fa69c0&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><h3 dir=\"auto\">Summary</h3>\n<p dir=\"auto\">When GitHub Enterprise Cloud users create a repository, its location often defaults to the user's account. This increases risks of leaking enterprise data if the user adds such data to their repository.</p>\n<p dir=\"auto\">With this feature, enterprise admins will be able to configure a specific organization as the default repository creation location. Then, when users who are authenticated to the enterprise create a new repository, its default location will be the configured organization.</p>\n<h3 dir=\"auto\">Intended Outcome</h3>\n<p dir=\"auto\">This will reduce the risk of enterprise data being accidentally leaked.</p>\n<h3 dir=\"auto\">How will it work?</h3>\n<p dir=\"auto\">In enterprise settings, enterprise admins will have an option to configure a specific organization as the default repository creation location. Then, when enterprise users create a repository, its default location will be the configured organization. This mock-up shows how the enterprise setting might look:</p>\n<p dir=\"auto\"><a target=\"_blank\" rel=\"noopener noreferrer\" href=\"https://user-images.githubusercontent.com/1767415/154565432-211ff7a6-188d-429d-ab8e-5d63e21e3131.png\"><img src=\"https://user-images.githubusercontent.com/1767415/154565432-211ff7a6-188d-429d-ab8e-5d63e21e3131.png\" alt=\"image\" style=\"max-width: 100%;\"></a></p>\n<p dir=\"auto\">This table shows how repository creation behavior will change when configured as above.</p>\n<table role=\"table\">\n<thead>\n<tr>\n<th>Action</th>\n<th>Default repository location</th>\n<th>Default repository location when configured as above</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1. On the GitHub homepage (<a href=\"https://github.com/\">https://github.com/</a>) or a non-enterprise context, when a user clicks \"<strong>+</strong>\" on the page header and then <strong>New repository</strong></td>\n<td>The user's personal account</td>\n<td>The user's personal account</td>\n</tr>\n<tr>\n<td>2. In the context of a specific enterprise (<a href=\"https://github.com/intel-sandbox/\">https://github.com/intel-sandbox/</a>*) when a user clicks \"<strong>+</strong>\" on the page header and then <strong>New repository</strong></td>\n<td>The user's personal account</td>\n<td>The in-context enterprise's configured organization</td>\n</tr>\n<tr>\n<td>3. When a user clicks the <strong>New</strong> repository button on an organization overview page (this button is only visible if the user has permission to create repositories in the organization)</td>\n<td>The organization in which the <strong>New</strong> button was clicked</td>\n<td>The in-context enterprise's configured organization</td>\n</tr>\n<tr>\n<td>4. When a user clicks the <strong>Use this template</strong> on a template repository</td>\n<td>The user's personal account</td>\n<td>The in-context enterprise's configured organization</td>\n</tr>\n</tbody>\n</table>",
            "url": "https://github.com/github/roadmap/issues/475",
            "title": "Enterprise admins can set a specific organization as the default repository creation location",
            "date_modified": "2022-03-15T22:55:26.000Z",
            "date_published": "2022-03-15T22:04:58.000Z",
            "author": {
                "name": "github-product-roadmap",
                "url": "https://github.com/github-product-roadmap"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/67656570?u=71034939d8d88be6d9b9068038dfdc8158fa69c0&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><h3 dir=\"auto\">Summary</h3>\n<p dir=\"auto\">Precise code navigation – a convenience <a href=\"https://docs.github.com/en/repositories/working-with-files/using-files/navigating-code-on-github/\">already available for Python</a> – is coming for Java. When a developer views code on GitHub and clicks on a type name, method, function, or class instance, GitHub will allow navigation to the specific definition of that item. For example, if code calls a method named <code>constant()</code> and multiple classes have a method with that name, precise code navigation will automatically identify and navigate to the correct one that is referenced, as shown here:</p>\n<p dir=\"auto\"><a target=\"_blank\" rel=\"noopener noreferrer\" href=\"https://user-images.githubusercontent.com/1767415/148132001-6def6592-d898-4a5e-ae96-9215350539ea.png\"><img src=\"https://user-images.githubusercontent.com/1767415/148132001-6def6592-d898-4a5e-ae96-9215350539ea.png\" alt=\"image\" style=\"max-width: 100%;\"></a></p>\n<p dir=\"auto\">This is different than today's search-based navigation, where for these languages a developer might need to choose from multiple definitions with the same name, as shown here:</p>\n<p><a target=\"_blank\" rel=\"noopener noreferrer\" href=\"https://user-images.githubusercontent.com/1767415/130671189-e6a36f69-4199-4ee0-b985-388854716a43.png\"><img src=\"https://user-images.githubusercontent.com/1767415/130671189-e6a36f69-4199-4ee0-b985-388854716a43.png\" height=\"280\" style=\"max-width: 100%;\"></a></p>\n<h3 dir=\"auto\">Intended Outcome</h3>\n<p dir=\"auto\">Even when code contains multiple definitions with similar names, GitHub will support navigating to the specific definition that the code references. The code navigation engine knows the precise definition by indexing the code using <a href=\"https://github.blog/2021-12-09-introducing-stack-graphs/\" rel=\"nofollow\">stack graphs</a>.</p>\n<h3 dir=\"auto\">How will it work?</h3>\n<p dir=\"auto\">There will be no visual change to how code navigation works today except that for Java, developers will not be prompted to choose between multiple, similarly named definitions. Code navigation will know precisely which definition is referenced.</p>",
            "url": "https://github.com/github/roadmap/issues/474",
            "title": "Precise code navigation for Java",
            "date_modified": "2022-03-15T22:55:25.000Z",
            "date_published": "2022-03-15T22:04:55.000Z",
            "author": {
                "name": "github-product-roadmap",
                "url": "https://github.com/github-product-roadmap"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/67656570?u=71034939d8d88be6d9b9068038dfdc8158fa69c0&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><h3 dir=\"auto\">Summary</h3>\n<p dir=\"auto\">In ecosystems like npm where developers can indicate that a certain dependency is used during development only (a <code>devDependency</code>), developers have asked for a way to understand when Dependabot alerts are related only to a development dependency. In this initial ship, we expect to add support for a label on alerts that concern development dependencies to make it easier to filter, triage, or sort alerts.</p>\n<h3 dir=\"auto\">Intended Outcome</h3>\n<p dir=\"auto\"><em>No response</em></p>\n<h3 dir=\"auto\">How will it work?</h3>\n<p dir=\"auto\"><em>No response</em></p>",
            "url": "https://github.com/github/roadmap/issues/473",
            "title": "Expose information about development dependencies in Dependabot alerts",
            "date_modified": "2022-03-15T22:55:24.000Z",
            "date_published": "2022-03-15T22:04:52.000Z",
            "author": {
                "name": "github-product-roadmap",
                "url": "https://github.com/github-product-roadmap"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/67656570?u=71034939d8d88be6d9b9068038dfdc8158fa69c0&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><h3 dir=\"auto\">Summary</h3>\n<p dir=\"auto\">Dependency caching is one of the most effective ways to make jobs faster on GitHub Actions.<br>\nHowever, there is no great way to clear caches or debug issues with them. Also while we evict caches at a certain threshold limit, the cache performance can take a hit when the storage is near its quota. This prevents the broad adoption of our caching capability.</p>\n<p dir=\"auto\">We are now enabling a management experience for users to view and monitor their current cache storage usage within a Repository.</p>\n<h3 dir=\"auto\">Intended Outcome</h3>\n<ul dir=\"auto\">\n<li>GitHub Actions enables customers to cache intermediate outputs and dependencies for their workflows. Caching is an effective way to make jobs faster and a management experience for cache usage would further promote its adoption.</li>\n<li>Cache Management makes it easier to debug caching issues and provides greater control over cache usage by enabling users to view and delete existing caches.</li>\n<li>As we expand caching to ES and AE, a self-serve way will reduce support tickets by providing better ways to troubleshoot and debug corrupted caches.</li>\n</ul>\n<h3 dir=\"auto\">How will it work?</h3>\n<p dir=\"auto\">We will enable cache users to view and monitor their cache usage across all the workflows in their repository using APIs. Org admins would also be able to view the cache usage for each of the repositories in their org using an API.</p>",
            "url": "https://github.com/github/roadmap/issues/472",
            "title": "Actions: Ability to view cache usage (Cloud)",
            "date_modified": "2022-03-18T14:27:09.000Z",
            "date_published": "2022-02-09T18:28:33.000Z",
            "author": {
                "name": "github-product-roadmap",
                "url": "https://github.com/github-product-roadmap"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/67656570?u=71034939d8d88be6d9b9068038dfdc8158fa69c0&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><h3 dir=\"auto\">Summary</h3>\n<p dir=\"auto\">Dependency caching is one of the most effective ways to make jobs faster on GitHub Actions.<br>\nHowever, caches can often go corrupt, and there is no great way to clear caches or debug issues with them. Also while we evict caches at a certain threshold limit, the cache performance can take a hit when the storage is near its quota. All this generates significant support requests and prevents the broad adoption of our caching capability.</p>\n<p dir=\"auto\">We are now enabling a management experience for users to view and delete their existing caches and monitor their current cache storage usage within a Repository.</p>\n<h3 dir=\"auto\">Intended Outcome</h3>\n<ul dir=\"auto\">\n<li>GitHub Actions enables customers to cache intermediate outputs and dependencies for their workflows. Caching is an effective way to make jobs faster and a management experience for cache usage would further promote its adoption.</li>\n<li>Cache Management makes it easier to debug caching issues and provides greater control over cache usage by enabling users to view and delete existing caches.</li>\n<li>As we start supporting caching in ES and AE, a self-serve way will reduce support tickets by providing better ways to troubleshoot and debug corrupted caches.</li>\n</ul>\n<h3 dir=\"auto\">How will it work?</h3>\n<p dir=\"auto\">Once we enable Cache support in GHES, We will also be enabling a new Management experience (API based) to help cache users to view and monitor their cache usage across all the workflows in their repository.</p>",
            "url": "https://github.com/github/roadmap/issues/471",
            "title": "Actions: Management experience for Cache (Server) ",
            "date_modified": "2022-03-15T22:55:22.000Z",
            "date_published": "2022-02-09T18:28:30.000Z",
            "author": {
                "name": "github-product-roadmap",
                "url": "https://github.com/github-product-roadmap"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/67656570?u=71034939d8d88be6d9b9068038dfdc8158fa69c0&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><h3 dir=\"auto\">Summary</h3>\n<p dir=\"auto\">In addition to the text log actions will now be able to publish a markdown document that will be displayed on the run summary page.</p>\n<h3 dir=\"auto\">Intended Outcome</h3>\n<p dir=\"auto\">Actions like test runners, and linters often want to provide a richer experience for their output than is possible with simple text.</p>\n<h3 dir=\"auto\">How will it work?</h3>\n<p dir=\"auto\">An action author will have a new method in the toolkit that will let them write markdown formatted content to a summary file that is automatically created per action in a job.  On completion of each action the summary file is automatically uploaded and will be displayed on as part of the run summary.</p>",
            "url": "https://github.com/github/roadmap/issues/470",
            "title": "Actions:  Publish custom summary documents (Cloud)",
            "date_modified": "2022-03-15T22:55:21.000Z",
            "date_published": "2022-02-09T18:28:09.000Z",
            "author": {
                "name": "github-product-roadmap",
                "url": "https://github.com/github-product-roadmap"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/67656570?u=71034939d8d88be6d9b9068038dfdc8158fa69c0&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><h3 dir=\"auto\">Summary</h3>\n<p dir=\"auto\">In addition to the text log actions will now be able to publish a markdown document that will be displayed on the run summary page.</p>\n<h3 dir=\"auto\">Intended Outcome</h3>\n<p dir=\"auto\">Actions like test runners, and linters often want to provide a richer experience for their output than is possible with simple text.</p>\n<h3 dir=\"auto\">How will it work?</h3>\n<p dir=\"auto\">An action author will have a new method in the toolkit that will let them write markdown formatted content to a summary file that is automatically created per action in a job. On completion of each action the summary file is automatically uploaded and will be displayed on as part of the run summary.</p>",
            "url": "https://github.com/github/roadmap/issues/469",
            "title": "Actions: Publish custom summary documents (Server)",
            "date_modified": "2022-03-15T22:55:20.000Z",
            "date_published": "2022-02-09T18:26:49.000Z",
            "author": {
                "name": "github-product-roadmap",
                "url": "https://github.com/github-product-roadmap"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/67656570?u=71034939d8d88be6d9b9068038dfdc8158fa69c0&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><h3 dir=\"auto\">Summary</h3>\n<p dir=\"auto\">Starting this February, Visual Studio developers will be able to use GitHub Copilot technical preview by installing an extension from the <a href=\"https://marketplace.visualstudio.com/\" rel=\"nofollow\">marketplace.</a> In all manners, this extension will provide AI-powered autocomplete similar to GitHub Copilot extension already available for <a href=\"https://marketplace.visualstudio.com/items?itemName=GitHub.copilot\" rel=\"nofollow\">VS Code.</a></p>\n<h3 dir=\"auto\">Intended Outcome</h3>\n<p dir=\"auto\">Using Visual Studio and GitHub Copilot, developers will be able to:</p>\n<ul dir=\"auto\">\n<li>Generate multi-line suggestions based relevant to the context of your file and project.</li>\n<li>Convert comments to code. Write a comment describing the logic you want, and let GitHub Copilot assemble the code for you.</li>\n<li>Cycle through multiple suggestions. Pick the suggestion that best suits your application.</li>\n<li>Work with a broad set of frameworks and languages. The technical preview does especially well for Python, JavaScript, TypeScript, Ruby, Java, and Go, but it understands dozens of languages and can help you find your way around almost anything.</li>\n</ul>\n<h3 dir=\"auto\">How will it work?</h3>\n<p dir=\"auto\">After being admitted to the <a href=\"https://copilot.github.com\">GitHub Copilot technical preview</a>, Visual Studio developers should install the GitHub Copilot extension from the <a href=\"https://marketplace.visualstudio.com/\" rel=\"nofollow\">Marketplace.</a> Once installed, you'll be prompted to sign-in with your GitHub identity. After that, all you need to do is type in the code editor! GitHub Copilot will suggest multi-line code completions as you type. Hit \"tab\" to accept a suggestion.</p>\n<p dir=\"auto\">Illustration:<br>\n<a target=\"_blank\" rel=\"noopener noreferrer\" href=\"https://user-images.githubusercontent.com/16976466/151772017-5fd7d4f8-e7f2-46f3-abbf-744610561d82.gif\"><img src=\"https://user-images.githubusercontent.com/16976466/151772017-5fd7d4f8-e7f2-46f3-abbf-744610561d82.gif\" alt=\"Copilot_vs_UE_3\" style=\"max-width: 100%;\"></a><br>\n.</p>",
            "url": "https://github.com/github/roadmap/issues/468",
            "title": "GitHub Copilot extension for Visual Studio (technical preview)",
            "date_modified": "2022-03-15T22:55:19.000Z",
            "date_published": "2022-02-09T18:23:51.000Z",
            "author": {
                "name": "github-product-roadmap",
                "url": "https://github.com/github-product-roadmap"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/67656570?u=71034939d8d88be6d9b9068038dfdc8158fa69c0&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><p dir=\"auto\">The dependency graph today uses manifest parsing to understand the set of dependencies in a repository. This approach has some shortcomings: we can't easily support complex dependency systems which use executable code in the build to resolve dependencies (like Gradle), and users of an ecosystem need to wait for GitHub to add support for it.</p>\n<p dir=\"auto\">The dependencies API will allow users to upload details of their dependencies directly, via an API request. It will be designed to work with the output of build tools and package managers. The dependency graph will store this data and, if an ecosystem is supported in the <a href=\"https://github.com/advisories\">advisory database</a>, GitHub will send alerts if/when a vulnerable dependency is present.</p>\n<p dir=\"auto\">This release will be a public beta.</p>",
            "url": "https://github.com/github/roadmap/issues/467",
            "title": "Dependency graph: Dependencies API (Public Beta)",
            "date_modified": "2022-03-15T22:55:18.000Z",
            "date_published": "2022-02-09T18:23:47.000Z",
            "author": {
                "name": "github-product-roadmap",
                "url": "https://github.com/github-product-roadmap"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/67656570?u=71034939d8d88be6d9b9068038dfdc8158fa69c0&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><h3 dir=\"auto\">Summary</h3>\n<p dir=\"auto\">As part of our ongoing commitment to <a href=\"https://github.blog/2021-11-15-githubs-commitment-to-npm-ecosystem-security/\" rel=\"nofollow\">npm ecosystem security</a>, we have already rolled out enhanced login verification to all publishers on the npm registry. The next step in securing the accounts of publishers on the registry is to enforce the use of 2FA for all accounts with publishing rights to high-impact packages. The first phase of enforce will be the top 100 packages, by dependents, on February 1 2021.</p>\n<h3 dir=\"auto\">Intended Outcome</h3>\n<p dir=\"auto\">All publishers of the top-100 packages by dependents enrolled in mandatory 2FA.</p>\n<h3 dir=\"auto\">How will it work?</h3>\n<p dir=\"auto\">Once mandatory 2FA is enforced accounts with publish rights to the top-100 packages on the registry, by dependents, will have limited access to the registry and npmjs.com until they register a 2FA device.</p>",
            "url": "https://github.com/github/roadmap/issues/466",
            "title": "npm: Mandatory 2FA for top 100 packages",
            "date_modified": "2022-02-15T00:08:49.000Z",
            "date_published": "2022-02-09T18:21:29.000Z",
            "author": {
                "name": "github-product-roadmap",
                "url": "https://github.com/github-product-roadmap"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/67656570?u=71034939d8d88be6d9b9068038dfdc8158fa69c0&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><h3 dir=\"auto\">Summary</h3>\n<p dir=\"auto\">As part of our ongoing commitment to <a href=\"https://github.blog/2021-11-15-githubs-commitment-to-npm-ecosystem-security/\" rel=\"nofollow\">npm ecosystem security</a>, we have already rolled out enhanced login verification to all publishers on the npm registry. The next step in securing the accounts of publishers on the registry is to enforce the use of 2FA for all accounts with publishing rights to high-impact packages. The second phase of enforce will be the top 500 packages by dependents.</p>\n<h3 dir=\"auto\">Intended Outcome</h3>\n<p dir=\"auto\">All publishers of the top-500 packages by dependents enrolled in enforced 2FA</p>\n<h3 dir=\"auto\">How will it work?</h3>\n<p dir=\"auto\">Once mandatory 2FA is enforced accounts with publish rights to the top-500 packages on the registry, by dependents, will have limited access to the registry and npmjs.com until they register a 2FA device.</p>",
            "url": "https://github.com/github/roadmap/issues/465",
            "title": "npm: Enforcing 2FA for top 500 packages",
            "date_modified": "2022-03-15T22:55:17.000Z",
            "date_published": "2022-02-09T18:21:27.000Z",
            "author": {
                "name": "github-product-roadmap",
                "url": "https://github.com/github-product-roadmap"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/67656570?u=71034939d8d88be6d9b9068038dfdc8158fa69c0&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><h3 dir=\"auto\">Summary</h3>\n<p dir=\"auto\">As part of our ongoing commitment to <a href=\"https://github.blog/2021-11-15-githubs-commitment-to-npm-ecosystem-security/\" rel=\"nofollow\">npm ecosystem security</a>, we have already rolled out enhanced login verification to all publishers on the npm registry. The next step in securing the accounts of publishers on the registry is to enforce the use of 2FA for all accounts with publishing rights to high-impact packages. The third phase in this is to roll out 2FA for all \"High-Impact Projects\".</p>\n<h3 dir=\"auto\">Intended Outcome</h3>\n<p dir=\"auto\">All \"High-Impact Projects\" are enrolled in enforced 2FA</p>\n<h3 dir=\"auto\">How will it work?</h3>\n<p dir=\"auto\">Once mandatory 2FA is enforced accounts with publish rights to the top-100 packages on the registry, by dependents, will have limited access to the registry and npmjs.com until they register a 2FA device.</p>",
            "url": "https://github.com/github/roadmap/issues/464",
            "title": "npm: Enforcing 2FA for high-impact projects",
            "date_modified": "2022-03-15T22:55:16.000Z",
            "date_published": "2022-02-09T18:21:23.000Z",
            "author": {
                "name": "github-product-roadmap",
                "url": "https://github.com/github-product-roadmap"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/67656570?u=71034939d8d88be6d9b9068038dfdc8158fa69c0&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><h3 dir=\"auto\">Summary</h3>\n<p dir=\"auto\">As part of our ongoing commitment to <a href=\"https://github.blog/2021-11-15-githubs-commitment-to-npm-ecosystem-security/\" rel=\"nofollow\">npm ecosystem security</a> we are expanding the options for 2FA by implementing <a href=\"https://webauthn.guide/\" rel=\"nofollow\">WebAuthn</a> support on npmjs.com.</p>\n<h3 dir=\"auto\">Intended Outcome</h3>\n<p dir=\"auto\">npm account holders will be able to use WebAuthn to add security keys and biometric devices as 2FA sources for authentication to the regisry, publishing of packages, and any other operations that require an addiional factor of authentication.</p>\n<h3 dir=\"auto\">How will it work?</h3>\n<p dir=\"auto\">We will do a complete overhaul of 2FA management on npmjs.com adding support for a variety of 2FA authentication options in npmjs.com account settings. When authenticating through npmjs.com customers will be able to use registered security keys and biometric devices in addition to Authentication Applications, as part of the authentication flow. If an account has enabled 2FA for publishing pacakges they will be propted to visit a unique URL to go through the WebAuthN flow if they do not want to use an Authentication Device (TOTP).</p>\n<p dir=\"auto\">Customers will still be able to use authentication tokens to publish without 2FA if they desire for setting up automated workflows.</p>",
            "url": "https://github.com/github/roadmap/issues/463",
            "title": "npm: Add WebAuthn support",
            "date_modified": "2022-03-15T22:55:15.000Z",
            "date_published": "2022-02-09T18:21:20.000Z",
            "author": {
                "name": "github-product-roadmap",
                "url": "https://github.com/github-product-roadmap"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/67656570?u=71034939d8d88be6d9b9068038dfdc8158fa69c0&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><h3 dir=\"auto\">Summary</h3>\n<p dir=\"auto\">Many GitHub Enterprise Server customers have teams and CI farms located all around the world. The GitHub repository cache will mirror repositories near these clients, reducing latency and bandwidth required to support geographically-distributed teams while also reducing load on the primary instance.</p>\n<h3 dir=\"auto\">Intended Outcome</h3>\n<p dir=\"auto\">Massive read load from very large CI farms can affect performance on the customer's GitHub Enterprise Server. This degrades the developer experience - fetches, pushes, merges, and even non-Git features can be slowed down when load is high. Also, there's no reason to transmit the same Git data over and over again via a long-haul network link. The repository cache helps customers reduce bandwidth consumed on long, possibly intercontinental networks. It also helps customers serve their CI and automation needs from a dedicated host, reducing the load on the primary GHES and improving the experience for users of the primary.</p>\n<h3 dir=\"auto\">How will it work?</h3>\n<p dir=\"auto\">The repository cache listens to the primary instance (whether that's a single GHES server, a geo-replicated set of instances, or a cluster configuration) for changes to Git data. CI farms and other read-heavy consumers clone and fetch from the cache server instead of the primary instance. Changes are propagated across the network once per cache instance rather than once per client.</p>",
            "url": "https://github.com/github/roadmap/issues/462",
            "title": "Repository cache for GHES",
            "date_modified": "2022-02-09T18:22:30.000Z",
            "date_published": "2022-02-09T18:21:18.000Z",
            "author": {
                "name": "github-product-roadmap",
                "url": "https://github.com/github-product-roadmap"
            }
        }
    ]
}