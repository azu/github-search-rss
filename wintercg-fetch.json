{
    "version": "https://jsonfeed.org/version/1",
    "title": "wintercg/fetch Issues",
    "home_page_url": "https://azu.github.io/github-search-rss/wintercg-fetch.json",
    "feed_url": "https://azu.github.io/github-search-rss/wintercg-fetch.json",
    "description": "wintercg/fetch Issues on GitHub",
    "items": [
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/16144158?u=82cadd66bfcfcd8340269a3c0ce30f503acaf7b4&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><p dir=\"auto\">As promised a few calls ago, I have been working on drafting the initial specification for WinterCG Fetch. I've had many discussions with multiple folks and I have arrived at two options for us. I'd like us to decide on one of them as the organization structure for our specification. Once agreed; I will continue <a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load title\" data-id=\"1371464266\" data-permission-text=\"Title is private\" data-url=\"https://github.com/wintercg/fetch/issues/11\" data-hovercard-type=\"pull_request\" data-hovercard-url=\"/wintercg/fetch/pull/11/hovercard\" href=\"https://github.com/wintercg/fetch/pull/11\">#11</a> and get our base line specification published.</p>\n<h3 dir=\"auto\">Option 1</h3>\n<p dir=\"auto\">The first option is to create a fork of <code class=\"notranslate\">whatwg/fetch</code> here in wintercg. We will utilize aspects of the <a href=\"https://tabatkins.github.io/bikeshed/\" rel=\"nofollow\">Bikeshed</a> language (which is what <code class=\"notranslate\">whatwg/fetch</code> is written in) to omit sections and include notes/extensions for aspects that we want to modify.</p>\n<p dir=\"auto\">We will be responsible for rebasing our modifications every time Fetch lands a change to the specification. This could be partially automated where we create a bot that watches the <code class=\"notranslate\">whatwg/fetch</code> repo, and anytime new commit(s) are merged to <code class=\"notranslate\">main</code>, it would open a branch and attempts to do the necessary git operations. Of course, if there are merge conflicts they would need to be settled by a contributor here in WinterCG.</p>\n<p dir=\"auto\">This will ensure our specification is always up to date with the latest whatwg version.</p>\n<p dir=\"auto\">This option has a long-term maintenance cost where members of WinterCG would be responsible for managing the rebasing overtime. As stated, it could be automated, but it wouldn't be a perfect solution as whenever conflicts arise someone would have to spend time fixing them.</p>\n<h3 dir=\"auto\">Option 2</h3>\n<p dir=\"auto\">The second option is to start with essentially an empty specification that states something along the lines of: \"Unless otherwise specified in this document, WinterCG Fetch is compatible with the latest edition of WHATWG Fetch specification\". Then, overtime as we agree on modifications to <code class=\"notranslate\">whatwg/fetch</code>, we will create new sections within our document that states the necessary changes. For example, lets pretend we agree to get rid of the entire concept of \"Forbidden Headers\". Our specification may include a section such as:</p>\n<blockquote>\n<p dir=\"auto\">Please note this is purely for demonstration purposes. The WinterCG has made no decisions regarding modifications to the Whatwg Fetch API and the content in the following example is purely hypothetical. Do not use this issue thread to discuss the nuance of the example.</p>\n</blockquote>\n<div class=\"snippet-clipboard-content notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"### Headers\n\n#### Modification of Forbidden Headers List\n\nSection [2.2.2 Headers #forbidden-header-name](https://fetch.spec.whatwg.org/#forbidden-header-name) of the whatwg/fetch specification states a list of header names that are considered &quot;forbidden&quot;. During runtime execution of the Fetch API, usage of a forbidden header results in an early return such as in the [Concept Headers append](https://fetch.spec.whatwg.org/#concept-headers-append) section.\n\nWinterCG Fetch deviates from this section by stating that there are **no** forbidden headers. A WinterCG Fetch API will not return early if it encounters one of these headers.\"><pre class=\"notranslate\"><code>### Headers\n\n#### Modification of Forbidden Headers List\n\nSection [2.2.2 Headers #forbidden-header-name](https://fetch.spec.whatwg.org/#forbidden-header-name) of the whatwg/fetch specification states a list of header names that are considered \"forbidden\". During runtime execution of the Fetch API, usage of a forbidden header results in an early return such as in the [Concept Headers append](https://fetch.spec.whatwg.org/#concept-headers-append) section.\n\nWinterCG Fetch deviates from this section by stating that there are **no** forbidden headers. A WinterCG Fetch API will not return early if it encounters one of these headers.\n</code></pre></div>\n<p dir=\"auto\">This option has less maintenance burden as it could essentially stagnate while remaining \"up to date\". With the catch all statement stating that essentially WinterCG Fetch <strong>is</strong> WHATWG Fetch unless otherwise noted. The WHATWG Fetch could land changes and unless we need to deviate from those changes, we don't have to modify our specification.</p>\n<p dir=\"auto\">Unfortunately, this also means that if we are not on top of changes to WHATWG Fetch, we could incorrectly be supporting something they add that we want to deviate from. Arguably, implementations don't generally move as quickly as standards. And so even if there is a bit of a lag between us coming to decision on a hypothetical change to WHATWG Fetch, many implementers would already be apart of the conversation and it wouldn't have much impact.</p>\n<hr>\n<p dir=\"auto\">With these two options, please react to this post with which one you prefer more to give us a sense of what folks are preferring. We will also be discussing this at upcoming wintercg calls. When we come to a majority decision I will create the initial proposal draft. In the mean time, we can being making API decisions for WinterCG Fetch - capture the result in issues, and when we eventually get our proposal created, I can add those decisions to the initial draft. Also please feel free to use this issue to discuss details of either option too.</p>\n<p dir=\"auto\">Thank you!</p>\n<p dir=\"auto\">Option 1 - react with: <g-emoji class=\"g-emoji\" alias=\"smile\" fallback-src=\"https://github.githubassets.com/images/icons/emoji/unicode/1f604.png\">ðŸ˜„</g-emoji></p>\n<p dir=\"auto\">Option 2 - react with: <g-emoji class=\"g-emoji\" alias=\"rocket\" fallback-src=\"https://github.githubassets.com/images/icons/emoji/unicode/1f680.png\">ðŸš€</g-emoji></p>",
            "url": "https://github.com/wintercg/fetch/issues/12",
            "title": "Specification outline",
            "date_modified": "2022-10-19T21:40:41.000Z",
            "date_published": "2022-10-19T21:40:11.000Z",
            "author": {
                "name": "Ethan-Arrowood",
                "url": "https://github.com/Ethan-Arrowood"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/439929?u=88483145a53c3d594ab68146c1a8bdecc3bcd1d3&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><p dir=\"auto\">Within Workers we have been having a discussion about how to communicate to users via Errors that the conditions leading to an error are temporary and that the user should retry their operation. The how and when to retry is not important here.</p>\n<p dir=\"auto\">For example, a <code class=\"notranslate\">fetch()</code> promise can fail for many reasons. The network path could temporarily be down, the URL could be blocked, the header could be malformated, etc. We want to be able to clearly indicate that the user can/should retry their operation <em>without</em> requiring that the user resort to parsing the error message.</p>\n<p dir=\"auto\">We have several possible paths forward, all of which have the same fundamental problem. We'd like to get consensus on which approach folks would find the most agreeable.</p>\n<h2 dir=\"auto\">Option 1: New error types</h2>\n<div class=\"highlight highlight-source-js notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"const err = new Error('an error occurred');\nObject.defineProperty(err, 'name', { value: 'RetriableError' });\"><pre><span class=\"pl-k\">const</span> <span class=\"pl-s1\">err</span> <span class=\"pl-c1\">=</span> <span class=\"pl-k\">new</span> <span class=\"pl-v\">Error</span><span class=\"pl-kos\">(</span><span class=\"pl-s\">'an error occurred'</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-v\">Object</span><span class=\"pl-kos\">.</span><span class=\"pl-en\">defineProperty</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">err</span><span class=\"pl-kos\">,</span> <span class=\"pl-s\">'name'</span><span class=\"pl-kos\">,</span> <span class=\"pl-kos\">{</span> <span class=\"pl-c1\">value</span>: <span class=\"pl-s\">'RetriableError'</span> <span class=\"pl-kos\">}</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">;</span></pre></div>\n<h2 dir=\"auto\">Option 2: Non-standard own properties on <code class=\"notranslate\">Error</code></h2>\n<div class=\"highlight highlight-source-js notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"const err = new Error('an error occurred');\nerr.retriable = true;\"><pre><span class=\"pl-k\">const</span> <span class=\"pl-s1\">err</span> <span class=\"pl-c1\">=</span> <span class=\"pl-k\">new</span> <span class=\"pl-v\">Error</span><span class=\"pl-kos\">(</span><span class=\"pl-s\">'an error occurred'</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-s1\">err</span><span class=\"pl-kos\">.</span><span class=\"pl-c1\">retriable</span> <span class=\"pl-c1\">=</span> <span class=\"pl-c1\">true</span><span class=\"pl-kos\">;</span></pre></div>\n<h2 dir=\"auto\">Option 3: Using <code class=\"notranslate\">cause</code></h2>\n<div class=\"highlight highlight-source-js notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"const err = new Error('an error occured', { cause: { retriable: true } })\"><pre><span class=\"pl-k\">const</span> <span class=\"pl-s1\">err</span> <span class=\"pl-c1\">=</span> <span class=\"pl-k\">new</span> <span class=\"pl-v\">Error</span><span class=\"pl-kos\">(</span><span class=\"pl-s\">'an error occured'</span><span class=\"pl-kos\">,</span> <span class=\"pl-kos\">{</span> <span class=\"pl-c1\">cause</span>: <span class=\"pl-kos\">{</span> <span class=\"pl-c1\">retriable</span>: <span class=\"pl-c1\">true</span> <span class=\"pl-kos\">}</span> <span class=\"pl-kos\">}</span><span class=\"pl-kos\">)</span></pre></div>\n<h2 dir=\"auto\">Option 4: Using <code class=\"notranslate\">AggregateError</code></h2>\n<div class=\"highlight highlight-source-js notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"// The first object is always an error but the additional things communicate\n// the additional structured information we want.\nconst err = new AggregateError([\n  new Error('an error occurred'),\n  { retriable: true }\n])\"><pre><span class=\"pl-c\">// The first object is always an error but the additional things communicate</span>\n<span class=\"pl-c\">// the additional structured information we want.</span>\n<span class=\"pl-k\">const</span> <span class=\"pl-s1\">err</span> <span class=\"pl-c1\">=</span> <span class=\"pl-k\">new</span> <span class=\"pl-v\">AggregateError</span><span class=\"pl-kos\">(</span><span class=\"pl-kos\">[</span>\n  <span class=\"pl-k\">new</span> <span class=\"pl-v\">Error</span><span class=\"pl-kos\">(</span><span class=\"pl-s\">'an error occurred'</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">,</span>\n  <span class=\"pl-kos\">{</span> <span class=\"pl-c1\">retriable</span>: <span class=\"pl-c1\">true</span> <span class=\"pl-kos\">}</span>\n<span class=\"pl-kos\">]</span><span class=\"pl-kos\">)</span></pre></div>\n<h2 dir=\"auto\">Option 5: ??</h2>\n<p dir=\"auto\">Other ideas?</p>\n<h2 dir=\"auto\">Current Thinking</h2>\n<p dir=\"auto\">My current thinking here is to prefer Option 3, using the <code class=\"notranslate\">cause</code> property.</p>\n<p dir=\"auto\">Specifically, pulling out to a logical level: The purpose of the <code class=\"notranslate\">cause</code> is to communicate the reason for this error. That reason might be that another <code class=\"notranslate\">Error</code> was thrown, or it might be that some other condition occurred. For instance, the network was down, or there was an internal error, etc. So let's differentiate between <code class=\"notranslate\">Error</code> and <code class=\"notranslate\">Condition</code>.</p>\n<p dir=\"auto\">If I have a transient condition and want to communicate that the user should retry their operation, then I could logically do something like:</p>\n<div class=\"highlight highlight-source-js notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"cont condition = {\n  // The condition is temporary....\n  transient: true,\n  // The operation is retriable...\n  retriable: true,\n};\nconst err = new Error('oops that failed', { cause: condition });\"><pre><span class=\"pl-s1\">cont</span> <span class=\"pl-s1\">condition</span> <span class=\"pl-c1\">=</span> <span class=\"pl-kos\">{</span>\n  <span class=\"pl-c\">// The condition is temporary....</span>\n  <span class=\"pl-c1\">transient</span>: <span class=\"pl-c1\">true</span><span class=\"pl-kos\">,</span>\n  <span class=\"pl-c\">// The operation is retriable...</span>\n  <span class=\"pl-c1\">retriable</span>: <span class=\"pl-c1\">true</span><span class=\"pl-kos\">,</span>\n<span class=\"pl-kos\">}</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-k\">const</span> <span class=\"pl-s1\">err</span> <span class=\"pl-c1\">=</span> <span class=\"pl-k\">new</span> <span class=\"pl-v\">Error</span><span class=\"pl-kos\">(</span><span class=\"pl-s\">'oops that failed'</span><span class=\"pl-kos\">,</span> <span class=\"pl-kos\">{</span> <span class=\"pl-c1\">cause</span>: <span class=\"pl-s1\">condition</span> <span class=\"pl-kos\">}</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">;</span></pre></div>\n<p dir=\"auto\">The challenge with this, of course, is interoperability. If workers chooses to use <code class=\"notranslate\">cause</code> in this way but other <code class=\"notranslate\">fetch()</code> implementations choose to use <code class=\"notranslate\">cause</code> in other ways then we can run into interop issues. To be clear, <em>ALL</em> of the options suffer from this exact problem.</p>\n<h2 dir=\"auto\">Proposal</h2>\n<p dir=\"auto\">The proposal I would like to make is to define a new <code class=\"notranslate\">ErrorCondition</code> interface specifically for use with <code class=\"notranslate\">cause</code></p>\n<p dir=\"auto\">Essentially (treat this as a discussion example to express intent... the <em>actual</em> proposal can be refined):</p>\n<div class=\"snippet-clipboard-content notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"dictionary ErrorConditionInit {\n  boolean transient = false;\n  boolean retriable = false;\n  DOMString name = &quot;&quot;;\n};\n\ninterface ErrorCondition {\n  constructor(optional DOMString message = &quot;&quot;, optional ConditionInit init = {});\n  readonly attribute boolean transient;\n  readonly attribute boolean retriable;\n  readonly attribute DOMString name;\n  readonly attribute DOMString message;\n}\"><pre class=\"notranslate\"><code>dictionary ErrorConditionInit {\n  boolean transient = false;\n  boolean retriable = false;\n  DOMString name = \"\";\n};\n\ninterface ErrorCondition {\n  constructor(optional DOMString message = \"\", optional ConditionInit init = {});\n  readonly attribute boolean transient;\n  readonly attribute boolean retriable;\n  readonly attribute DOMString name;\n  readonly attribute DOMString message;\n}\n</code></pre></div>\n<p dir=\"auto\">Note that this interface <em>intentionally</em> mimics <code class=\"notranslate\">DOMException</code> with the inclusion of a <code class=\"notranslate\">name</code> and <code class=\"notranslate\">message</code> accessors.</p>\n<p dir=\"auto\">Example use (assuming the proposal to add <code class=\"notranslate\">cause</code> to <code class=\"notranslate\">DOMException</code> goes through):</p>\n<div class=\"snippet-clipboard-content notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"const err = new DOMException('The operation failed', {\n  name: 'NETWORK_ERR',\n  cause: new ErrorCondition('The network path is down', {\n    transient: true,\n    retriable: true,\n  })\n});\n\nconsole.log(err.cause.transient);  // true\nconsole.log(err.cause.retriable); // true\"><pre class=\"notranslate\"><code>const err = new DOMException('The operation failed', {\n  name: 'NETWORK_ERR',\n  cause: new ErrorCondition('The network path is down', {\n    transient: true,\n    retriable: true,\n  })\n});\n\nconsole.log(err.cause.transient);  // true\nconsole.log(err.cause.retriable); // true\n</code></pre></div>\n<p dir=\"auto\">To be clear, I don't really have strong opinions on exactly how we solve this use case. My only requirement is that we have a mechanism for reliably communicating transient/retriable conditions that is interoperable across runtimes.</p>\n<h2 dir=\"auto\">Some questions</h2>\n<ol dir=\"auto\">\n<li>How are retriable errors like this handled elsewhere on the web?</li>\n</ol>",
            "url": "https://github.com/wintercg/fetch/issues/10",
            "title": "Error conditions, retry, and Error.cause",
            "date_modified": "2022-09-10T22:02:02.000Z",
            "date_published": "2022-09-08T18:15:41.000Z",
            "author": {
                "name": "jasnell",
                "url": "https://github.com/jasnell"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/8225977?u=ebf8bbc30918fe9c36833005bebc027a65984f34&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><p dir=\"auto\">The fetch spec includes APIs for interacting with form submissions. For example, there is the <code class=\"notranslate\">Request</code> and <code class=\"notranslate\">Response</code> constructors accepting <a href=\"https://url.spec.whatwg.org/#interface-urlsearchparams\" rel=\"nofollow\"><code class=\"notranslate\">URLSearchParams</code></a> and <a href=\"https://xhr.spec.whatwg.org/#interface-formdata\" rel=\"nofollow\"><code class=\"notranslate\">FormData</code></a> objects as the request/response body, which is generally useful and is expected to be part of the common minimum API.</p>\n<p dir=\"auto\">However, the fetch spec also defines the <a href=\"https://fetch.spec.whatwg.org/#dom-body-formdata\" rel=\"nofollow\"><code class=\"notranslate\">formData()</code></a> method of the <code class=\"notranslate\">Body</code> interface mixin, which is included in <code class=\"notranslate\">Request</code> and <code class=\"notranslate\">Response</code>. This method parses the HTTP body as a form submission enctype (either <code class=\"notranslate\">application/x-www-form-urlencoded</code> or <code class=\"notranslate\">multipart/form-data</code>) and returns a <code class=\"notranslate\">FormData</code> object. Since form submission bodies only generally make sense as requests, and it's rarely useful to parse a request body from an HTTP client, it wouldn't make much sense to include this method as part of the common minimum API â€“ but it is certainly useful for fetch-based HTTP server APIs, as Deno and CFW have.</p>\n<p dir=\"auto\">For <code class=\"notranslate\">multipart/form-data</code> parsing, however, this method leaves things almost completely unspecified. While there is a formal definition of this format (in <a href=\"https://www.rfc-editor.org/rfc/rfc7578\" rel=\"nofollow\">RFC7578</a>, which relies on <a href=\"https://www.rfc-editor.org/rfc/rfc2046#section-5.1\" rel=\"nofollow\">the <code class=\"notranslate\">multipart</code> definitions in RFC2046</a>), it is in the form of an ABNF grammar rather than a parsing algorithms, and so different implementations differ in how they parse some input.</p>\n<p dir=\"auto\">What's more, browsers have not always escaped field names and filenames in <code class=\"notranslate\">multipart/form-data</code> payloads in the same way. For example, until last year Firefox escaped double quotes by prepending a backslash, and newlines by turning them into spaces; while Chromium and Webkit used percent-encoding. And while this percent-encoding behavior was added to the HTML spec (<a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load title\" data-id=\"784103377\" data-permission-text=\"Title is private\" data-url=\"https://github.com/whatwg/html/issues/6282\" data-hovercard-type=\"pull_request\" data-hovercard-url=\"/whatwg/html/pull/6282/hovercard\" href=\"https://github.com/whatwg/html/pull/6282\">whatwg/html#6282</a>), and FIrefox's behavior fixed in turn, no implementation of the parsing that I'm aware of (including Chromium and Webkit!) decode the percent-encoding escapes:</p>\n<div class=\"highlight highlight-source-js notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"const original = new FormData();\noriginal.set('a&quot;b', &quot;&quot;);\noriginal.set('c&quot;d', new File([], 'e&quot;f'));\nlog(original);  // a&quot;b c&quot;d e&quot;f\n\nconst parsed = await new Response(original).formData();\nlog(parsed);  // a%22b c%22d e%22f\n// (In CFW it's a%22b c%22d undefined, because it seems like files are not\n// distinguished from non-file values when parsing.)\n\nfunction log(formdata) {\n  // FormData is pair-iterable.\n  const entries = [...formdata];\n  const firstEntryName = entries[0][0];\n  const secondEntryName = entries[1][0];\n  const secondEntryFilename = entries[1][1].name;\n  console.log(firstEntryName, secondEntryName, secondEntryFilename);\n}\"><pre><span class=\"pl-k\">const</span> <span class=\"pl-s1\">original</span> <span class=\"pl-c1\">=</span> <span class=\"pl-k\">new</span> <span class=\"pl-v\">FormData</span><span class=\"pl-kos\">(</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-s1\">original</span><span class=\"pl-kos\">.</span><span class=\"pl-en\">set</span><span class=\"pl-kos\">(</span><span class=\"pl-s\">'a\"b'</span><span class=\"pl-kos\">,</span> <span class=\"pl-s\">\"\"</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-s1\">original</span><span class=\"pl-kos\">.</span><span class=\"pl-en\">set</span><span class=\"pl-kos\">(</span><span class=\"pl-s\">'c\"d'</span><span class=\"pl-kos\">,</span> <span class=\"pl-k\">new</span> <span class=\"pl-v\">File</span><span class=\"pl-kos\">(</span><span class=\"pl-kos\">[</span><span class=\"pl-kos\">]</span><span class=\"pl-kos\">,</span> <span class=\"pl-s\">'e\"f'</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-en\">log</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">original</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">;</span>  <span class=\"pl-c\">// a\"b c\"d e\"f</span>\n\n<span class=\"pl-k\">const</span> <span class=\"pl-s1\">parsed</span> <span class=\"pl-c1\">=</span> <span class=\"pl-k\">await</span> <span class=\"pl-k\">new</span> <span class=\"pl-v\">Response</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">original</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">.</span><span class=\"pl-en\">formData</span><span class=\"pl-kos\">(</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-en\">log</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">parsed</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">;</span>  <span class=\"pl-c\">// a%22b c%22d e%22f</span>\n<span class=\"pl-c\">// (In CFW it's a%22b c%22d undefined, because it seems like files are not</span>\n<span class=\"pl-c\">// distinguished from non-file values when parsing.)</span>\n\n<span class=\"pl-k\">function</span> <span class=\"pl-en\">log</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">formdata</span><span class=\"pl-kos\">)</span> <span class=\"pl-kos\">{</span>\n  <span class=\"pl-c\">// FormData is pair-iterable.</span>\n  <span class=\"pl-k\">const</span> <span class=\"pl-s1\">entries</span> <span class=\"pl-c1\">=</span> <span class=\"pl-kos\">[</span>...<span class=\"pl-s1\">formdata</span><span class=\"pl-kos\">]</span><span class=\"pl-kos\">;</span>\n  <span class=\"pl-k\">const</span> <span class=\"pl-s1\">firstEntryName</span> <span class=\"pl-c1\">=</span> <span class=\"pl-s1\">entries</span><span class=\"pl-kos\">[</span><span class=\"pl-c1\">0</span><span class=\"pl-kos\">]</span><span class=\"pl-kos\">[</span><span class=\"pl-c1\">0</span><span class=\"pl-kos\">]</span><span class=\"pl-kos\">;</span>\n  <span class=\"pl-k\">const</span> <span class=\"pl-s1\">secondEntryName</span> <span class=\"pl-c1\">=</span> <span class=\"pl-s1\">entries</span><span class=\"pl-kos\">[</span><span class=\"pl-c1\">1</span><span class=\"pl-kos\">]</span><span class=\"pl-kos\">[</span><span class=\"pl-c1\">0</span><span class=\"pl-kos\">]</span><span class=\"pl-kos\">;</span>\n  <span class=\"pl-k\">const</span> <span class=\"pl-s1\">secondEntryFilename</span> <span class=\"pl-c1\">=</span> <span class=\"pl-s1\">entries</span><span class=\"pl-kos\">[</span><span class=\"pl-c1\">1</span><span class=\"pl-kos\">]</span><span class=\"pl-kos\">[</span><span class=\"pl-c1\">1</span><span class=\"pl-kos\">]</span><span class=\"pl-kos\">.</span><span class=\"pl-c1\">name</span><span class=\"pl-kos\">;</span>\n  <span class=\"pl-smi\">console</span><span class=\"pl-kos\">.</span><span class=\"pl-en\">log</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">firstEntryName</span><span class=\"pl-kos\">,</span> <span class=\"pl-s1\">secondEntryName</span><span class=\"pl-kos\">,</span> <span class=\"pl-s1\">secondEntryFilename</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\">For browsers, specifying <code class=\"notranslate\">multipart/form-data</code> parsing is not a big priority, since there are not many use cases for them, and the <code class=\"notranslate\">formData()</code> method has been broken for 8 years or so. But for WinterCG runtimes with a fetch-based HTTP server API, being able to parse form submissions with the existing fetch API is crucial, and being able to accurately parse the form submissions that all browser engines are currently submitting is a large part of that. So this seems like a very interesting issue to tackle as part of the WinterCG project.</p>",
            "url": "https://github.com/wintercg/fetch/issues/9",
            "title": "Work on standardizing multipart/form-data parsing (for `Request.prototype.formData`)",
            "date_modified": "2022-10-12T07:46:08.000Z",
            "date_published": "2022-07-30T20:14:29.000Z",
            "author": {
                "name": "andreubotella",
                "url": "https://github.com/andreubotella"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/2842176?v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><p dir=\"auto\">E.g. <code class=\"notranslate\">fetch('/foo')</code>, what should the whole URL should be?</p>",
            "url": "https://github.com/wintercg/fetch/issues/8",
            "title": "URL with relative uri",
            "date_modified": "2022-09-10T17:12:00.000Z",
            "date_published": "2022-06-30T17:13:19.000Z",
            "author": {
                "name": "XadillaX",
                "url": "https://github.com/XadillaX"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/11720408?u=81d18186faaee6e6a77cb714e55240f238480871&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><p dir=\"auto\">Platforms like <a href=\"https://developers.cloudflare.com/workers/runtime-apis/request/\" rel=\"nofollow\">Cloudflare Workers</a> or <a href=\"https://shopify.dev/custom-storefronts/oxygen/worker-runtime-apis#custom-headers\" rel=\"nofollow\">Shopify Oxygen</a> may need to add additional information to requests/responses. Cloudflare Workers has a proprietary <a href=\"https://developers.cloudflare.com/workers/runtime-apis/request/#incomingrequestcfproperties\" rel=\"nofollow\"><code class=\"notranslate\">.cf</code> property</a> which includes fields like geolocation data etc. Shopify's Oxygen runtime has similar needs but uses custom HTTP headers to pass the data.</p>\n<p dir=\"auto\">Since the standard doesn't offer any way to pass extra meta information along with <code class=\"notranslate\">Request</code>/<code class=\"notranslate\">Response</code> instances, it would be great to explore these and similar scenarios to see how the extra meta data may be added. There likely were no use cases for this in the browser world, but on the server side, the situation is different.</p>\n<p dir=\"auto\">Using extra HTTP custom headers might be the most obvious approach, but it has a clear downside that headers have tight size limits, aren't very suitable for holding complex data, and can't contain anything that isn't directly serialisable into a string.</p>\n<p dir=\"auto\">A custom property like <code class=\"notranslate\">.meta</code> or <code class=\"notranslate\">.metadata</code> (which should hold a JavaScript object, leaving its fields up to the vendor implementation) would be more flexible but needs to be standardised.</p>",
            "url": "https://github.com/wintercg/fetch/issues/7",
            "title": "Passing platform-specific meta information with the `Request`/`Response` instances",
            "date_modified": "2022-06-29T21:17:39.000Z",
            "date_published": "2022-06-28T15:46:25.000Z",
            "author": {
                "name": "maxshirshin",
                "url": "https://github.com/maxshirshin"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/52195?v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><p dir=\"auto\">The <code class=\"notranslate\">fetch()</code> spec forbids to read and store cookies because of <a href=\"https://developer.mozilla.org/en-US/docs/Glossary/Forbidden_header_name\" rel=\"nofollow\">https://developer.mozilla.org/en-US/docs/Glossary/Forbidden_header_name</a>.<br>\nHow should handle cookies in server environments?</p>\n<p dir=\"auto\">Most implementations have allow them in some way, however this changed between all the implementations:</p>\n<ul dir=\"auto\">\n<li>Cloudflare ahttps://developers.cloudflare.com/workers/runtime-apis/headers/ <a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load title\" data-id=\"529945199\" data-permission-text=\"Title is private\" data-url=\"https://github.com/whatwg/fetch/issues/973\" data-hovercard-type=\"issue\" data-hovercard-url=\"/whatwg/fetch/issues/973/hovercard\" href=\"https://github.com/whatwg/fetch/issues/973\">whatwg/fetch#973</a></li>\n<li>Deno (It seems it allows all the Forbidden Header names - <a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/lucacasonato/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/lucacasonato\">@lucacasonato</a> please edit this issue to confirm, possibly add a reference).</li>\n<li>node-fetch (<a href=\"https://www.npmjs.com/package/node-fetch#extract-set-cookie-header\" rel=\"nofollow\">https://www.npmjs.com/package/node-fetch#extract-set-cookie-header</a>)</li>\n</ul>\n<p dir=\"auto\">I think it would be a good way to create a shared standard for this behavior.</p>",
            "url": "https://github.com/wintercg/fetch/issues/6",
            "title": "Cookies and fetch() on servers",
            "date_modified": "2022-05-30T21:57:23.000Z",
            "date_published": "2022-05-27T10:50:14.000Z",
            "author": {
                "name": "mcollina",
                "url": "https://github.com/mcollina"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/42794878?u=c2da6d9d9cc86ff6ae7bd4c089f2cdbb9ff01a84&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><p dir=\"auto\">Currently, both the <code class=\"notranslate\">Request</code> and <code class=\"notranslate\">Response</code> classes contain a bunch of properties that likely have no effect server-side.</p>\n<h1 dir=\"auto\">Request:</h1>\n<ol dir=\"auto\">\n<li><a href=\"https://fetch.spec.whatwg.org/#concept-request-destination\" rel=\"nofollow\"><code class=\"notranslate\">request.destination</code></a></li>\n<li><a href=\"https://fetch.spec.whatwg.org/#concept-request-referrer\" rel=\"nofollow\"><code class=\"notranslate\">request.referrer</code></a></li>\n<li><a href=\"https://fetch.spec.whatwg.org/#concept-request-referrer-policy\" rel=\"nofollow\"><code class=\"notranslate\">request.referrerPolicy</code></a></li>\n<li><a href=\"https://fetch.spec.whatwg.org/#concept-request-mode\" rel=\"nofollow\"><code class=\"notranslate\">request.mode</code></a> *</li>\n<li><a href=\"https://fetch.spec.whatwg.org/#concept-request-cache-mode\" rel=\"nofollow\"><code class=\"notranslate\">request.cache</code></a> \"...indicating how the request will interact with the browserâ€™s cache when fetching\"</li>\n<li><a href=\"https://fetch.spec.whatwg.org/#concept-request-integrity-metadata\" rel=\"nofollow\"><code class=\"notranslate\">request.integrity</code></a> \"A cryptographic hash of the resource to be fetched by request.\"</li>\n<li><a href=\"https://fetch.spec.whatwg.org/#concept-request-reload-navigation-flag\" rel=\"nofollow\"><code class=\"notranslate\">request.isReloadNavigation</code></a></li>\n<li><a href=\"https://fetch.spec.whatwg.org/#concept-request-history-navigation-flag\" rel=\"nofollow\"><code class=\"notranslate\">request.isHistoryNavigation</code></a></li>\n</ol>\n<h1 dir=\"auto\">RequestInit</h1>\n<p dir=\"auto\">(options that are passed to the <code class=\"notranslate\">Request</code> constructor)</p>\n<ol dir=\"auto\">\n<li><code class=\"notranslate\">RequestInit.referrer</code>: \"A string whose value is a same-origin URL\"</li>\n<li><code class=\"notranslate\">RequestInit.referrerPolicy</code>: \"A <a href=\"https://w3c.github.io/webappsec-referrer-policy/#referrer-policy\" rel=\"nofollow\">referrer policy</a> to set requestâ€™s <a href=\"https://fetch.spec.whatwg.org/#dom-request-referrerpolicy\" rel=\"nofollow\">referrerPolicy</a>.\"</li>\n<li><code class=\"notranslate\">RequestInit.mode</code>: \"A string to indicate whether the request will use CORS, or will be restricted to same-origin URLs. Sets requestâ€™s <a href=\"https://fetch.spec.whatwg.org/#dom-request-mode\" rel=\"nofollow\">mode</a>. If input is a string, it defaults to \"cors\".\"</li>\n<li><code class=\"notranslate\">RequestInit.credentials</code>: see <code class=\"notranslate\">request.credentials</code> *</li>\n<li><code class=\"notranslate\">RequestInit.cache</code>: see <code class=\"notranslate\">request.cache</code></li>\n<li><code class=\"notranslate\">RequestInit.integrity</code>: see <code class=\"notranslate\">request.integrity</code></li>\n<li><code class=\"notranslate\">RequestInit.window</code>: \"Can only be null. Used to disassociate request from any <a href=\"https://html.spec.whatwg.org/multipage/window-object.html#window\" rel=\"nofollow\">Window</a>.\"</li>\n</ol>\n<h1 dir=\"auto\">Response</h1>\n<ol dir=\"auto\">\n<li><a href=\"https://fetch.spec.whatwg.org/#concept-response-type\" rel=\"nofollow\"><code class=\"notranslate\">response.type</code></a> **</li>\n</ol>\n<p dir=\"auto\">* <code class=\"notranslate\">omit</code> and <code class=\"notranslate\">include</code> may be useful for developers, however <code class=\"notranslate\">same-origin</code> is not.<br>\n** <code class=\"notranslate\">cors</code> should be omitted from this type.</p>\n<h1 dir=\"auto\">Implementations:</h1>\n<ul dir=\"auto\">\n<li>node.js: implements \"everything\" according to the spec (even things that aren't relevant to a server environment).</li>\n<li>Deno: <a href=\"https://deno.land/manual/runtime/web_platform_apis#fetch-api\" rel=\"nofollow\">https://deno.land/manual/runtime/web_platform_apis#fetch-api</a></li>\n<li>node-fetch: <a href=\"https://github.com/node-fetch/node-fetch#class-request\">https://github.com/node-fetch/node-fetch#class-request</a></li>\n<li>Cloudflare workers: <a href=\"https://developers.cloudflare.com/workers//runtime-apis/request#requestinit\" rel=\"nofollow\">https://developers.cloudflare.com/workers//runtime-apis/request#requestinit</a> <a href=\"https://developers.cloudflare.com/workers//runtime-apis/request#properties\" rel=\"nofollow\">https://developers.cloudflare.com/workers//runtime-apis/request#properties</a></li>\n</ul>\n<h1 dir=\"auto\">Aligning Behavior</h1>\n<p dir=\"auto\">As you can see, each environment is different in supported properties which can cause cross-platform confusion. It also makes everything <em>more</em> confusing considering that these platforms typically leave in unsupported properties in their typings, but do not document which types are ignored (unless you look for it on google).</p>\n<h1 dir=\"auto\">Potential Solutions:</h1>\n<ol dir=\"auto\">\n<li>Choose default values to return for useless flags (for example, node.js' Request class will always return <code class=\"notranslate\">false</code> for <code class=\"notranslate\">request.isHistoryNavigation</code>). Default flags would also be needed for <code class=\"notranslate\">RequestInit</code> as the spec heavily defines fetch's behavior from certain flags being set.</li>\n<li>Fork the fetch spec and remove mentions of these flags, along with conditions that would no longer be possible with said flags being removed. This would be a lot of work.</li>\n<li>Create a new document that would supersede certain steps/behaviors in the fetch spec. For example:</li>\n</ol>\n<div class=\"snippet-clipboard-content notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"&lt;-- Original fetch spec --&gt;\n\n# some title\n1. If request's mode is &quot;cors&quot; then:\n   ...\n2. Perform scheme fetch.\n3. If request's `referrer` is not this's current settings origin url then:\n   1. Abort this request.\n   2. Return a network error.\n// and so on\"><pre class=\"notranslate\"><code>&lt;-- Original fetch spec --&gt;\n\n# some title\n1. If request's mode is \"cors\" then:\n   ...\n2. Perform scheme fetch.\n3. If request's `referrer` is not this's current settings origin url then:\n   1. Abort this request.\n   2. Return a network error.\n// and so on\n</code></pre></div>\n<div class=\"snippet-clipboard-content notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"&lt;-- Server environment spec --&gt;\n\n# some title\n1. Ignore step 1\n3. Ignore step 3\n// and so on\"><pre class=\"notranslate\"><code>&lt;-- Server environment spec --&gt;\n\n# some title\n1. Ignore step 1\n3. Ignore step 3\n// and so on\n</code></pre></div>",
            "url": "https://github.com/wintercg/fetch/issues/5",
            "title": "Request/Response browser differences",
            "date_modified": "2022-09-08T21:29:02.000Z",
            "date_published": "2022-05-20T20:41:17.000Z",
            "author": {
                "name": "KhafraDev",
                "url": "https://github.com/KhafraDev"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/14309773?v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><p dir=\"auto\">The <a href=\"https://fetch.spec.whatwg.org/#scheme-fetch\" rel=\"nofollow\">WHATWG Fetch spec</a> says this regarding fetching of URLs using the <code class=\"notranslate\">file:</code> protocol:</p>\n<blockquote>\n<p dir=\"auto\">For now, unfortunate as it is, file <a href=\"https://url.spec.whatwg.org/#concept-url\" rel=\"nofollow\">URLs</a> are left as an exercise for the reader.</p>\n<p dir=\"auto\">When in doubt, return a <a href=\"https://fetch.spec.whatwg.org/#concept-network-error\" rel=\"nofollow\">network error</a>.</p>\n</blockquote>\n<p dir=\"auto\">That'd be nice to have a standard way for handling those.</p>",
            "url": "https://github.com/wintercg/fetch/issues/4",
            "title": "Standardize fetch calls to `file:` URLs",
            "date_modified": "2022-08-24T08:45:20.000Z",
            "date_published": "2022-05-17T10:12:57.000Z",
            "author": {
                "name": "aduh95",
                "url": "https://github.com/aduh95"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/1566869?u=2503348c06c35836486e92d9bcb983557dc4e955&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><p dir=\"auto\">As outlined at <a href=\"https://github.com/whatwg/fetch/issues/973\" data-hovercard-type=\"issue\" data-hovercard-url=\"/whatwg/fetch/issues/973/hovercard\">WHATWG/fetch</a> there is often the need in a server environment to access cookie headers.</p>\n<p dir=\"auto\">For example editing Cookie headers:</p>\n<div class=\"highlight highlight-source-ts notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"const h = new Headers;\nh.append(&quot;Set-Cookie&quot;, &quot;a=1; Expires=Wed, 21 Oct 2015 07:28:00 GMT&quot;);\nh.append(&quot;Set-Cookie&quot;, &quot;b=1; Expires=Wed, 21 Oct 2015 07:28:00 GMT&quot;);\n\nh.get(&quot;Set-Cookie&quot;)\n// a=1; Expires=Wed, 21 Oct 2015 07:28:00 GMT, b=1; Expires=Wed, 21 Oct 2015 07:28:00 GMT\"><pre><span class=\"pl-k\">const</span> <span class=\"pl-s1\">h</span> <span class=\"pl-c1\">=</span> <span class=\"pl-k\">new</span> <span class=\"pl-smi\">Headers</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-s1\">h</span><span class=\"pl-kos\">.</span><span class=\"pl-en\">append</span><span class=\"pl-kos\">(</span><span class=\"pl-s\">\"Set-Cookie\"</span><span class=\"pl-kos\">,</span> <span class=\"pl-s\">\"a=1; Expires=Wed, 21 Oct 2015 07:28:00 GMT\"</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-s1\">h</span><span class=\"pl-kos\">.</span><span class=\"pl-en\">append</span><span class=\"pl-kos\">(</span><span class=\"pl-s\">\"Set-Cookie\"</span><span class=\"pl-kos\">,</span> <span class=\"pl-s\">\"b=1; Expires=Wed, 21 Oct 2015 07:28:00 GMT\"</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">;</span>\n\n<span class=\"pl-s1\">h</span><span class=\"pl-kos\">.</span><span class=\"pl-en\">get</span><span class=\"pl-kos\">(</span><span class=\"pl-s\">\"Set-Cookie\"</span><span class=\"pl-kos\">)</span>\n<span class=\"pl-c\">// a=1; Expires=Wed, 21 Oct 2015 07:28:00 GMT, b=1; Expires=Wed, 21 Oct 2015 07:28:00 GMT</span></pre></div>\n<p dir=\"auto\"><code class=\"notranslate\">Headers.prototype.getAll</code> would solve this problem, but was removed from the browser specification. Should we standardize on adding it back? Or should we define a new method all together? Ideally we should align with <code class=\"notranslate\">node-fetch</code> and <code class=\"notranslate\">undici</code> as well.</p>",
            "url": "https://github.com/wintercg/fetch/issues/3",
            "title": "Standardize access to cookie headers",
            "date_modified": "2022-06-14T20:19:08.000Z",
            "date_published": "2022-05-12T14:00:37.000Z",
            "author": {
                "name": "blittle",
                "url": "https://github.com/blittle"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/241506?u=5c10f2bbf617c297b2ceb8d0e827906007a7d5a7&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><h2 dir=\"auto\">Proposal</h2>\n<p dir=\"auto\">I would like to propose that the CG pursue standardization of Mutual TLS authentication in the <code class=\"notranslate\">fetch</code> API.</p>\n<p dir=\"auto\">This is a feature that is not likely to be implemented by browser runtimes but is in my opinion missing in non-browser runtimes where <code class=\"notranslate\">fetch</code> is the only interoperable HTTP client.</p>\n<p dir=\"auto\">The use-case I have in mind is implementation of OAuth <a href=\"https://www.rfc-editor.org/rfc/rfc8705.html#name-mutual-tls-for-oauth-client\" rel=\"nofollow\">mTLS Client Authentication</a> and <a href=\"https://www.rfc-editor.org/rfc/rfc8705.html#name-mutual-tls-client-certifica\" rel=\"nofollow\">Client Certificate-Bound Access Tokens</a>.</p>\n<h2 dir=\"auto\">Prior Art</h2>\n<p dir=\"auto\"><strong>Node.js</strong> - <a href=\"https://nodejs.org/api/https.html#httpsgetoptions-callback\" rel=\"nofollow\"><code class=\"notranslate\">https</code> module</a> has the option to provide the <code class=\"notranslate\">cert</code>, <code class=\"notranslate\">key</code>, <code class=\"notranslate\">crl</code>, <code class=\"notranslate\">passphrase</code>, <code class=\"notranslate\">pfx</code>, and <code class=\"notranslate\">ca</code> options.</p>\n<p dir=\"auto\"><strong>Deno</strong> - using <code class=\"notranslate\">deno --unstable</code> there's <code class=\"notranslate\">Deno.createHttpClient</code>, the result of which can be passed as a <code class=\"notranslate\">client</code> property to <code class=\"notranslate\">fetch</code>'s <code class=\"notranslate\">init</code> argument. This method accepts <code class=\"notranslate\">certChain</code>, <code class=\"notranslate\">privateKey</code>, and <code class=\"notranslate\">caCerts</code> options.</p>",
            "url": "https://github.com/wintercg/fetch/issues/2",
            "title": "Mutual TLS (mTLS)",
            "date_modified": "2022-05-17T12:32:18.000Z",
            "date_published": "2022-04-21T11:31:57.000Z",
            "author": {
                "name": "panva",
                "url": "https://github.com/panva"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/1315533?v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><p dir=\"auto\">We should discuss things like cors behavior - there are questions/suggestions about this in <a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load title\" data-id=\"1187175060\" data-permission-text=\"Title is private\" data-url=\"https://github.com/nodejs/undici/issues/1315\" data-hovercard-type=\"pull_request\" data-hovercard-url=\"/nodejs/undici/pull/1315/hovercard?comment_id=1085012282&amp;comment_type=issue_comment\" href=\"https://github.com/nodejs/undici/pull/1315#issuecomment-1085012282\">nodejs/undici#1315 (comment)</a></p>\n<p dir=\"auto\">I think <a href=\"https://deno.land/manual/runtime/web_platform_apis#spec-deviations\" rel=\"nofollow\">https://deno.land/manual/runtime/web_platform_apis#spec-deviations</a> is a good baseline but I would request the following deviations for what we standardize:</p>\n<ol dir=\"auto\">\n<li>The server user agent does not have a cookie jar. As such, the set-cookie header on a response is not processed, or filtered from the visible response headers.</li>\n<li>Servers do not follow the same-origin policy, because the http agent currently does not have the concept of origins, and it does not have a cookie jar. This means servers do not need to protect against leaking authenticated data cross origin. Because of this servers do not implement the following sections of the WHATWG fetch specification:</li>\n</ol>\n<ul dir=\"auto\">\n<li>Section 3.1. 'Origin' header.</li>\n<li>Section 3.2. CORS protocol.</li>\n<li>Section 3.5. CORB.</li>\n<li>Section 3.6. 'Cross-Origin-Resource-Policy' header.</li>\n<li>Atomic HTTP redirect handling.</li>\n<li>The opaqueredirect response type.</li>\n</ul>\n<ol start=\"3\" dir=\"auto\">\n<li>A fetch with a redirect mode of manual will return a basic response rather than an opaqueredirect response.</li>\n<li>The request and response header guards are implemented, but unlike browsers do not have any constraints on which header names are allowed.</li>\n<li>The referrer, referrerPolicy, mode, credentials, cache, integrity, keepalive, and window properties and their relevant behaviours in RequestInit are not implemented. The relevant fields are not present on the Request object.</li>\n</ol>\n<p dir=\"auto\">Of course, this would need to be bike-shedded and written more formally. Please suggest any more deviations we'd want here.</p>\n<p dir=\"auto\">Note this list omits the handling of <code class=\"notranslate\">file:</code> urls. Node.js does not wish to implement file url support at the moment because of security concerns. People (<a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/mcollina/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/mcollina\">@mcollina</a> for example) have raised good concerns it would be too easy to get a <code class=\"notranslate\">file</code> url from a user and pass that to <code class=\"notranslate\">fetch</code>. I think it's probably fine for servers/edge to deviate on this?</p>\n<p dir=\"auto\">cc <a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/lucacasonato/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/lucacasonato\">@lucacasonato</a></p>",
            "url": "https://github.com/wintercg/fetch/issues/1",
            "title": "Standardize supported subset of `fetch`",
            "date_modified": "2022-05-10T20:01:01.000Z",
            "date_published": "2022-04-01T13:01:20.000Z",
            "author": {
                "name": "benjamingr",
                "url": "https://github.com/benjamingr"
            }
        }
    ]
}